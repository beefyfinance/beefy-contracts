// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin-4/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin-4/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin-4/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin-4/contracts/token/ERC721/IERC721Receiver.sol";

import "./IDystopiaBoostStrategy.sol";
import "./IVoter.sol";
import "./IVeDist.sol";
import "./DystManager.sol";

contract DystopiaStaker is ERC20, DystManager,  ReentrancyGuard {
    using SafeERC20 for IERC20;
    using SafeMath for uint256;

    // beToken fee taken from strats
    uint256 public beTokenShare;
    
    // Strategy mapping 
    mapping(address => mapping (uint256 => address)) public whitelistedStrategy;
    mapping(address => address) public replacementStrategy;

    IVoter public dystVoter;
    IVeToken public veToken;
    IVeDist public veDist;
    uint256 public veTokenId;
    IERC20 public want;
    address public treasury;

    event Deposit(address indexed user, uint256 pid, uint256 amount);
    event Withdraw(address indexed user, uint256 pid, uint256 amount);
    event EmergencyWithdraw(address indexed user, uint256 pid, uint256 amount);

    event CreateLock(address indexed user, uint256 veTokenId, uint256 amount, uint256 unlockTime);
    event Release(address indexed user, uint256 veTokenId, uint256 amount);
    event IncreaseTime(address indexed user, uint256 veTokenId, uint256 unlockTime);
    event IncreaseAmount(address indexed user, uint256 veTokenId, uint256 amount);
    event ClaimVeEmissions(address indexed user, uint256 veTokenId, uint256 amount);
    event ClaimOwnerRewards(address indexed user, uint256[] pids, address[][] tokens);
    event TransferVeToken(address indexed user, address to, uint256 veTokenId);

    constructor(
        string memory _name,
        string memory _symbol,
        address _dystVoter,
        address _treasury,
        address _keeper,
        address _voter
    ) public ERC20(
        _name,
        _symbol
    ) {
        dystVoter = IVoter(_dystVoter);
        veToken = IVeToken(dystVoter._ve());
        want = IERC20(veToken.token());
        IMinter _minter = IMinter(dystVoter.minter());
        veDist = IVeDist(_minter._ve_dist());
        treasury = _treasury;
        keeper = _keeper;
        beefyVoter = _beefyVoter;

        want.safeApprove(address(veToken), uint256(-1));
    }

    function setVeTokenId(uint256 _veTokenId) external onlyManager {
        require(_veTokenId == 0 || veToken.ownerOf(_veTokenId) == address(this), "!veTokenId");
        veTokenId = _veTokenId;
    }

    function setVeDist(address _veDist) external onlyOwner {
        veDist = IVeDist(_veDist);
    }

    function setTreasury(address _treasury) external onlyOwner {
        treasury = _treasury;
    }

    // pause deposits
    function pause() public onlyManager {
        _pause();
    }

    // unpause deposits
    function unpause() external onlyManager {
        _unpause();
    }

    // Get Rewards and send to strat
    function harvestRewards(address _gauge, address[] calldata tokens) external onlyWhitelist(_gauge) {
        IGauge(_gauge).getReward(address(this), tokens);
        for (uint i; i < tokens.length; ++i) {
            IERC20(tokens[i]).safeTransfer(msg.sender, IERC20(tokens[i].balanceOf(address(this))));
        }
    }

    // Pass through a deposit to a boosted chef
    function deposit(address _gauge, uint256 _amount) external onlyWhitelist(_gauge) {
        // Grab needed info
        address _underlying = IDystopiaBoostedStrategy(_gauge).want();
        // Take before balances snapshot and transfer want from strat
        IERC20(_underlying).safeTransferFrom(msg.sender, address(this), _amount);
        IGauge(_gauge).deposit(_amount, tokenId);
    }

    // Pass through a withdrawal from boosted chef
    function withdraw(address _gauge, uint256 _amount) external onlyWhitelist(_gauge) {
        // Grab needed pool info
        address _underlying = IDystopiaBoostedStrategy(_gauge).want(); 
        uint256 _before = IERC20(_underlying).balanceOf(address(this));       
        IGauge(_gauge).withdraw(_pid, _amount);
        uint256 _balance = IERC20(_underlying).balanceOf(address(this)) - _before;
        IERC20(_underlying).safeTransfer(msg.sender, _balance);
    }

    /**
     * @dev Updates address of the batch.
     * @param _dystBatch new batch address.
     */
    function setBatch(address _dystBatch) external onlyOwner {
        emit NewCakeBatch(dystBatch, _dystBatch);
        dystBatch = _dystBatch;
    }

    /**
     * @dev Updates share for the Batch.
     * @param _newBeTokenShare new share.
     */
    function setBeTokenShare(uint256 _newBeTokenShare) external onlyManager {
        require(_newBeTokenShare <= 1000, "too much");
        emit NewBeTokenShare(beTokenShare, _newBeTokenShare);
        beTokenShare = _newBeTokenShare;
    }

    // Set Lock Duration
    function setDuration(uint256 _days) external onlyOwner {
        require(_days * 1 days <= MAX_DURATION, "Higher than max");
        require(_days * 1 days >= 1 weeks || _days == 0, "Week min");
        duration = _days * 1 days;
        emit UpdatedDuration(duration);
    }

    // Set Lock 
    function setLock(bool _lock) external onlyOwner {
        lock = _lock;
        emit UpdatedLock(lock);
    }

    // Set reward bool
    function setPayRewards(bool _payRewards) external onlyOwner {
        payRewards = _payRewards;
        emit UpdatedPayRewards(payRewards);
    }

    // Adjust reserve rate 
    function adjustReserve(uint256 _rate) external onlyOwner {
        require(_rate <= MAX, "Higher than max");
        reserveRate = _rate;
        emit UpdatedReserveRate(_rate);
    }

    /**
     * @dev Whitelists a strategy address to interact with the Boosted Chef and gives approvals.
     * @param _strategy new strategy address.
     */
    function whitelistStrategy(address _strategy) external onlyManager {
        IERC20 _want = IDystopiaBoostStrategy(_strategy).want();
        address _gauge = IDystopiaBoostStrategy(_strategy).gauge();
        uint256 stratBal = IGauge(_gauge).balanceOf(address(this));
        require(stratBal == 0, "!inactive");

        _want.safeApprove(_gauge, 0);
        _want.safeApprove(_gauge, type(uint256).max);
        whitelistedStrategy[_gauge] = _strategy;
    }

    /**
     * @dev Removes a strategy address from the whitelist and remove approvals.
     * @param _strategy remove strategy address from whitelist.
     */
    function blacklistStrategy(address _strategy) external onlyManager {
        IERC20 _want = IDystopiaBoostStrategy(_strategy).want();
        uint256 _gauge = IDystopiaBoostStrategy(_strategy).gauge();
        _want.safeApprove(_gauge, 0);
        whitelistedStrategy[_gauge] = address(0);
    }

    /**
     * @dev Prepare a strategy to be retired and replaced with another.
     * @param _oldStrategy strategy to be replaced.
     * @param _newStrategy strategy to be implemented.
     */
    function proposeStrategy(address _oldStrategy, address _newStrategy) external onlyManager {
        require(IDystopiaBoostStrategy(_oldStrategy).gauge() == IDystopiaBoostStrategy(_newStrategy).gauge(), "!gauge");
        replacementStrategy[_oldStrategy] = _newStrategy;
    }

    /**
     * @dev Switch over whitelist from one strategy to another for a gauge.
     * @param _pid pid for which the new strategy will be whitelisted.
     */
    function upgradeStrategy(address _gauge) external onlyWhitelist(_gauge) {
        whitelistedStrategy[_gauge] = replacementStrategy[msg.sender];
    }

    // claim veToken emissions and increases locked amount in veToken
    function claimVeEmissions() external {
        uint256 _amount = veDist.claim(veTokenId);
        emit ClaimVeEmissions(msg.sender, veTokenId, _amount);
    }

    // vote for emission weights
    function vote(uint256 _veTokenId, address[] calldata _tokenVote, int256[] calldata _weights) external onlyVoter {
        voter.vote(_veTokenId, _tokenVote, _weights);
    }

    // reset current votes
    function resetVote(uint256 _veTokenId) external onlyVoter {
        voter.reset(_veTokenId);
    }

    // claim owner rewards such as trading fees and bribes from gauges, transferred to treasury
    function claimOwnerRewards(uint256[] memory _pids, address[][] memory _tokens) external onlyVoter {
        for (uint256 i; i < _pids.length; i++) {
            PoolInfo storage pool = poolInfo[_pids[i]];

            pool.bribe.getReward(veTokenId, _tokens[i]);
            for (uint256 j; j < _tokens[i].length; j++) {
                address _reward = _tokens[i][j];
                uint256 _rewardBal = IERC20(_reward).balanceOf(address(this)).sub(storedRewardBalance[_reward]);

                if (_rewardBal > 0) {
                    IERC20(_reward).safeTransfer(treasury, _rewardBal);
                }
            }
        }

        emit ClaimOwnerRewards(msg.sender, _pids, _tokens);
    }

    // create a new veToken if none is assigned to this address
    function createLock(uint256 _amount, uint256 _lock_duration) external onlyManager {
        require(veTokenId == 0, "veToken > 0");
        require(_amount > 0, "amount == 0");

        want.safeTransferFrom(address(msg.sender), address(this), _amount);
        veTokenId = veToken.create_lock(_amount, _lock_duration);

        emit CreateLock(msg.sender, veTokenId, _amount, _lock_duration);
    }

    // release expired lock of a non-main veToken owned by this address and transfer want token to treasury
    function release(uint256 _veTokenId) external onlyManager {
        require(_veTokenId > 0 && veTokenId != _veTokenId, "!veTokenId");

        veToken.withdraw(_veTokenId);
        uint256 _wantBal = want.balanceOf(address(this)).sub(storedRewardBalance[address(want)]);
        safeTransfer(want, treasury, _wantBal);

        emit Release(msg.sender, _veTokenId, _wantBal);
    }

    // merge voting power of two veTokens by burning the _from veToken, _from must be detached and not voted with
    function merge(uint256 _fromId, uint256 _toId) external onlyManager {
        require(_fromId != veTokenId, "cannot burn main veTokenId");
        veToken.merge(_fromId, _toId);
    }

    // extend lock time for veToken to increase voting power
    function increaseUnlockTime(uint256 _lock_duration) external onlyManager {
        veToken.increase_unlock_time(veTokenId, _lock_duration);
        emit IncreaseTime(msg.sender, veTokenId, _lock_duration);
    }

    // deposit an amount of want
    function deposit(uint256 _amount) external {
        _deposit(msg.sender, _amount);
    }

    // deposit an amount of want token on behalf of an address
    function depositFor(address _user, uint256 _amount) external {
        _deposit(_user, _amount);
    }

    // transfer an amount of want token to this address and lock into veToken
    function _deposit(address _user, uint256 _amount) internal whenNotPaused nonReentrant {
        want.safeTransferFrom(msg.sender, address(this), _amount);
        uint256 wantBal = want.balanceOf(address(this)).sub(storedRewardBalance[address(want)]);

        if (_amount > wantBal) {
            _amount = wantBal;
        }

        veToken.increase_amount(veTokenId, _amount);
        _mint(_user, _amount);

        emit IncreaseAmount(msg.sender, veTokenId, _amount);
    }

    // whitelist new token
    function whitelist(address _token) external onlyManager {
        voter.whitelist(_token, veTokenId);
    }

    // transfer veToken to another address, must be detached from all gauges first
    function transferVeToken(address _to, uint256 _veTokenId) external onlyOwner {
        if (veTokenId == _veTokenId) {
            veTokenId = 0;
        }
        veToken.safeTransferFrom(address(this), _to, _veTokenId);

        emit TransferVeToken(msg.sender, _to, _veTokenId);
    }

    // confirmation required for receiving veToken to smart contract
    function onERC721Received(
        address operator,
        address from,
        uint tokenId,
        bytes calldata data
    ) external view returns (bytes4) {
        operator;
        from;
        tokenId;
        data;
        require(msg.sender == address(veToken), "!veToken");
        return bytes4(keccak256("onERC721Received(address,address,uint,bytes)"));
    }
}