// SPDX-License-Identifier: MIT

pragma solidity ^0.6.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/utils/Address.sol";

import "../../interfaces/common/IUniswapRouter.sol";
import "../../interfaces/fryworld/IDeepFryer.sol";

/**
 * @dev Implementation of a strategy to get yields from farming the FRIES token. 
 * Fry.world is a yield optimizer that is allowing users to farm their token.
 * The strategy simply deposits whatever funds it receives from the vault into the DeepFryer,
 * which is clone of Sushiswap's MasterChef contract. Rewards generated in FRIES can regularly be harvested, 
 * swapped for the original vault asset, and deposited again for compound farming.
 * This strat is currently compatible with: wBNB and BUSD. The token to use is configured with a constructor argument.
 */ 

contract StrategyFry {
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;

    /** 
     * @dev Tokens Used:
     * {output} - Token generated by staking our funds. In this case it's the FRIES token. 
     * {wbnb} - Required for liquidity routing when doing swaps.
     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. 
     */
    address constant public output = address(0x393B312C01048b3ed2720bF1B090084C09e408A1);
    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c); 
    address  public want; 

    /**
     * @dev Third Party Contracts:
     * {unirouter} - AMM used to swap from {output} into {want}
     * {deepFryer} - MasterChef modified contract. Where we deposit and withdraw the funds.
     */
    address  public unirouter = address(0xBf6527834dBB89cdC97A79FCD62E6c08B19F8ec0);
    address constant public deepFryer = address(0x066d5544A0b05B19f08E45Dbc13758a3590386C4);
    
    /**
     * @dev Beefy Contracts:
     * {rewards} - Reward pool where the strategy fee earnings will go.
     * {vault} - Address of the vault that controls the strategy's funds.
     */
    address public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C); 
    address public vault;

    /** 
     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().
     Current implementation separates 5% for fees.
     * {fee} - 4% goes to BIFI holders through the {rewards} pool.
     * {callfee} - 1% goes to whoever executes the harvest function as gas subsidy.
     * {withdrawalFee} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.
     */
    uint public fee = 800; 
    uint public callfee = 200;
    uint constant public max = 1000;      
 
    uint public withdrawalFee = 10;
    uint constant public withdrawalMax = 10000;

    /**
     * @dev Routes we take to swap tokens in Unswap clones.
     * {swap2TokenRouting} - Route we take to get from {output} into {want}.
     * {swap2WbnbRouting} - Route we take to get from {output} into {wbnb}.
     * {want2WbnbRouting} - Route we take to get from {want} into {wbnb}.
     */
    address[] public swap2TokenRouting;
    address[] public swap2WbnbRouting;
    address[] public want2WbnbRouting;

    // Convenience value for UIs to display the strat name. It is initialized on contract deploy.
    string public getName;
    // Should be set to the index of the {want} pool in the deepFryer. BUSD index is 1 and wBNB is 2. 
    uint public poolIndex;

    /**
     * @dev Initializes the strategy with the token that it will look to maximize.
     */   
    constructor(address _want, address _vault, uint _poolIndex) public {
        want = _want;
        vault = _vault;
        poolIndex = _poolIndex;

        getName = string(
            abi.encodePacked("Beefy:Strategy:", 
                abi.encodePacked(ERC20(want).name()," Fry World"
                )
            ));

        if (wbnb == want) {
            swap2TokenRouting = [output,want];
        } else {
            swap2TokenRouting = [output,wbnb,want]; 
        }
        swap2WbnbRouting = [output,wbnb]; 
        want2WbnbRouting = [want,wbnb];
        
        IERC20(want).safeApprove(unirouter, uint(-1));
        IERC20(output).safeApprove(unirouter, uint(-1));
    }

    /**
     * @dev Function that puts the funds to work. It gets called whenever someone deposits 
     * in the strategy's vault contract. It deposits whatever {want} it has available to 
     * farm FRIES in the deep fryer.
     */        
    function deposit() public {
        uint _want = IERC20(want).balanceOf(address(this));
        if (_want > 0) {
            IERC20(want).safeApprove(deepFryer, 0);
            IERC20(want).safeApprove(deepFryer, _want);
            IDeepFryer(deepFryer).deposit(poolIndex, _want);
        }
    }

    /**
     * @dev It withdraws funds from fry and sents them back to the vault.
     * Gets called when users withdraw from the parent vault.
     */    
    function withdraw(uint _amount) external {
        require(msg.sender == vault, "!vault");
        uint _balance = IERC20(want).balanceOf(address(this));
        if (_balance < _amount) {
            _amount = _withdrawSome(_amount.sub(_balance));
            _amount = _amount.add(_balance);
        }

        uint _fee = 0;
        if (withdrawalFee > 0){
            _fee = _amount.mul(withdrawalFee).div(withdrawalMax);
        }        
        
        IERC20(want).safeTransfer(vault, _amount.sub(_fee));
    }

    /**
     * @dev Internal function that manages the actual withdraw from the fry platform.
     */ 
    function _withdrawSome(uint256 _amount) internal returns (uint) {
        IDeepFryer(deepFryer).withdraw(poolIndex, _amount);
        return _amount;
    }

    /**
     * @dev Core function of the strat, in charge of collecting and re-investing rewards. 
     * 1. It claims rewards from fry's reward pool
     * 2. It swaps the FRIES token for {want} 
     * 3. It charges the system fee and sends it to BIFI stakers.
     * 4. It re-invests the remaining profits.
     */    
    function harvest() public {
        require(!Address.isContract(msg.sender),"!contract");
        IDeepFryer(deepFryer).deposit(poolIndex, 0);
        doswap();
        dosplit();
        deposit();
    }

    /**
     * @dev Swaps {output} for {want} using the established Uniswap clone.
     */
    function doswap() internal {
        if (want == wbnb) {
            uint256 _2token = IERC20(output).balanceOf(address(this));
            IUniswapRouter(unirouter).swapExactTokensForTokens(_2token, 0, swap2TokenRouting, address(this), now.add(600));
        } else {
            uint256 _2token = IERC20(output).balanceOf(address(this)).mul(95).div(100);
            uint256 _2wbnb = IERC20(output).balanceOf(address(this)).mul(5).div(100);
            uint256 _want = IERC20(want).balanceOf(address(this));
            IUniswapRouter(unirouter).swapExactTokensForTokens(_2token, 0, swap2TokenRouting, address(this), now.add(600));
            IUniswapRouter(unirouter).swapExactTokensForTokens(_2wbnb, 0, swap2WbnbRouting, address(this), now.add(600));
            if (_want > 0) {
                IUniswapRouter(unirouter).swapExactTokensForTokens(_want, 0, want2WbnbRouting, address(this), now.add(600));
            }
        }
    }

    /**
     * @dev Takes our 4% as system fees from the rewards. Takes out an extra 1% as 
     * gas subsidy and pays it out to the function caller.
     */
    function dosplit() internal {
        uint _bal = IERC20(wbnb).balanceOf(address(this));
        if (want == wbnb) {
            _bal = IERC20(wbnb).balanceOf(address(this)).mul(5).div(100);
        }

        uint _fee = _bal.mul(fee).div(max);
        uint _callfee = _bal.mul(callfee).div(max);
        IERC20(wbnb).safeTransfer(rewards, _fee);
        IERC20(wbnb).safeTransfer(msg.sender, _callfee);
    }

    /**
     * @dev Function to calculate the total underlaying {want} held by the strat.
     * It takes into account both the funds in hand, as the funds allocated in fry.
     */
    function balanceOf() public view returns (uint) {
        return balanceOfWant()
               .add(balanceOfPool());
    }

    /**
     * @dev It calculates how much {want} the contract holds.
     */    
    function balanceOfWant() public view returns (uint) {
        return IERC20(want).balanceOf(address(this));
    }

    /**
     * @dev It calculates how much {want} the strategy has allocated in fry's DeepFryer.
     */    
    function balanceOfPool() public view returns (uint) {
        (uint _amount, ) = IDeepFryer(deepFryer).userInfo(poolIndex, address(this));
        return _amount;
    }
}