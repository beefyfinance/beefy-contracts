{
  "language": "Solidity",
  "sources": {
    "contracts/BIFI/infra/BeefyFeeBatch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../interfaces/common/IUniswapRouterETH.sol\";\n\ncontract BeefyFeeBatch is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public wNative ;\n    address public bifi;\n\n    address public treasury;\n    address public rewardPool;\n    address public unirouter;\n\n    // Fee constants\n    uint constant public TREASURY_FEE = 140;\n    uint constant public REWARD_POOL_FEE = 860;\n    uint constant public MAX_FEE = 1000;\n\n    address[] public wNativeToBifiRoute;\n\n    constructor(\n        address _treasury,\n        address _rewardPool,\n        address _unirouter,\n        address _bifi,\n        address _wNative\n    ) {\n        treasury = _treasury;\n        rewardPool = _rewardPool;\n        unirouter = _unirouter;\n        bifi = _bifi;\n        wNative  = _wNative ;\n\n        wNativeToBifiRoute = [wNative, bifi];\n\n        IERC20(wNative).safeApprove(unirouter, type(uint256).max);\n    }\n\n    event NewRewardPool(address oldRewardPool, address newRewardPool);\n    event NewTreasury(address oldTreasury, address newTreasury);\n    event NewUnirouter(address oldUnirouter, address newUnirouter);\n    event NewBifiRoute(address[] oldRoute, address[] newRoute);\n\n    modifier onlyEOA() {\n        require(msg.sender == tx.origin, \"!EOA\");\n        _;\n    }\n\n    // Main function. Divides Beefy's profits.\n    function harvest() public onlyEOA {\n        uint256 wNativeBal = IERC20(wNative).balanceOf(address(this));\n\n        uint256 treasuryHalf = wNativeBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wNative).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wNativeToBifiRoute, treasury, block.timestamp);\n\n        uint256 rewardsFeeAmount = wNativeBal.mul(REWARD_POOL_FEE).div(MAX_FEE);\n        IERC20(wNative).safeTransfer(rewardPool, rewardsFeeAmount);\n    }\n\n    // Manage the contract\n    function setRewardPool(address _rewardPool) external onlyOwner {\n        emit NewRewardPool(rewardPool, _rewardPool);\n        rewardPool = _rewardPool;\n    }\n\n    function setTreasury(address _treasury) external onlyOwner {\n        emit NewTreasury(treasury, _treasury);\n        treasury = _treasury;\n    }\n\n    function setUnirouter(address _unirouter) external onlyOwner {\n        emit NewUnirouter(unirouter, _unirouter);\n\n        IERC20(wNative).safeApprove(_unirouter, type(uint256).max);\n        IERC20(wNative).safeApprove(unirouter, 0);\n\n        unirouter = _unirouter;\n    }\n\n    function setNativeToBifiRoute(address[] memory _route) external onlyOwner {\n        require(_route[0] == wNative);\n        require(_route[_route.length - 1] == bifi);\n\n        emit NewBifiRoute(wNativeToBifiRoute, _route);\n        wNativeToBifiRoute = _route;\n    }\n\n    // Rescue locked funds sent by mistake\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        require(_token != wNative, \"!safe\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/common/IUniswapRouterETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IUniswapRouterETH {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Typhoon/StrategyTyphoonLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/typhoon/ILPStaking.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyTyphoonLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x4090e535F2e251F5F88518998B18b54d26B3b07c);\n    address constant public want = address(0x687efea126216159b628Fd3F5B7dE996C6cd42D6);\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x0Db2Dd5864b33dC3c7CfE818e8F155c0aA569b45);\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            ILPStaking(masterchef).deposit(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            ILPStaking(masterchef).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        ILPStaking(masterchef).claim();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, , ,) = ILPStaking(masterchef).userInfo(address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILPStaking(masterchef).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        ILPStaking(masterchef).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/common/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IUniswapV2Pair {\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}"
    },
    "contracts/BIFI/interfaces/typhoon/ILPStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ILPStaking {\n    function userInfo(address _user) external view returns (uint256, uint256, uint256, uint256);\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _amount) external;\n    function claim() external;\n}"
    },
    "contracts/BIFI/utils/GasThrottler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"./IGasPrice.sol\";\n\ncontract GasThrottler {\n\n    address public gasprice = address(0x16cD932c494Ac1B3452d6C8453fB7665aB49EC6b);\n\n    modifier gasThrottle() {\n        require(tx.gasprice <= IGasPrice(gasprice).maxGasPrice(), \"gas is too high!\");\n        _;\n    }\n}"
    },
    "contracts/BIFI/strategies/Common/StratManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract StratManager is Ownable, Pausable {\n    /**\n     * @dev Beefy Contracts:\n     * {keeper} - Address to manage a few lower risk features of the strat\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {unirouter} - Address of exchange to execute swaps.\n     */\n    address public keeper;\n    address public strategist;\n    address public unirouter;\n    address public vault;\n    address public beefyFeeRecipient;\n\n    /**\n     * @dev Initializes the base strategy.\n     * @param _keeper address to use as alternative owner.\n     * @param _strategist address where strategist fees go.\n     * @param _unirouter router to use for swaps\n     * @param _vault address of parent vault.\n     * @param _beefyFeeRecipient address where to send Beefy's fees.\n     */\n    constructor(\n        address _keeper,\n        address _strategist,\n        address _unirouter,\n        address _vault,\n        address _beefyFeeRecipient\n    ) {\n        keeper = _keeper;\n        strategist = _strategist;\n        unirouter = _unirouter;\n        vault = _vault;\n        beefyFeeRecipient = _beefyFeeRecipient;\n    }\n\n    // checks that caller is either owner or keeper.\n    modifier onlyManager() {\n        require(msg.sender == owner() || msg.sender == keeper, \"!manager\");\n        _;\n    }\n\n    // verifies that the caller is not a contract.\n    modifier onlyEOA() {\n        require(msg.sender == tx.origin, \"!EOA\");\n        _;\n    }\n\n    /**\n     * @dev Updates address of the strat keeper.\n     * @param _keeper new keeper address.\n     */\n    function setKeeper(address _keeper) external onlyManager {\n        keeper = _keeper;\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates router that will be used for swaps.\n     * @param _unirouter new unirouter address.\n     */\n    function setUnirouter(address _unirouter) external onlyOwner {\n        unirouter = _unirouter;\n    }\n\n    /**\n     * @dev Updates parent vault.\n     * @param _vault new vault address.\n     */\n    function setVault(address _vault) external onlyOwner {\n        vault = _vault;\n    }\n\n    /**\n     * @dev Updates beefy fee recipient.\n     * @param _beefyFeeRecipient new beefy fee recipient address.\n     */\n    function setBeefyFeeRecipient(address _beefyFeeRecipient) external onlyOwner {\n        beefyFeeRecipient = _beefyFeeRecipient;\n    }\n\n    /**\n     * @dev Function to synchronize balances before new user deposit.\n     * Can be overridden in the strategy.\n     */\n    function beforeDeposit() external virtual {}\n}"
    },
    "contracts/BIFI/strategies/Common/FeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"./StratManager.sol\";\n\nabstract contract FeeManager is StratManager {\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE = 1000;\n    uint constant public MAX_CALL_FEE = 111;\n\n    uint constant public WITHDRAWAL_FEE_CAP = 50;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    uint public withdrawalFee = 10;\n\n    uint public callFee = 111;\n    uint public beefyFee = MAX_FEE - STRATEGIST_FEE - callFee;\n\n    function setCallFee(uint256 _fee) external onlyManager {\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        beefyFee = MAX_FEE - STRATEGIST_FEE - callFee;\n    }\n\n    function setWithdrawalFee(uint256 _fee) external onlyManager {\n        require(_fee <= WITHDRAWAL_FEE_CAP, \"!cap\");\n\n        withdrawalFee = _fee;\n    }\n}"
    },
    "contracts/BIFI/utils/IGasPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IGasPrice {\n    function maxGasPrice() external returns (uint);\n}"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Wault/StrategyWexPolySingle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/wault/IWaultMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyWexPolySingle is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public native;\n    address public output;\n    address public want;\n\n    // Third party contracts\n    address public chef;\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToNativeRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _chef,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n        chef = _chef;\n\n        output = _outputToNativeRoute[0];\n        native = _outputToNativeRoute[_outputToNativeRoute.length - 1];\n        outputToNativeRoute = _outputToNativeRoute;\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IWaultMasterChef(chef).deposit(poolId, wantBal, false);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IWaultMasterChef(chef).withdraw(poolId, _amount.sub(wantBal), false);\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IWaultMasterChef(chef).claim(poolId);\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toNative = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toNative, 0, outputToNativeRoute, address(this), block.timestamp);\n\n        uint256 nativeBal = IERC20(native).balanceOf(address(this));\n\n        uint256 callFeeAmount = nativeBal.mul(callFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = nativeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = nativeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(native).safeTransfer(strategist, strategistFee);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IWaultMasterChef(chef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IWaultMasterChef(chef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IWaultMasterChef(chef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(chef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(chef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/interfaces/common/IUniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IUniswapRouter {\n    function factory() external pure returns (address);\n    function WBNB() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityBNB(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountBNB, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityBNB(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountBNB);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityBNBWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountBNB);\n    function removeLiquidityBNBSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountBNB);\n    function removeLiquidityBNBWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountBNB);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactBNBForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForBNBSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactBNBForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactBNB(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForBNB(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapBNBForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/BIFI/interfaces/wault/IWaultMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IWaultMasterChef {\n    function deposit(uint256 _pid, uint256 _amount, bool _withdrawRewards) external;\n    function withdraw(uint256 _pid, uint256 _amount, bool _withdrawRewards) external;\n    function claim(uint256 _pid) external;\n    function pendingWex(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Wault/StrategyWexPolyLP.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/wault/IWaultMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyWexPolyLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public native;\n    address public output;\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address public chef;\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToNativeRoute;\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _chef,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute,\n        address[] memory _outputToLp0Route,\n        address[] memory _outputToLp1Route\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n        chef = _chef;\n\n        output = _outputToNativeRoute[0];\n        native = _outputToNativeRoute[_outputToNativeRoute.length - 1];\n        outputToNativeRoute = _outputToNativeRoute;\n\n        // setup lp routing\n        lpToken0 = IUniswapV2Pair(want).token0();\n        outputToLp0Route = _outputToLp0Route;\n\n        lpToken1 = IUniswapV2Pair(want).token1();\n        outputToLp1Route = _outputToLp1Route;\n\n        _giveAllowances();\n        callFee = 11;\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IWaultMasterChef(chef).deposit(poolId, wantBal, false);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IWaultMasterChef(chef).withdraw(poolId, _amount.sub(wantBal), false);\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IWaultMasterChef(chef).claim(poolId);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toNative = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toNative, 0, outputToNativeRoute, address(this), block.timestamp);\n\n        uint256 nativeBal = IERC20(native).balanceOf(address(this));\n\n        uint256 callFeeAmount = nativeBal.mul(callFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = nativeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = nativeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(native).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IWaultMasterChef(chef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    function outputToNative() external view returns(address[] memory) {\n        return outputToNativeRoute;\n    }\n\n    function outputToLp0() external view returns(address[] memory) {\n        return outputToLp0Route;\n    }\n\n    function outputToLp1() external view returns(address[] memory) {\n        return outputToLp1Route;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IWaultMasterChef(chef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IWaultMasterChef(chef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(chef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(chef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Swirl/StrategySwirlLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/swirl/ILiquidityMining.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in SwirlCash.\n */\ncontract StrategySwirlLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {swirl} - Token generated by staking our funds. In this case it's the SWIRL token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb   = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public swirl  = address(0x52d86850bc8207b520340B7E39cDaF22561b9E56);\n    address constant public bifi   = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public lpPair = address(0x135AeDCFb35b0b5dCf61Db7891a21253452Eb970);\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - LiquidityMining contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x9FC04657C1178F857d36D8a6B028C732D78F60E0);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {swirlToWbnbRoute} - Route we take to get from {swirl} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {swirlToLp0Route} - Route we take to get from {swirl} into {lpToken0}.\n     * {swirlToLp1Route} - Route we take to get from {swirl} into {lpToken1}.\n     */\n    address[] public swirlToWbnbRoute = [swirl, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public swirlToLp0Route;\n    address[] public swirlToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            swirlToLp0Route = [swirl, wbnb];\n        } else if (lpToken0 != swirl) {\n            swirlToLp0Route = [swirl, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            swirlToLp1Route = [swirl, wbnb];\n        } else if (lpToken1 != swirl) {\n            swirlToLp1Route = [swirl, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(swirl).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {swirl}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            ILiquidityMining(masterchef).deposit(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            ILiquidityMining(masterchef).withdraw(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {swirl} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        ILiquidityMining(masterchef).claim();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(swirl).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, swirlToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {swirl} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 swirlHalf = IERC20(swirl).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != swirl) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(swirlHalf, 0, swirlToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != swirl) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(swirlHalf, 0, swirlToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ,) = ILiquidityMining(masterchef).userInfo(address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILiquidityMining(masterchef).withdraw(balanceOfPool());\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ILiquidityMining(masterchef).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(swirl).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(swirl).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/swirl/ILiquidityMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ILiquidityMining {\n    function userInfo(address _user) external view returns (uint256, uint256, uint256);\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _amount) external;\n    function claim() external;\n}"
    },
    "contracts/BIFI/strategies/Mdex/StrategyMdexBscSingle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/mdex/IMasterChef.sol\";\nimport \"../../interfaces/mdex/ISwapMining.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming Single Pools in MDex.\n *\n * This strat needs to be adjusted for every single token to make routing via MDex or PancakeSwap\n * MDex routing is preferable as we can claim swap rewards via claimSwapRewards()\n */\ncontract StrategyMdexBscSingle is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd, usdt} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the MDX token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public usdt = address(0x55d398326f99059fF775485246999027B3197955);\n    address constant public output = address(0x9C65AB58d8d978DB963e63f2bfB7121627e3a739);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {mdxrouter} - MDex unirouter\n     * {masterchef} - MasterChef contract\n     * {swapmining} - Swap Mining contract to get trade rewards\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public mdxrouter  = address(0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8);\n    address constant public masterchef = address(0xc48FE252Aa631017dF253578B1405ea399728A50);\n    address constant public swapmining = address(0x782395303692aBeD877d2737Aa7982345eB44c11);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     *\n     * {callFee} - 0.5% goes to whoever executes the harvest. Can be lowered.\n     * {rewardsFee} - 3% that goes to BIFI holders. Can be increased by decreasing {callFee}.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n    uint constant public MAX_CALL_FEE = 111;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    uint public callFee = MAX_CALL_FEE;\n    uint public rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    /**\n     * @dev Routes we take to swap tokens using MDex and PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToWantRoute} - Route we take to get from {output} into {want}.\n     * {wbnbToWantRoute} - Route we take to go from {wbnb} into {want}.\n     * {useOutputToWantRoute} - If true use {outputToWantRoute} via MDex, otherwise use {wbnbToWantRoute} via PCS\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToWantRoute;\n    address[] public wbnbToWantRoute;\n    bool public immutable useOutputToWantRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _want, uint8 _poolId, bool _useOutputToWantRoute, address _vault, address _strategist) {\n        want = _want;\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        useOutputToWantRoute = _useOutputToWantRoute;\n        outputToWantRoute = [output, busd, want];\n        wbnbToWantRoute = [wbnb, want];\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(mdxrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {want} from the MasterChef.\n     * The available {want} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {want}\n     * 4. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(mdxrouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} rewards earned for more {want}.\n     */\n    function swapRewards() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        if (useOutputToWantRoute) {\n            IUniswapRouterETH(mdxrouter).swapExactTokensForTokens(outputBal, 0, outputToWantRoute, address(this), block.timestamp.add(600));\n        } else {\n            IUniswapRouterETH(mdxrouter).swapExactTokensForTokens(outputBal, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n            uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(wbnbBal, 0, wbnbToWantRoute, address(this), block.timestamp.add(600));\n        }\n    }\n\n    function claimSwapRewards() public onlyOwner {\n        ISwapMining(swapmining).takerWithdraw();\n    }\n\n    /**\n     * @dev Function to synchronize balances.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ,) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(mdxrouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(mdxrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external onlyOwner {\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/mdex/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMasterChef {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function pendingMdx(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/interfaces/mdex/ISwapMining.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ISwapMining {\n    function takerWithdraw() external;\n}"
    },
    "contracts/BIFI/strategies/Mdex/StrategyMdexBscLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/mdex/IMasterChef.sol\";\nimport \"../../interfaces/mdex/ISwapMining.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in MDex.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyMdexBscLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd, usdt} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the MDX token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public usdt = address(0x55d398326f99059fF775485246999027B3197955);\n    address constant public output = address(0x9C65AB58d8d978DB963e63f2bfB7121627e3a739);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {mdxrouter} - MDex unirouter\n     * {masterchef} - MasterChef contract\n     * {swapmining} - Swap Mining contract to get trade rewards\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public mdxrouter  = address(0x7DAe51BD3E3376B8c7c4900E9107f12Be3AF1bA8);\n    address constant public masterchef = address(0xc48FE252Aa631017dF253578B1405ea399728A50);\n    address constant public swapmining = address(0x782395303692aBeD877d2737Aa7982345eB44c11);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     *\n     * {callFee} - 0.5% goes to whoever executes the harvest. Can be lowered.\n     * {rewardsFee} - 3% that goes to BIFI holders. Can be increased by decreasing {callFee}.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n    uint constant public MAX_CALL_FEE = 111;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    uint public callFee = MAX_CALL_FEE;\n    uint public rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    /**\n     * @dev Routes we take to swap tokens using MDex and PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb || lpToken0 == busd || lpToken0 == usdt) {\n            outputToLp0Route = [output, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, usdt, lpToken0];\n        }\n\n        if (lpToken1 == wbnb || lpToken1 == busd || lpToken1 == usdt) {\n            outputToLp1Route = [output, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, usdt, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(mdxrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(mdxrouter, 0);\n        IERC20(lpToken0).safeApprove(mdxrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(mdxrouter, 0);\n        IERC20(lpToken1).safeApprove(mdxrouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(mdxrouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(mdxrouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(mdxrouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(mdxrouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    function claimSwapRewards() public {\n        ISwapMining(swapmining).takerWithdraw();\n    }\n\n    /**\n     * @dev Function to synchronize balances.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ,) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(mdxrouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(mdxrouter, 0);\n        IERC20(lpToken1).safeApprove(mdxrouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(mdxrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(mdxrouter, 0);\n        IERC20(lpToken0).safeApprove(mdxrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(mdxrouter, 0);\n        IERC20(lpToken1).safeApprove(mdxrouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external onlyOwner {\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Mdex/StrategyMdexLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/mdex/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in MDex.\n * This strategy simply deposits whatever funds it receives from the vault into the selected HECOPool pool.\n * MDX rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the HECOPool pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyMdexLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wht} - Required for liquidity routing when doing swaps.\n     * {mdx} - Token generated by staking our funds. In this case it's the MDX token.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wht = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public mdx = address(0x25D2e80cB6B86881Fd7e07dd263Fb79f4AbE033c);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - MDex unirouter\n     * {masterchef} - MDex MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0xED7d5F38C79115ca12fe6C0041abb22F0A06C300);\n    address constant public masterchef = address(0xFB03e11D93632D97a8981158A632Dd5986F5E909);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {treasury} - Address of the Beefy treasury. Rewards accumulate here and are then sent to BSC.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public treasury = address(0xf4859A3f36fBcA24BF8299bf56359fB441b03034);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 3.5% goes to BIFI holders through the {treasury}.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 777;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using MDex.\n     * {mdxToWhtRoute} - Route we take to get from {mdx} into {wht}.\n     * {mdxToLp0Route} - Route we take to get from {mdx} into {lpToken0}.\n     * {mdxToLp1Route} - Route we take to get from {mdx} into {lpToken1}.\n     */\n    address[] public mdxToWhtRoute = [mdx, wht];\n    address[] public mdxToLp0Route;\n    address[] public mdxToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wht) {\n            mdxToLp0Route = [mdx, wht];\n        } else if (lpToken0 != mdx) {\n            mdxToLp0Route = [mdx, wht, lpToken0];\n        }\n\n        if (lpToken1 == wht) {\n            mdxToLp1Route = [mdx, wht];\n        } else if (lpToken1 != mdx) {\n            mdxToLp1Route = [mdx, wht, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(mdx).safeApprove(unirouter, type(uint).max);\n        IERC20(wht).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {mdx}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {mdx} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 3.5% -> Beefy Treasury\n     * 0.5% -> Call Fee\n     * 0.5% -> Strategist fee\n     */\n    function chargeFees() internal {\n        uint256 toWht = IERC20(mdx).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWht, 0, mdxToWhtRoute, address(this), block.timestamp.add(600));\n\n        uint256 whtBal = IERC20(wht).balanceOf(address(this));\n\n        uint256 treasuryFee = whtBal.mul(TREASURY_FEE).div(MAX_FEE);\n        IERC20(wht).safeTransfer(treasury, treasuryFee);\n\n        uint256 callFee = whtBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wht).safeTransfer(msg.sender, callFee);\n\n        uint256 strategistFee = whtBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wht).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {mdx} for {lpToken0} and {lpToken1} using a Uniswap based {unirouter}.\n     */\n    function addLiquidity() internal {\n        uint256 mdxHalf = IERC20(mdx).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != mdx) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(mdxHalf, 0, mdxToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != mdx) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(mdxHalf, 0, mdxToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, , ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(mdx).safeApprove(unirouter, 0);\n        IERC20(wht).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(mdx).safeApprove(unirouter, type(uint).max);\n        IERC20(wht).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n\n        deposit();\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Venus/StrategyVenusXVS.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/venus/IUnitroller.sol\";\nimport \"../../interfaces/venus/IVToken.sol\";\n\n/**\n * @title Strategy Venus XVS\n * @author sirbeefalot & superbeefyboy\n * @dev It maximizes yields doing leveraged lending with XVS on Venus.\n */\ncontract StrategyVenusXVS is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {venus}   - Token earned through farming.\n     * {wbnb}    - Required for liquidity routing when doing swaps.\n     * {bifi}    - BeefyFinance token, used to send funds to the treasury.\n     * {vtoken}  - Venus Token. We interact with it to mint/redem/borrow/repay the loan.\n     * {want}    - Token that the strategy maximizes.\n     */\n    address constant public venus = address(0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63);\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public vtoken;\n    address public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter}  - Pancakeswap unirouter. Has the most liquidity for {venus}.\n     * {unitroller} - Controller contract for the {venus} rewards.\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public unitroller = address(0xfD36E2c2a6789Db23113685031d7F16329158384);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards}  - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault}    - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 5.0% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 5 === 0.05% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint256 constant public REWARDS_FEE    = 600;\n    uint256 constant public CALL_FEE       = 200;\n    uint256 constant public TREASURY_FEE   = 100;\n    uint256 constant public STRATEGIST_FEE = 100;\n    uint256 constant public MAX_FEE        = 1000;\n\n    uint256 constant public WITHDRAWAL_FEE = 5;\n    uint256 constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using the {unirouter}.\n     * {venusToWbnbRoute} - Route we take to go from {venus} into {wbnb}.\n     * {wbnbToBifiRoute}  - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public venusToWbnbRoute = [venus, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Variables that can be changed to config profitability and risk:\n     * {borrowRate}          - What % of our collateral do we borrow per leverage level.\n     * {borrowDepth}         - How many levels of leverage do we take.\n     * {minLeverage}         - The minimum amount of collateral required to leverage.\n     * {BORROW_RATE_MAX}     - A limit on how much we can push borrow risk.\n     * {BORROW_DEPTH_MAX}    - A limit on how many steps we can leverage.\n     */\n    uint256 public borrowRate;\n    uint256 public borrowDepth;\n    uint256 public minLeverage;\n    uint256 constant public BORROW_RATE_MAX = 58;\n    uint256 constant public BORROW_DEPTH_MAX = 10;\n\n    /**\n     * @dev We keep and update a cache of the strat's {want} deposited in venus. Contract\n     * functions that use this value always update it first. We use it to keep the UI helper\n     * functions as view only.\n     */\n    uint256 public depositedBalance;\n\n    /**\n     * @dev Helps to differentiate borrowed funds that shouldn't be used in functions like 'deposit()'\n     * as they're required to deleverage correctly.\n     */\n    uint256 public reserves = 0;\n\n    /**\n     * @dev Events that the contract emits\n     */\n    event StratHarvest(address indexed harvester);\n    event StratRebalance(uint256 _borrowRate, uint256 _borrowDepth);\n\n    /**\n     * @notice Initializes the strategy\n     * @param _vault Address of the vault that will manage the strat.\n     * @param _vtoken Address of the vtoken that we will interact with.\n     * @param _borrowRate Initial borrow rate used.\n     * @param _borrowDepth Initial borow depth used.\n     * @param _minLeverage Minimum amount that the '_leverage' function will actually leverage.\n     * @param _markets Array with a single element being the target vtoken address.\n     */\n    constructor(\n        address _vault,\n        address _vtoken,\n        uint256 _borrowRate,\n        uint256 _borrowDepth,\n        uint256 _minLeverage,\n        address[] memory _markets\n    ) {\n        vault = _vault;\n        vtoken = _vtoken;\n        want = IVToken(_vtoken).underlying();\n        minLeverage = _minLeverage;\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n        strategist = msg.sender;\n\n        IERC20(want).safeApprove(vtoken, type(uint).max);\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IUnitroller(unitroller).enterMarkets(_markets);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault. It does {borrowDepth}\n     * levels of compound lending. It also updates the helper {depositedBalance} variable.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = availableWant();\n\n        if (wantBal > 0) {\n            _leverage(wantBal);\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev Repeatedly supplies and borrows {want} following the configured {borrowRate} and {borrowDepth}\n     * @param _amount amount of {want} to leverage\n     */\n    function _leverage(uint256 _amount) internal {\n        if (_amount < minLeverage) { return; }\n\n        for (uint i = 0; i < borrowDepth; i++) {\n            IVToken(vtoken).mint(_amount);\n            _amount = _amount.mul(borrowRate).div(100);\n            IVToken(vtoken).borrow(_amount);\n        }\n\n        reserves = reserves.add(_amount);\n    }\n\n    /**\n     * @dev Incrementally alternates between paying part of the debt and withdrawing part of the supplied\n     * collateral. Continues to do this until it repays the entire debt and withdraws all the supplied {want}\n     * from the system\n     */\n    function _deleverage() internal {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n\n        while (wantBal < borrowBal) {\n            IVToken(vtoken).repayBorrow(wantBal);\n\n            borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n            uint256 targetUnderlying = borrowBal.mul(100).div(borrowRate);\n            uint256 balanceOfUnderlying = IVToken(vtoken).balanceOfUnderlying(address(this));\n\n            IVToken(vtoken).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        IVToken(vtoken).repayBorrow(type(uint256).max);\n\n        uint256 vtokenBal = IERC20(vtoken).balanceOf(address(this));\n        IVToken(vtoken).redeem(vtokenBal);\n\n        reserves = 0;\n    }\n\n    /**\n     * @dev Extra safety measure that allows us to manually unwind one level. In case we somehow get into\n     * as state where the cost of unwinding freezes the system. We can manually unwind a few levels\n     * with this function and then 'rebalance()' with new {borrowRate} and {borrowConfig} values.\n     * @param _borrowRate configurable borrow rate in case it's required to unwind successfully\n     */\n    function deleverageOnce(uint _borrowRate) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!safe\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IVToken(vtoken).repayBorrow(wantBal);\n\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n        uint256 targetUnderlying = borrowBal.mul(100).div(_borrowRate);\n        uint256 balanceOfUnderlying = IVToken(vtoken).balanceOfUnderlying(address(this));\n\n        IVToken(vtoken).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n\n        updateBalance();\n\n        wantBal = IERC20(want).balanceOf(address(this));\n        reserves = wantBal;\n    }\n\n    /**xw\n     * @dev Updates the risk profile and rebalances the vault funds accordingly.\n     * @param _borrowRate percent to borrow on each leverage level.\n     * @param _borrowDepth how many levels to leveraxge the funds.\n     */\n    function rebalance(uint256 _borrowRate, uint256 _borrowDepth) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!rate\");\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \"!depth\");\n\n        _deleverage();\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        _leverage(wantBal);\n\n        emit StratRebalance(_borrowRate, _borrowDepth);\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims {venus} rewards from the Unitroller.\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It swaps the remaining rewards into more {want}.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        IUnitroller(unitroller).claimVenus(address(this));\n        _chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 5.0% as system fees from the rewards.\n     * 1% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3% -> BIFI Holders\n     */\n    function _chargeFees() internal {\n        uint256 toWbnb = IERC20(venus).balanceOf(address(this)).mul(50).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, venusToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. It deleverages from venus first,\n     * and then deposits again after the withdraw to make sure it mantains the desired ratio.\n     * @param _amount How much {want} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = availableWant();\n\n        if (wantBal < _amount) {\n            _deleverage();\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n\n        if (!paused()) {\n            _leverage(availableWant());\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev It helps mantain a cached version of the {want} deposited in venus.\n     * We use it to be able to keep the vault's 'balance()' function and\n     * 'getPricePerFullShare()' with view visibility.\n     */\n    function updateBalance() public {\n        uint256 supplyBal = IVToken(vtoken).balanceOfUnderlying(address(this));\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n        depositedBalance = supplyBal.sub(borrowBal);\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        panic();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Venus Platform.\n     */\n    function panic() public onlyOwner {\n        _deleverage();\n        updateBalance();\n        pause();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(vtoken, 0);\n        IERC20(venus).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(vtoken, type(uint).max);\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {want} held by the strat.\n     * It takes into account both the funds at hand, and the funds allocated in the {vtoken} contract.\n     * It uses a cache of the balances stored in {depositedBalance} to enable a few UI helper functions\n     * to exist. Sensitive functions should call 'updateBalance()' first to make sure the data is up to date.\n     * @return total {want} held by the strat.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfStrat().add(depositedBalance);\n    }\n\n    /**\n     * @notice Balance in strat contract\n     * @return how much {want} the contract holds.\n     */\n    function balanceOfStrat() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Required for various functions that need to deduct {reserves} from total {want}.\n     * @return how much {want} the hontract holds without reserves     \n     */\n     function availableWant() public view returns (uint256) {\n         uint256 wantBal = IERC20(want).balanceOf(address(this));\n         return wantBal.sub(reserves);\n     }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/venus/IUnitroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IUnitroller {\n    function claimVenus(address holder) external;\n    function enterMarkets(address[] memory _vtokens) external;\n    function exitMarket(address _vtoken) external;\n    function getAssetsIn(address account) view external returns (address[] memory);\n    function getAccountLiquidity(address account) view external returns (uint, uint, uint);\n}"
    },
    "contracts/BIFI/interfaces/venus/IVToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IVToken is IERC20 {\n    function underlying() external returns (address);\n    function mint(uint mintAmount) external returns (uint);\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function repayBorrow(uint repayAmount) external returns (uint);\n    function balanceOfUnderlying(address owner) external returns (uint);\n    function borrowBalanceCurrent(address account) external returns (uint);\n}"
    },
    "contracts/BIFI/strategies/Venus/StrategyVenusBETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/venus/IUnitroller.sol\";\nimport \"../../interfaces/venus/IVToken.sol\";\n\n/**\n * @title Strategy Venus\n * @author sirbeefalot & superbeefyboy\n * @dev It maximizes yields doing leveraged lending with a single configurable BEP20 asset\n * on the Venus lending platform.\n */\ncontract StrategyVenusBETH is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {venus}   - Token earned through farming.\n     * {wbnb}    - Required for liquidity routing when doing swaps.\n     * {bifi}    - BeefyFinance token, used to send funds to the treasury.\n     * {vtoken}  - Venus Token. We interact with it to mint/redem/borrow/repay the loan.\n     * {want}    - Token that the strategy maximizes.\n     */\n    address constant public venus = address(0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63);\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public vtoken;\n    address public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter}  - Pancakeswap unirouter. Has the most liquidity for {venus}.\n     * {unitroller} - Controller contract for the {venus} rewards.\n     * {bakeryRouter} - BakerySwap unirouter. Has the most liquidity for BETH\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public unitroller = address(0xfD36E2c2a6789Db23113685031d7F16329158384);\n    address constant public bakeryRouter = address(0xCDe540d7eAFE93aC5fE6233Bee57E1270D3E330F);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards}  - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault}    - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 5.0% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 5 === 0.05% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint256 constant public REWARDS_FEE    = 600;\n    uint256 constant public CALL_FEE       = 200;\n    uint256 constant public TREASURY_FEE   = 100;\n    uint256 constant public STRATEGIST_FEE = 100;\n    uint256 constant public MAX_FEE        = 1000;\n\n    uint256 constant public WITHDRAWAL_FEE = 5;\n    uint256 constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using the {unirouter}.\n     * {venusToWbnbRoute} - Route we take to go from {venus} into {wbnb}.\n     * {wbnbToBifiRoute}  - Route we take to go from {wbnb} into {bifi}.\n     * {wbnbToWantRoute} - Route we take to go from {wbnb} into {want}.\n     */\n    address[] public venusToWbnbRoute = [venus, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public wbnbToWantRoute;\n\n    /**\n     * @dev Variables that can be changed to config profitability and risk:\n     * {borrowRate}          - What % of our collateral do we borrow per leverage level.\n     * {borrowDepth}         - How many levels of leverage do we take.\n     * {minLeverage}         - The minimum amount of collateral required to leverage.\n     * {BORROW_RATE_MAX}     - A limit on how much we can push borrow risk.\n     * {BORROW_DEPTH_MAX}    - A limit on how many steps we can leverage.\n     */\n    uint256 public borrowRate;\n    uint256 public borrowDepth;\n    uint256 public minLeverage;\n    uint256 constant public BORROW_RATE_MAX = 58;\n    uint256 constant public BORROW_DEPTH_MAX = 10;\n\n    /**\n     * @dev We keep and update a cache of the strat's {want} deposited in venus. Contract\n     * functions that use this value always update it first. We use it to keep the UI helper\n     * functions as view only.\n     */\n    uint256 public depositedBalance;\n\n    /**\n     * @dev Helps to differentiate borrowed funds that shouldn't be used in functions like 'deposit()'\n     * as they're required to deleverage correctly.\n     */\n    uint256 public reserves = 0;\n\n    /**\n     * @dev Events that the contract emits\n     */\n    event StratHarvest(address indexed harvester);\n    event StratRebalance(uint256 _borrowRate, uint256 _borrowDepth);\n\n    /**\n     * @notice Initializes the strategy\n     * @param _vault Address of the vault that will manage the strat.\n     * @param _vtoken Address of the vtoken that we will interact with.\n     * @param _borrowRate Initial borrow rate used.\n     * @param _borrowDepth Initial borow depth used.\n     * @param _minLeverage Minimum amount that the '_leverage' function will actually leverage.\n     * @param _markets Array with a single element being the target vtoken address.\n     */\n    constructor(\n        address _vault,\n        address _vtoken,\n        uint256 _borrowRate,\n        uint256 _borrowDepth,\n        uint256 _minLeverage,\n        address[] memory _markets\n    ) {\n        vault = _vault;\n        vtoken = _vtoken;\n        want = IVToken(_vtoken).underlying();\n        minLeverage = _minLeverage;\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n        strategist = msg.sender;\n\n        wbnbToWantRoute = [wbnb, want];\n\n        IERC20(want).safeApprove(vtoken, type(uint).max);\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(bakeryRouter, type(uint).max);\n\n        IUnitroller(unitroller).enterMarkets(_markets);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault. It does {borrowDepth}\n     * levels of compound lending. It also updates the helper {depositedBalance} variable.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = availableWant();\n\n        if (wantBal > 0) {\n            _leverage(wantBal);\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev Repeatedly supplies and borrows {want} following the configured {borrowRate} and {borrowDepth}\n     * @param _amount amount of {want} to leverage\n     */\n    function _leverage(uint256 _amount) internal {\n        if (_amount < minLeverage) { return; }\n\n        for (uint i = 0; i < borrowDepth; i++) {\n            IVToken(vtoken).mint(_amount);\n            _amount = _amount.mul(borrowRate).div(100);\n            IVToken(vtoken).borrow(_amount);\n        }\n\n        reserves = reserves.add(_amount);\n    }\n\n    /**\n     * @dev Incrementally alternates between paying part of the debt and withdrawing part of the supplied\n     * collateral. Continues to do this until it repays the entire debt and withdraws all the supplied {want}\n     * from the system\n     */\n    function _deleverage() internal {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n\n        while (wantBal < borrowBal) {\n            IVToken(vtoken).repayBorrow(wantBal);\n\n            borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n            uint256 targetUnderlying = borrowBal.mul(100).div(borrowRate);\n            uint256 balanceOfUnderlying = IVToken(vtoken).balanceOfUnderlying(address(this));\n\n            IVToken(vtoken).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        IVToken(vtoken).repayBorrow(type(uint256).max);\n\n        uint256 vtokenBal = IERC20(vtoken).balanceOf(address(this));\n        IVToken(vtoken).redeem(vtokenBal);\n\n        reserves = 0;\n    }\n\n    /**\n     * @dev Extra safety measure that allows us to manually unwind one level. In case we somehow get into\n     * as state where the cost of unwinding freezes the system. We can manually unwind a few levels\n     * with this function and then 'rebalance()' with new {borrowRate} and {borrowConfig} values.\n     * @param _borrowRate configurable borrow rate in case it's required to unwind successfully\n     */\n    function deleverageOnce(uint _borrowRate) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!safe\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IVToken(vtoken).repayBorrow(wantBal);\n\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n        uint256 targetUnderlying = borrowBal.mul(100).div(_borrowRate);\n        uint256 balanceOfUnderlying = IVToken(vtoken).balanceOfUnderlying(address(this));\n\n        IVToken(vtoken).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n\n        updateBalance();\n\n        wantBal = IERC20(want).balanceOf(address(this));\n        reserves = wantBal;\n    }\n\n    /**xw\n     * @dev Updates the risk profile and rebalances the vault funds accordingly.\n     * @param _borrowRate percent to borrow on each leverage level.\n     * @param _borrowDepth how many levels to leveraxge the funds.\n     */\n    function rebalance(uint256 _borrowRate, uint256 _borrowDepth) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!rate\");\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \"!depth\");\n\n        _deleverage();\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        _leverage(wantBal);\n\n        emit StratRebalance(_borrowRate, _borrowDepth);\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims {venus} rewards from the Unitroller.\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It swaps the remaining rewards into more {want}.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        IUnitroller(unitroller).claimVenus(address(this));\n        _chargeFees();\n        _swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 5.0% as system fees from the rewards.\n     * 1% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3% -> BIFI Holders\n     */\n    function _chargeFees() internal {\n        uint256 toWbnb = IERC20(venus).balanceOf(address(this)).mul(50).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, venusToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {venus} rewards earned for more {want}.\n     */\n    function _swapRewards() internal {\n        uint256 venusBal = IERC20(venus).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(venusBal, 0, venusToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n        IUniswapRouter(bakeryRouter).swapExactTokensForTokens(wbnbBal, 0, wbnbToWantRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. It deleverages from venus first,\n     * and then deposits again after the withdraw to make sure it mantains the desired ratio.\n     * @param _amount How much {want} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = availableWant();\n\n        if (wantBal < _amount) {\n            _deleverage();\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n\n        if (!paused()) {\n            _leverage(availableWant());\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev It helps mantain a cached version of the {want} deposited in venus.\n     * We use it to be able to keep the vault's 'balance()' function and\n     * 'getPricePerFullShare()' with view visibility.\n     */\n    function updateBalance() public {\n        uint256 supplyBal = IVToken(vtoken).balanceOfUnderlying(address(this));\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n        depositedBalance = supplyBal.sub(borrowBal);\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        panic();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Venus Platform.\n     */\n    function panic() public onlyOwner {\n        _deleverage();\n        updateBalance();\n        pause();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(vtoken, 0);\n        IERC20(venus).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(bakeryRouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(vtoken, type(uint).max);\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(bakeryRouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {want} held by the strat.\n     * It takes into account both the funds at hand, and the funds allocated in the {vtoken} contract.\n     * It uses a cache of the balances stored in {depositedBalance} to enable a few UI helper functions\n     * to exist. Sensitive functions should call 'updateBalance()' first to make sure the data is up to date.\n     * @return total {want} held by the strat.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfStrat().add(depositedBalance);\n    }\n\n    /**\n     * @notice Balance in strat contract\n     * @return how much {want} the contract holds.\n     */\n    function balanceOfStrat() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Required for various functions that need to deduct {reserves} from total {want}.\n     * @return how much {want} the hontract holds without reserves     \n     */\n     function availableWant() public view returns (uint256) {\n         uint256 wantBal = IERC20(want).balanceOf(address(this));\n         return wantBal.sub(reserves);\n     }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Venus/StrategyVenusBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/venus/IUnitroller.sol\";\nimport \"../../interfaces/venus/IVBNB.sol\";\nimport \"../../interfaces/common/IWBNB.sol\";\n\n/**\n * @title Strategy Venus BNB\n * @author sirbeefalot & superbeefyboy\n * @dev It maximizes yields doing leveraged lending with BNB on Venus.\n */\ncontract StrategyVenusBNB is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb}  - Token that the strategy maximizes.\n     * {bifi}  - BeefyFinance token, used to send funds to the treasury.\n     * {venus} - Token earned through farming.\n     * {vbnb}  - Venus BNB. We interact with it to mint/redem/borrow/repay BNB.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public venus = address(0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63);\n    address constant public vbnb = address(0xA07c5b74C9B40447a954e1466938b865b6BBea36);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter}  - Pancakeswap unirouter. Has the most liquidity for {venus}.\n     * {unitroller} - Controller contract for the {venus} rewards.\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public unitroller = address(0xfD36E2c2a6789Db23113685031d7F16329158384);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards}  - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault}    - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint256 constant public REWARDS_FEE  = 665;\n    uint256 constant public CALL_FEE     = 223;\n    uint256 constant public TREASURY_FEE = 112;\n    uint256 constant public MAX_FEE      = 1000;\n\n    uint256 constant public WITHDRAWAL_FEE = 5;\n    uint256 constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using the {unirouter}.\n     * {venusToWbnbRoute} - Route we take to go from {venus} into {wbnb}.\n     * {wbnbToBifiRoute}  - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public venusToWbnbRoute = [venus, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Variables that can be changed to config profitability and risk:\n     * {borrowRate}          - What % of our collateral do we borrow per leverage level.\n     * {borrowDepth}         - How many levels of leverage do we take.\n     * {BORROW_RATE_MAX}     - A limit on how much we can push borrow risk.\n     * {BORROW_DEPTH_MAX}    - A limit on how many steps we can leverage.\n     * {MIN_LEVERAGE_AMOUNT} - The minimum amount of collateral required to leverage.\n     */\n    uint256 public borrowRate;\n    uint256 public borrowDepth;\n    uint256 constant public BORROW_RATE_MAX = 58;\n    uint256 constant public BORROW_DEPTH_MAX = 10;\n    uint256 constant public MIN_LEVERAGE_AMOUNT = 1e12;\n\n    /**\n     * @dev We keep and update a cache of the strat's bnb deposited in venus. Contract\n     * functions that use this value always update it first. We use it to keep the UI helper\n     * functions as view only.\n     */\n    uint256 public depositedBalance;\n\n    /**\n     * @dev Events that the contract emits\n     */\n    event StratHarvest(address indexed harvester);\n    event StratRebalance(uint256 _borrowRate, uint256 _borrowDepth);\n\n    /**\n     * @notice Initializes the strategy\n     * @param _vault Address of the vault that will manage the strat.\n     * @param _borrowRate Initial borrow rate used.\n     * @param _borrowDepth Initial borow depth used.\n     */\n    constructor(address _vault, uint256 _borrowRate, uint256 _borrowDepth, address[] memory _markets) {\n        vault = _vault;\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IUnitroller(unitroller).enterMarkets(_markets);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault. It does {borrowDepth}\n     * levels of compound lending. It also updates the helper {depositedBalance} variable.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        if (wbnbBal > 0) {\n            IWBNB(wbnb).withdraw(wbnbBal);\n            _leverage(wbnbBal);\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev Repeatedly supplies and borrows bnb following the configured {borrowRate} and {borrowDepth}\n     * @param _amount amount of bnb to leverage\n     */\n    function _leverage(uint256 _amount) internal {\n        if (_amount < MIN_LEVERAGE_AMOUNT) { return; }\n\n        for (uint i = 0; i < borrowDepth; i++) {\n            IVBNB(vbnb).mint{value: _amount}();\n            _amount = _amount.mul(borrowRate).div(100);\n            IVBNB(vbnb).borrow(_amount);\n        }\n    }\n\n    /**\n     * @dev Incrementally alternates between paying part of the debt and withdrawing part of the supplied\n     * collateral. Continues to do this until it repays the entire debt and withdraws all the supplied bnb\n     * from the system\n     */\n    function _deleverage() internal {\n        uint256 bnbBal = address(this).balance;\n        uint256 borrowBal = IVBNB(vbnb).borrowBalanceCurrent(address(this));\n\n        while (bnbBal < borrowBal) {\n            IVBNB(vbnb).repayBorrow{value: bnbBal}();\n\n            borrowBal = IVBNB(vbnb).borrowBalanceCurrent(address(this));\n            uint256 targetUnderlying = borrowBal.mul(100).div(borrowRate);\n            uint256 balanceOfUnderlying = IVBNB(vbnb).balanceOfUnderlying(address(this));\n\n            IVBNB(vbnb).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n            bnbBal = address(this).balance;\n        }\n\n        IVBNB(vbnb).repayBorrow{value: borrowBal}();\n\n        uint256 vbnbBal = IERC20(vbnb).balanceOf(address(this));\n        IVBNB(vbnb).redeem(vbnbBal);\n    }\n\n    /**\n     * @dev Extra safety measure that allows us to manually unwind one level. In case we somehow get into\n     * as state where the cost of unwinding freezes the system. We can manually unwind a few levels\n     * with this function and then 'rebalance()' with new {borrowRate} and {borrowConfig} values.\n     * @param _borrowRate configurable borrow rate in case it's required to unwind successfully\n     */\n    function deleverageOnce(uint _borrowRate) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!safe\");\n\n        uint256 bnbBal = address(this).balance;\n        IVBNB(vbnb).repayBorrow{value: bnbBal}();\n\n        uint256 borrowBal = IVBNB(vbnb).borrowBalanceCurrent(address(this));\n        uint256 targetUnderlying = borrowBal.mul(100).div(_borrowRate);\n        uint256 balanceOfUnderlying = IVBNB(vbnb).balanceOfUnderlying(address(this));\n\n        IVBNB(vbnb).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n\n        updateBalance();\n    }\n\n    /**\n     * @dev Updates the risk profile and rebalances the vault funds accordingly.\n     * @param _borrowRate percent to borrow on each leverage level.\n     * @param _borrowDepth how many levels to leverage the funds.\n     */\n    function rebalance(uint256 _borrowRate, uint256 _borrowDepth) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!rate\");\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \"!depth\");\n\n        _deleverage();\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n        _leverage(address(this).balance);\n\n        emit StratRebalance(_borrowRate, _borrowDepth);\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims {venus} rewards from the Unitroller.\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It swaps the remaining rewards into more {wbnb}.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        IUnitroller(unitroller).claimVenus(address(this));\n        _chargeFees();\n        _swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 1% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 3% -> BIFI Holders\n     */\n    function _chargeFees() internal {\n        uint256 toWbnb = IERC20(venus).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, venusToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Swaps {venus} rewards earned for more {wbnb}.\n     */\n    function _swapRewards() internal {\n        uint256 venusBal = IERC20(venus).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(venusBal, 0, venusToWbnbRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. It deleverages from venus first,\n     * and then deposits again after the withdraw to make sure it mantains the desired ratio.\n     * @param _amount How much {wbnb} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        if (wbnbBal < _amount) {\n            _deleverage();\n            IWBNB(wbnb).deposit{value: _amount.sub(wbnbBal)}();\n            wbnbBal = IERC20(wbnb).balanceOf(address(this));\n        }\n\n        if (wbnbBal > _amount) {\n            wbnbBal = _amount;\n        }\n\n        uint256 withdrawalFee = wbnbBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(wbnb).safeTransfer(vault, wbnbBal.sub(withdrawalFee));\n\n        if (!paused()) {\n            _leverage(address(this).balance);\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev It helps mantain a cached version of the bnb deposited in venus.\n     * We use it to be able to keep the vault's 'balance()' function and\n     * 'getPricePerFullShare()' with view visibility.\n     */\n    function updateBalance() public {\n        uint256 supplyBal = IVBNB(vbnb).balanceOfUnderlying(address(this));\n        uint256 borrowBal = IVBNB(vbnb).borrowBalanceCurrent(address(this));\n        depositedBalance = supplyBal.sub(borrowBal);\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It pauses the strat and\n     *  sends all the available funds back to the vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        _pause();\n\n        IERC20(venus).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n\n        _deleverage();\n        IWBNB(wbnb).deposit{value: address(this).balance}();\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n        IERC20(wbnb).transfer(vault, wbnbBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Venus Platform.\n     */\n    function panic() public onlyOwner {\n        pause();\n        _deleverage();\n        IWBNB(wbnb).deposit{value: address(this).balance}();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(venus).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat. It also puts the funds to work again.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        deposit();\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {wbnb} and bnb held by the strat.\n     * It takes into account both the funds at hand, and the funds allocated in the {vbnb} contract.\n     * It uses a cache of the balances stored in {depositedBalance} to enable a few UI helper functions\n     * to exist. Sensitive functions should call 'updateBalance()' first to make sure the data is up to date.\n     * @return total {wbnb} and bnb held by the strat.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfStrat().add(depositedBalance);\n    }\n\n    /**\n     * @dev It calculates how much BNB the contract holds.\n     * @return The sum of {wbnb} and bnb in the contract.\n     */\n    function balanceOfStrat() public view returns (uint256) {\n        uint256 bnbBal = address(this).balance;\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n        return bnbBal.add(wbnbBal);\n    }\n\n    receive () external payable {}\n}"
    },
    "contracts/BIFI/interfaces/venus/IVBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IVBNB {\n    function mint() external payable;\n    function redeem(uint redeemTokens) external returns (uint);\n    function redeemUnderlying(uint redeemAmount) external returns (uint);\n    function borrow(uint borrowAmount) external returns (uint);\n    function repayBorrow() external payable;\n    function balanceOfUnderlying(address owner) external returns (uint);\n    function borrowBalanceCurrent(address account) external returns (uint);\n}"
    },
    "contracts/BIFI/interfaces/common/IWBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IWBNB is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}"
    },
    "contracts/BIFI/vaults/BeefyVenusVaultBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IVenusStrategyBNB.sol\";\nimport \"../interfaces/common/IWBNB.sol\";\n\n/**\n * @title BeefyVault BNB\n * @author sirbeefalot & superbeefyboy\n * @dev Implementation of a custom vault to deposit exclusively BNB and WBNB on\n * the Venus lending platform for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate contract.\n */\ncontract BeefyVenusVaultBNB is ERC20, Ownable {\n    using SafeERC20 for IWBNB;\n    using Address for address;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // BEP20 token version of BNB.\n    IWBNB constant public wbnb = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev It initializes the vault's own 'moo' token.\n     * This token acts as vault 'shares'. It's minted when someone deposits and it's\n     * burned in order to withdraw the corresponding portion of the underlying BNB.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {wbnb} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     * and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint256) {\n        return available().add(IVenusStrategyBNB(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return wbnb.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(wbnb.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entry point of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        IVenusStrategyBNB(strategy).updateBalance();\n\n        uint256 _pool = balance();\n        wbnb.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Alternative entry point into the strat. You can send native BNB,\n     * and the vault will wrap them before sending them into the strat.\n     */\n    function depositBNB() public payable {\n        IVenusStrategyBNB(strategy).updateBalance();\n\n        uint256 _pool = balance();\n        uint256 _before = wbnb.balanceOf(address(this));\n        uint256 _amount = msg.value;\n        wbnb.deposit{value: _amount}();\n\n        uint256 _after = wbnb.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        wbnb.safeTransfer(strategy, _bal);\n        IVenusStrategyBNB(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Alternative helper function to withdraw all funds in native bnb form.\n     */\n    function withdrawAllBNB() external {\n        withdrawBNB(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        IVenusStrategyBNB(strategy).updateBalance();\n\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 b = wbnb.balanceOf(address(this));\n        if (b < r) {\n            uint256 _withdraw = r.sub(b);\n            IVenusStrategyBNB(strategy).withdraw(_withdraw);\n            uint256 _after = wbnb.balanceOf(address(this));\n            uint256 _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        wbnb.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Alternative function to exit the system. Works just like 'withdraw(uint256)',\n     * but the funds arrive in native bnb.\n     */\n    function withdrawBNB(uint256 _shares) public {\n        IVenusStrategyBNB(strategy).updateBalance();\n\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 b = wbnb.balanceOf(address(this));\n        if (b < r) {\n            uint256 _withdraw = r.sub(b);\n            IVenusStrategyBNB(strategy).withdraw(_withdraw);\n            uint256 _after = wbnb.balanceOf(address(this));\n            uint256 _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        wbnb.withdraw(r);\n        payable(msg.sender).transfer(r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. You have to call 'retireStrat'\n     * in the strategy contract before. This pauses the old strat and makes sure that all the old\n     * strategy funds are sent back to this vault before switching strats. When upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IVenusStrategyBNB(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n\n    receive () external payable {}\n}"
    },
    "contracts/BIFI/interfaces/beefy/IVenusStrategyBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IVenusStrategyBNB {\n    function want() external view returns (address);\n    function deposit() external;\n    function withdraw(uint256) external;\n    function updateBalance() external;\n    function balanceOf() external view returns (uint256);\n    function retireStrat() external;\n    function harvest() external;\n}\n"
    },
    "contracts/BIFI/vaults/BeefyWorkerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyWorkerVault is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n    // The YieldBalancer that controls it\n    address public yieldBalancer;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _token,\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        require(msg.sender == yieldBalancer, \"!yieldBalancer\");\n\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = token.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint _after = token.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IStrategy(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n\n    /**\n     * @dev sets the yield balancer with exclusive deposit rights.\n     * @param _yieldBalancer the new handler for the vault\n     */\n    function setYieldBalancer(address _yieldBalancer) external onlyOwner {\n        yieldBalancer = _yieldBalancer;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        require(_token != address(token), \"!token\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/beefy/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStrategy {\n    function vault() external view returns (address);\n    function want() external view returns (IERC20);\n    function beforeDeposit() external;\n    function deposit() external;\n    function withdraw(uint256) external;\n    function balanceOf() external view returns (uint256);\n    function balanceOfWant() external view returns (uint256);\n    function balanceOfPool() external view returns (uint256);\n    function harvest() external;\n    function retireStrat() external;\n    function panic() external;\n    function pause() external;\n    function unpause() external;\n    function paused() external view returns (bool);\n    function unirouter() external view returns (address);\n}\n"
    },
    "contracts/BIFI/vaults/BeefyVaultV6Matic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\nimport \"../interfaces/common/IWMATIC.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyVaultV6Matic is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IWMATIC;\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    IStrategy public strategy;\n    // BEP20 token version of BNB.\n    IWMATIC constant public wmatic = IWMATIC(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        IStrategy _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        _name,\n        _symbol\n    ) {\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return available().add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return wmatic.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(wmatic.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public nonReentrant {\n        strategy.beforeDeposit();\n\n        uint256 _pool = balance();\n        wmatic.safeTransferFrom(msg.sender, address(this), _amount);\n        earn();\n        uint256 _after = balance();\n        _amount = _after.sub(_pool); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    /**\n     * @dev Alternative entry point into the strat. You can send native MATIC,\n     * and the vault will wrap them before sending them into the strat.\n     */\n    function depositBNB() public payable {\n        strategy.beforeDeposit();\n\n        uint256 _pool = balance();\n        uint256 _amount = msg.value;\n        wmatic.deposit{value: _amount}();\n        earn();\n        uint256 _after = balance();\n        _amount = _after.sub(_pool); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        wmatic.safeTransfer(address(strategy), _bal);\n        strategy.deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Alternative helper function to withdraw all funds in native matic form.\n     */\n    function withdrawAllBNB() external {\n        withdrawBNB(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = wmatic.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            strategy.withdraw(_withdraw);\n            uint _after = wmatic.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        wmatic.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Alternative function to exit the system. Works just like 'withdraw(uint256)',\n     * but the funds arrive in native matic.\n     */\n    function withdrawBNB(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = wmatic.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            strategy.withdraw(_withdraw);\n            uint _after = wmatic.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        wmatic.withdraw(r);\n        payable(msg.sender).transfer(r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        strategy.retireStrat();\n        strategy = IStrategy(stratCandidate.implementation);\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        require(_token != address(wmatic), \"!token\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n\n    receive () external payable {}\n}"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/common/IWMATIC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IWMATIC is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}"
    },
    "contracts/BIFI/vaults/BeefyVenusVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IVenusStrategy.sol\";\n\n/**\n * @title BeefyVault\n * @author sirbeefalot & superbeefyboy\n * @dev Implementation of a custom vault to deposit any BEP20 which has an available\n * market on the Venus lending platform. Deposited tokens are used in optimized leveraged lending.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate contract.\n */\ncontract BeefyVenusVault is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev It initializes the vault's own 'moo' token.\n     * This token acts as vault 'shares'. It's minted when someone deposits and it's\n     * burned in order to withdraw the corresponding portion of the underlying {token}.\n     * @param _strategy the address of the strategy.\n     * @param _token the deposit token that the vault maximizes.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _strategy,\n        address _token,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     * and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint256) {\n        return token.balanceOf(address(this)).add(IVenusStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entry point of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        IVenusStrategy(strategy).updateBalance();\n\n        uint256 _pool = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IVenusStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        IVenusStrategy(strategy).updateBalance();\n\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint256 b = token.balanceOf(address(this));\n        if (b < r) {\n            uint256 _withdraw = r.sub(b);\n            IVenusStrategy(strategy).withdraw(_withdraw);\n            uint256 _after = token.balanceOf(address(this));\n            uint256 _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. You have to call 'retireStrat'\n     * in the strategy contract before. This pauses the old strat and makes sure that all the old\n     * strategy funds are sent back to this vault before switching strats. When upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IVenusStrategy(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/beefy/IVenusStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IVenusStrategy {\n    function want() external view returns (address);\n    function deposit() external;\n    function withdraw(uint256) external;\n    function updateBalance() external;\n    function balanceOf() external view returns (uint256);\n    function retireStrat() external;\n    function harvest() external;\n}\n"
    },
    "contracts/BIFI/vaults/BeefyVaultV4.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyVaultV4 is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _token,\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = token.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint _after = token.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IStrategy(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n}\n"
    },
    "contracts/BIFI/vaults/BeefyVaultV6.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyVaultV6 is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    IStrategy public strategy;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        IStrategy _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        _name,\n        _symbol\n    ) {\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    function want() public view returns (IERC20) {\n        return IERC20(strategy.want());\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return want().balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return want().balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(want().balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public nonReentrant {\n        strategy.beforeDeposit();\n\n        uint256 _pool = balance();\n        want().safeTransferFrom(msg.sender, address(this), _amount);\n        earn();\n        uint256 _after = balance();\n        _amount = _after.sub(_pool); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        want().safeTransfer(address(strategy), _bal);\n        strategy.deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = want().balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            strategy.withdraw(_withdraw);\n            uint _after = want().balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        want().safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        require(address(this) == IStrategy(_implementation).vault(), \"Proposal not valid for this Vault\");\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        strategy.retireStrat();\n        strategy = IStrategy(stratCandidate.implementation);\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        require(_token != address(want()), \"!token\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/vaults/BeefyBurningVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IBurningStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * It supports deposits of burning tokens and strategies with entrance fee.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyBurningVault is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _token,\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this)).add(IBurningStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public nonReentrant {\n        IBurningStrategy(strategy).updateBalance();\n\n        uint256 _pool = balance();\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        earn();\n        uint256 _after = balance();\n        _amount = _after.sub(_pool); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IBurningStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = token.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IBurningStrategy(strategy).withdraw(_withdraw);\n            uint _after = token.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IBurningStrategy(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n}"
    },
    "contracts/BIFI/interfaces/beefy/IBurningStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBurningStrategy {\n    function want() external view returns (address);\n    function deposit() external;\n    function withdraw(uint256) external;\n    function updateBalance() external;\n    function balanceOf() external view returns (uint256);\n    function retireStrat() external;\n    function harvest() external;\n}\n"
    },
    "contracts/BIFI/zaps/BeefyZapUniswapV2.sol": {
      "content": "// SPDX-License-Identifier: GPLv2\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 2 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n\n// @author Wivern for Beefy.Finance\n// @notice This contract adds liquidity to Uniswap V2 compatible liquidity pair pools and stake.\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@uniswap/lib/contracts/libraries/Babylonian.sol';\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\nimport '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';\nimport '@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol';\n\ninterface IWETH is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint256 wad) external;\n}\n\ninterface IBeefyVault is IERC20 {\n    function deposit(uint256 amount) external;\n    function withdraw(uint256 shares) external;\n    function want() external pure returns (address); // Beefy Vault V6\n    function token() external pure returns (address); // Beefy Vault V5\n}\n\ncontract BeefyZapUniswapV2 {\n    using LowGasSafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IBeefyVault;\n\n    IUniswapV2Router02 public immutable router;\n    address public immutable WETH;\n    uint256 public constant minimumAmount = 1000;\n\n    constructor(address _router, address _WETH) {\n        // Safety checks to ensure WETH token address\n        IWETH(_WETH).deposit{value: 0}();\n        IWETH(_WETH).withdraw(0);\n\n        router = IUniswapV2Router02(_router);\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH);\n    }\n\n    function beefInETH (address beefyVault, uint256 tokenAmountOutMin) external payable {\n        require(msg.value >= minimumAmount, 'Beefy: Insignificant input amount');\n\n        IWETH(WETH).deposit{value: msg.value}();\n\n        _swapAndStake(beefyVault, tokenAmountOutMin, WETH);\n    }\n\n    function beefIn (address beefyVault, uint256 tokenAmountOutMin, address tokenIn, uint256 tokenInAmount) external {\n        require(tokenInAmount >= minimumAmount, 'Beefy: Insignificant input amount');\n        require(IERC20(tokenIn).allowance(msg.sender, address(this)) >= tokenInAmount, 'Beefy: Input token is not approved');\n\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), tokenInAmount);\n\n        _swapAndStake(beefyVault, tokenAmountOutMin, tokenIn);\n    }\n\n    function beefOut (address beefyVault, uint256 withdrawAmount) external {\n        (IBeefyVault vault, IUniswapV2Pair pair) = _getVaultPair(beefyVault);\n\n        IERC20(beefyVault).safeTransferFrom(msg.sender, address(this), withdrawAmount);\n        vault.withdraw(withdrawAmount);\n\n        if (pair.token0() != WETH && pair.token1() != WETH) {\n            return _removeLiquidity(address(pair), msg.sender);\n        }\n\n        _removeLiquidity(address(pair), address(this));\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = pair.token0();\n        tokens[1] = pair.token1();\n\n        _returnAssets(tokens);\n    }\n\n    function beefOutAndSwap(address beefyVault, uint256 withdrawAmount, address desiredToken, uint256 desiredTokenOutMin) external {\n        (IBeefyVault vault, IUniswapV2Pair pair) = _getVaultPair(beefyVault);\n        address token0 = pair.token0();\n        address token1 = pair.token1();\n        require(token0 == desiredToken || token1 == desiredToken, 'Beefy: desired token not present in liquidity pair');\n\n        vault.safeTransferFrom(msg.sender, address(this), withdrawAmount);\n        vault.withdraw(withdrawAmount);\n        _removeLiquidity(address(pair), address(this));\n\n        address swapToken = token1 == desiredToken ? token0 : token1;\n        address[] memory path = new address[](2);\n        path[0] = swapToken;\n        path[1] = desiredToken;\n\n        _approveTokenIfNeeded(path[0], address(router));\n        router.swapExactTokensForTokens(IERC20(swapToken).balanceOf(address(this)), desiredTokenOutMin, path, address(this), block.timestamp);\n\n        _returnAssets(path);\n    }\n\n    function _removeLiquidity(address pair, address to) private {\n        IERC20(pair).safeTransfer(pair, IERC20(pair).balanceOf(address(this)));\n        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);\n\n        require(amount0 >= minimumAmount, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amount1 >= minimumAmount, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    }\n\n    function _getVaultPair (address beefyVault) private view returns (IBeefyVault vault, IUniswapV2Pair pair) {\n        vault = IBeefyVault(beefyVault);\n\n        try vault.want() returns (address pairAddress) {\n            pair = IUniswapV2Pair(pairAddress); // Vault V6\n        } catch {\n            pair = IUniswapV2Pair(vault.token()); // Vault V5\n        }\n\n        require(pair.factory() == router.factory(), 'Beefy: Incompatible liquidity pair factory');\n    }\n\n    function _swapAndStake(address beefyVault, uint256 tokenAmountOutMin, address tokenIn) private {\n        (IBeefyVault vault, IUniswapV2Pair pair) = _getVaultPair(beefyVault);\n\n        (uint256 reserveA, uint256 reserveB,) = pair.getReserves();\n        require(reserveA > minimumAmount && reserveB > minimumAmount, 'Beefy: Liquidity pair reserves too low');\n\n        bool isInputA = pair.token0() == tokenIn;\n        require(isInputA || pair.token1() == tokenIn, 'Beefy: Input token not present in liquidity pair');\n\n        address[] memory path = new address[](2);\n        path[0] = tokenIn;\n        path[1] = isInputA ? pair.token1() : pair.token0();\n\n        uint256 fullInvestment = IERC20(tokenIn).balanceOf(address(this));\n        uint256 swapAmountIn;\n        if (isInputA) {\n            swapAmountIn = _getSwapAmount(fullInvestment, reserveA, reserveB);\n        } else {\n            swapAmountIn = _getSwapAmount(fullInvestment, reserveB, reserveA);\n        }\n\n        _approveTokenIfNeeded(path[0], address(router));\n        uint256[] memory swapedAmounts = router\n            .swapExactTokensForTokens(swapAmountIn, tokenAmountOutMin, path, address(this), block.timestamp);\n\n        _approveTokenIfNeeded(path[1], address(router));\n        (,, uint256 amountLiquidity) = router\n            .addLiquidity(path[0], path[1], fullInvestment.sub(swapedAmounts[0]), swapedAmounts[1], 1, 1, address(this), block.timestamp);\n\n        _approveTokenIfNeeded(address(pair), address(vault));\n        vault.deposit(amountLiquidity);\n\n        vault.safeTransfer(msg.sender, vault.balanceOf(address(this)));\n        _returnAssets(path);\n    }\n\n    function _returnAssets(address[] memory tokens) private {\n        uint256 balance;\n        for (uint256 i; i < tokens.length; i++) {\n            balance = IERC20(tokens[i]).balanceOf(address(this));\n            if (balance > 0) {\n                if (tokens[i] == WETH) {\n                    IWETH(WETH).withdraw(balance);\n                    (bool success,) = msg.sender.call{value: balance}(new bytes(0));\n                    require(success, 'Beefy: ETH transfer failed');\n                } else {\n                    IERC20(tokens[i]).safeTransfer(msg.sender, balance);\n                }\n            }\n        }\n    }\n\n    function _getSwapAmount(uint256 investmentA, uint256 reserveA, uint256 reserveB) private view returns (uint256 swapAmount) {\n        uint256 halfInvestment = investmentA / 2;\n        uint256 nominator = router.getAmountOut(halfInvestment, reserveA, reserveB);\n        uint256 denominator = router.quote(halfInvestment, reserveA.add(halfInvestment), reserveB.sub(nominator));\n        swapAmount = investmentA.sub(Babylonian.sqrt(halfInvestment * halfInvestment * nominator / denominator));\n    }\n\n    function estimateSwap(address beefyVault, address tokenIn, uint256 fullInvestmentIn) public view returns(uint256 swapAmountIn, uint256 swapAmountOut, address swapTokenOut) {\n        (, IUniswapV2Pair pair) = _getVaultPair(beefyVault);\n\n        bool isInputA = pair.token0() == tokenIn;\n        require(isInputA || pair.token1() == tokenIn, 'Beefy: Input token not present in liquidity pair');\n\n        (uint256 reserveA, uint256 reserveB,) = pair.getReserves();\n        (reserveA, reserveB) = isInputA ? (reserveA, reserveB) : (reserveB, reserveA);\n\n        swapAmountIn = _getSwapAmount(fullInvestmentIn, reserveA, reserveB);\n        swapAmountOut = router.getAmountOut(swapAmountIn, reserveA, reserveB);\n        swapTokenOut = isInputA ? pair.token1() : pair.token0();\n    }\n\n    function _approveTokenIfNeeded(address token, address spender) private {\n        if (IERC20(token).allowance(address(this), spender) == 0) {\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n}\n"
    },
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/BIFI/vaults/BeefyVaultV5.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyVaultV5 is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _token,\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = token.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint _after = token.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IStrategy(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        require(_token != address(token), \"!token\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/vaults/BeefyVaultV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyVaultV3 is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _token,\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = token.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint _after = token.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IStrategy(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n}\n"
    },
    "contracts/BIFI/vaults/BeefyVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyVaultV2 is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat cantidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _token,\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(abi.encodePacked(_name)),\n        string(abi.encodePacked(_symbol))\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        uint256 _pool = balance();\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = token.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint _after = token.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. You have to call 'retireStrat'\n     * in the strategy contract before. This pauses the old strat and makes sure that all the old\n     * strategy funds are sent back to this vault before switching strats. When upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n}"
    },
    "contracts/BIFI/vaults/BeefyVaultCapped.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\n\n/**\n * @dev Implementation of a vault to deposit funds for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate 'Strategy.sol' contract.\n */\ncontract BeefyVaultCapped is ERC20, Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // The token the vault accepts and looks to maximize.\n    IERC20 public token;\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n    // Deposit cap. Can be increased.\n    uint256 public depositCap;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n    event NewDepositCap(uint256 oldCap, uint256 newCap);\n\n    /**\n     * @dev Sets the value of {token} to the token that the vault will\n     * hold as underlying value. It initializes the vault's own 'moo' token.\n     * This token is minted when someone does a deposit. It is burned in order\n     * to withdraw the corresponding portion of the underlying assets.\n     * @param _token the token to maximize.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     * @param _depositCap max amount of funds that the vault can manage.\n     */\n    constructor (\n        address _token,\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay,\n        uint256 _depositCap\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        token = IERC20(_token);\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n        depositCap = _depositCap;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {token} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     *  and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint) {\n        return token.balanceOf(address(this)).add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return token.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return totalSupply() == 0 ? 1e18 : balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(token.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entry point of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        uint256 _pool = balance();\n        require(_pool.add(_amount) < depositCap, \"!cap\");\n\n        uint256 _before = token.balanceOf(address(this));\n        token.safeTransferFrom(msg.sender, address(this), _amount);\n        uint256 _after = token.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        token.safeTransfer(strategy, _bal);\n        IStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = token.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint _after = token.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        token.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. After upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time\n     * happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        IStrategy(strategy).retireStrat();\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n\n    /**\n     * @dev Increase the amount of funds that the vault can manage.\n     * @param _depositCap new cap, must be larger than {depositCap}\n     */\n    function increaseDepositCap(uint256 _depositCap) external onlyOwner {\n        require(_depositCap > depositCap, \"!decrease\");\n\n        emit NewDepositCap(depositCap, _depositCap);\n        depositCap = _depositCap;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        require(_token != address(token), \"!token\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/vaults/BeefyVaultBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/beefy/IStrategy.sol\";\nimport \"../interfaces/common/IWBNB.sol\";\n\n/**\n * @title BeefyVault BNB\n * @author sirbeefalot & superbeefyboy\n * @dev Implementation of a vault to deposit exclusively BNB and WBNB for yield optimizing.\n * This is the contract that receives funds and that users interface with.\n * The yield optimizing strategy itself is implemented in a separate contract.\n */\ncontract BeefyVaultBNB is ERC20, Ownable {\n    using SafeERC20 for IWBNB;\n    using Address for address;\n    using SafeMath for uint256;\n\n    struct StratCandidate {\n        address implementation;\n        uint proposedTime;\n    }\n\n    // The last proposed strategy to switch to.\n    StratCandidate public stratCandidate;\n    // The strategy currently in use by the vault.\n    address public strategy;\n    // BEP20 token version of BNB.\n    IWBNB constant public wbnb = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    // The minimum time it has to pass before a strat candidate can be approved.\n    uint256 public immutable approvalDelay;\n\n    event NewStratCandidate(address implementation);\n    event UpgradeStrat(address implementation);\n\n    /**\n     * @dev It initializes the vault's own 'moo' token.\n     * This token acts as vault 'shares'. It's minted when someone deposits and it's\n     * burned in order to withdraw the corresponding portion of the underlying BNB.\n     * @param _strategy the address of the strategy.\n     * @param _name the name of the vault token.\n     * @param _symbol the symbol of the vault token.\n     * @param _approvalDelay the delay before a new strat can be approved.\n     */\n    constructor (\n        address _strategy,\n        string memory _name,\n        string memory _symbol,\n        uint256 _approvalDelay\n    ) ERC20(\n        string(_name),\n        string(_symbol)\n    ) {\n        strategy = _strategy;\n        approvalDelay = _approvalDelay;\n    }\n\n    /**\n     * @dev It calculates the total underlying value of {wbnb} held by the system.\n     * It takes into account the vault contract balance, the strategy contract balance\n     * and the balance deployed in other contracts as part of the strategy.\n     */\n    function balance() public view returns (uint256) {\n        return available().add(IStrategy(strategy).balanceOf());\n    }\n\n    /**\n     * @dev Custom logic in here for how much the vault allows to be borrowed.\n     * We return 100% of tokens for now. Under certain conditions we might\n     * want to keep some of the system funds at hand in the vault, instead\n     * of putting them to work.\n     */\n    function available() public view returns (uint256) {\n        return wbnb.balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function for various UIs to display the current value of one of our yield tokens.\n     * Returns an uint256 with 18 decimals of how much underlying asset one vault share represents.\n     */\n    function getPricePerFullShare() public view returns (uint256) {\n        return balance().mul(1e18).div(totalSupply());\n    }\n\n    /**\n     * @dev A helper function to call deposit() with all the sender's funds.\n     */\n    function depositAll() external {\n        deposit(wbnb.balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev The entrypoint of funds into the system. People deposit with this function\n     * into the vault. The vault is then in charge of sending funds into the strategy.\n     */\n    function deposit(uint _amount) public {\n        uint256 _pool = balance();\n        uint256 _before = wbnb.balanceOf(address(this));\n        wbnb.safeTransferFrom(msg.sender, address(this), _amount);\n\n        uint256 _after = wbnb.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Alternative entry point into the strat. You can send native BNB,\n     * and the vault will wrap them before sending them into the strat.\n     */\n    function depositBNB() public payable {\n        uint256 _pool = balance();\n        uint256 _before = wbnb.balanceOf(address(this));\n        uint256 _amount = msg.value;\n        wbnb.deposit{value: _amount}();\n\n        uint256 _after = wbnb.balanceOf(address(this));\n        _amount = _after.sub(_before); // Additional check for deflationary tokens\n\n        uint256 shares = 0;\n        if (totalSupply() == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(totalSupply())).div(_pool);\n        }\n        _mint(msg.sender, shares);\n\n        earn();\n    }\n\n    /**\n     * @dev Function to send funds into the strategy and put them to work. It's primarily called\n     * by the vault's deposit() function.\n     */\n    function earn() public {\n        uint _bal = available();\n        wbnb.safeTransfer(strategy, _bal);\n        IStrategy(strategy).deposit();\n    }\n\n    /**\n     * @dev A helper function to call withdraw() with all the sender's funds.\n     */\n    function withdrawAll() external {\n        withdraw(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Alternative helper function to withdraw all funds in native bnb form.\n     */\n    function withdrawAllBNB() external {\n        withdrawBNB(balanceOf(msg.sender));\n    }\n\n    /**\n     * @dev Function to exit the system. The vault will withdraw the required tokens\n     * from the strategy and pay up the token holder. A proportional number of IOU\n     * tokens are burned in the process.\n     */\n    function withdraw(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        uint b = wbnb.balanceOf(address(this));\n        if (b < r) {\n            uint _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint _after = wbnb.balanceOf(address(this));\n            uint _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        wbnb.safeTransfer(msg.sender, r);\n    }\n\n    /**\n     * @dev Alternative function to exit the system. Works just like 'withdraw(uint256)',\n     * but the funds arrive in native bnb.\n     */\n    function withdrawBNB(uint256 _shares) public {\n        uint256 r = (balance().mul(_shares)).div(totalSupply());\n        _burn(msg.sender, _shares);\n\n        // Check balance\n        uint256 b = wbnb.balanceOf(address(this));\n        if (b < r) {\n            uint256 _withdraw = r.sub(b);\n            IStrategy(strategy).withdraw(_withdraw);\n            uint256 _after = wbnb.balanceOf(address(this));\n            uint256 _diff = _after.sub(b);\n            if (_diff < _withdraw) {\n                r = b.add(_diff);\n            }\n        }\n\n        wbnb.withdraw(r);\n        payable(msg.sender).transfer(r);\n    }\n\n\n    /**\n     * @dev Sets the candidate for the new strat to use with this vault.\n     * @param _implementation The address of the candidate strategy.\n     */\n    function proposeStrat(address _implementation) public onlyOwner {\n        stratCandidate = StratCandidate({\n            implementation: _implementation,\n            proposedTime: block.timestamp\n         });\n\n        emit NewStratCandidate(_implementation);\n    }\n\n    /**\n     * @dev It switches the active strat for the strat candidate. You have to call 'retireStrat'\n     * in the strategy contract before. This pauses the old strat and makes sure that all the old\n     * strategy funds are sent back to this vault before switching strats. When upgrading, the\n     * candidate implementation is set to the 0x00 address, and proposedTime to a time happening in +100 years for safety.\n     */\n\n    function upgradeStrat() public onlyOwner {\n        require(stratCandidate.implementation != address(0), \"There is no candidate\");\n        require(stratCandidate.proposedTime.add(approvalDelay) < block.timestamp, \"Delay has not passed\");\n\n        emit UpgradeStrat(stratCandidate.implementation);\n\n        strategy = stratCandidate.implementation;\n        stratCandidate.implementation = address(0);\n        stratCandidate.proposedTime = 5000000000;\n\n        earn();\n    }\n}"
    },
    "contracts/BIFI/utils/BeefyRefund.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract BeefyRefund {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address constant public dead = address(0x000000000000000000000000000000000000dEaD);\n    address public token;\n    address public mootoken;\n\n    uint256 public pricePerFullShare;\n\n    constructor(address _token, address _mootoken, uint256 _pricePerFullShare) {\n        token = _token;\n        mootoken = _mootoken;\n        pricePerFullShare = _pricePerFullShare;\n    }\n\n    function refund() external {\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        uint256 balance = IERC20(mootoken).balanceOf(msg.sender);\n        IERC20(mootoken).safeTransferFrom(msg.sender, dead, balance);\n\n        uint256 refundAmount = balance.mul(pricePerFullShare).div(1e18);\n        IERC20(token).safeTransfer(msg.sender, refundAmount);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Thugs/StrategyThugsLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/thugs/IThugswapRouter.sol\";\nimport \"../../interfaces/thugs/IThugswapPair.sol\";\nimport \"../../interfaces/thugs/IOriginalGangsterV2.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in StreetSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyThugsLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {drugs} - Token generated by staking our funds. In this case it's the DRUGS token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IThugswapPair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public drugs = address(0x339550404Ca4d831D12B1b2e4768869997390010);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - Selected unirouter configured through constructor\n     * {gangster} - OriginalGangster contract\n     * {poolId} - OriginalGangster pool id\n     */\n    address public unirouter;\n    address constant public gangster = address(0x03edb31BeCc296d45670790c947150DAfEC2E238);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 667;\n    uint constant public CALL_FEE     = 166;\n    uint constant public TREASURY_FEE = 167;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Thugswap.\n     * {drugsToWbnbRoute} - Route we take to get from {drugs} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {drugsToLp0Route} - Route we take to get from {drugs} into {lpToken0}.\n     * {drugsToLp1Route} - Route we take to get from {drugs} into {lpToken1}.\n     */\n    address[] public drugsToWbnbRoute = [drugs, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public drugsToLp0Route;\n    address[] public drugsToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _unirouter) {\n        lpPair = _lpPair;\n        lpToken0 = IThugswapPair(lpPair).token0();\n        lpToken1 = IThugswapPair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        unirouter = _unirouter;\n\n        if (lpToken0 == wbnb) {\n            drugsToLp0Route = [drugs, wbnb];\n        } else if (lpToken0 != drugs) {\n            drugsToLp0Route = [drugs, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            drugsToLp1Route = [drugs, wbnb];\n        } else if (lpToken1 != drugs) {\n            drugsToLp1Route = [drugs, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(gangster, type(uint).max);\n        IERC20(drugs).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the OriginalGangster to farm {drugs}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IOriginalGangsterV2(gangster).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the OriginalGangster.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IOriginalGangsterV2(gangster).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the OriginalGangster.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {drugs} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IOriginalGangsterV2(gangster).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 1.0% -> Call Fee\n     * 1.0% -> Treasury fee\n     * 4.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(drugs).balanceOf(address(this)).mul(6).div(100);\n        IThugswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, drugsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IThugswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Swaps {drugs} for {lpToken0}, {lpToken1} & {wbnb} using ThugSwap.\n     */\n    function addLiquidity() internal {\n        uint256 drugsHalf = IERC20(drugs).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != drugs) {\n            IThugswapRouter(unirouter).swapExactTokensForTokens(drugsHalf, 0, drugsToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != drugs) {\n            IThugswapRouter(unirouter).swapExactTokensForTokens(drugsHalf, 0, drugsToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IThugswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the OriginalGangster.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the OriginalGangster\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IOriginalGangsterV2(gangster).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IOriginalGangsterV2(gangster).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the OriginalGangster, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IOriginalGangsterV2(gangster).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(gangster, 0);\n        IERC20(drugs).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(gangster, type(uint).max);\n        IERC20(drugs).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/thugs/IThugswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IThugswapRouter {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityBNB(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountBNB, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityBNB(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountBNB);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactBNBForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForBNB(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n}"
    },
    "contracts/BIFI/interfaces/thugs/IThugswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IThugswapPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/BIFI/interfaces/thugs/IOriginalGangsterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IOriginalGangsterV2 {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function enterStaking(uint256 _amount) external;\n    function leaveStaking(uint256 _amount) external;\n    function pendingDrugs(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Thugs/StrategyHoes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/thugs/IOriginalGangsterV2.sol\";\nimport \"../../interfaces/thugs/ISmartGangster.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming a {hoes} pool + base {drugs} farming.\n *\n * The strategy simply deposits whatever {drugs} it receives from the vault into the OriginalGangster getting {hoes} in exchange.\n * This {hoes} is then allocated into the configured pool (SmartGangster). Rewards generated by the SmartGangster can be harvested,\n * swapped for more {drugs}, and deposited again for compound farming. Rewards from the OriginalGangster are also compounded.\n *\n * This strat is currently compatible with all {hoes} pools.\n * The output token and its corresponding SmartGangster is configured with a constructor argument\n */\ncontract StrategyHoes is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {drugs} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {hoes} - Intermediate token generated by staking {drugs} in the OriginalGangster.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {output} - Token generated by staking {drugs}.\n     */\n    address constant public wbnb  = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public drugs = address(0x339550404Ca4d831D12B1b2e4768869997390010);\n    address constant public hoes  = address(0xfE60B258204398F008581775F08D2b43fb7b422b);\n    address constant public bifi  = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public output;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - StreetSwap unirouter\n     * {originalGangster} - OriginalGangster contract. Stake {drugs}, get {hoes}.\n     * {smartGangster} - SmartGangster contract. Stake {hoes}, get {output} token.\n     */\n    address constant public unirouter = address(0x3bc677674df90A9e5D741f28f6CA303357D0E4Ec);\n    address constant public originalGangster = address(0x03edb31BeCc296d45670790c947150DAfEC2E238);\n    address public smartGangster;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.5% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE = 667;\n    uint constant public CALL_FEE = 83;\n    uint constant public TREASURY_FEE = 250;\n    uint constant public MAX_FEE = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using StreetSwap.\n     * {outputToDrugsRoute} - Route we take to get from {output} into {drugs}.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public outputToDrugsRoute;\n    address[] public outputToWbnbRoute;\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the SmartGangster and Vault that it will use.\n     */\n    constructor(address _smartGangster, address _vault) {\n        smartGangster = _smartGangster;\n        vault = _vault;\n        output = ISmartGangster(smartGangster).rewardToken();\n\n        outputToDrugsRoute = [output, wbnb, drugs];\n        outputToWbnbRoute = [output, wbnb];\n\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {drugs} in the OriginalGangster to receive {hoes}\n     * It then deposits the received {hoes} in the SmartGangster to farm {output}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 drugsBal = IERC20(drugs).balanceOf(address(this));\n\n        if (drugsBal > 0) {\n            IERC20(drugs).safeApprove(originalGangster, 0);\n            IERC20(drugs).safeApprove(originalGangster, drugsBal);\n            IOriginalGangsterV2(originalGangster).enterStaking(drugsBal);\n\n            uint256 hoesBal = IERC20(hoes).balanceOf(address(this));\n            IERC20(hoes).safeApprove(smartGangster, 0);\n            IERC20(hoes).safeApprove(smartGangster, hoesBal);\n            ISmartGangster(smartGangster).deposit(hoesBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {hoes} from the SmartGangster, the {hoes} is switched back to {drugs}.\n     * The resulting {drugs} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 drugsBal = IERC20(drugs).balanceOf(address(this));\n\n        if (drugsBal < _amount) {\n            uint256 hoesBal = IERC20(hoes).balanceOf(address(this));\n            ISmartGangster(smartGangster).withdraw(_amount.sub(drugsBal).sub(hoesBal));\n\n            hoesBal = IERC20(hoes).balanceOf(address(this));\n            if (hoesBal > _amount) {\n                hoesBal = _amount;\n            }\n\n            IOriginalGangsterV2(originalGangster).leaveStaking(hoesBal);\n            drugsBal = IERC20(drugs).balanceOf(address(this));\n        }\n\n        if (drugsBal > _amount) {\n            drugsBal = _amount;\n        }\n\n        uint256 _fee = drugsBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(drugs).safeTransfer(vault, drugsBal.sub(_fee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the OriginalGangster & SmartGangster\n     * 2. It swaps the {output} token for {drugs}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IOriginalGangsterV2(originalGangster).leaveStaking(0);\n        ISmartGangster(smartGangster).deposit(0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.5% -> Treasury fee\n     * 4% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Swaps whatever {output} it has for more {drugs}.\n     */\n    function swapRewards() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(outputBal, 0, outputToDrugsRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {drugs} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the SmartGangster.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfDrugs().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {drugs} the contract holds.\n     */\n    function balanceOfDrugs() public view returns (uint256) {\n        return IERC20(drugs).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {drugs} the strategy has allocated in the OriginalGangster\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IOriginalGangsterV2(originalGangster).userInfo(0, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that gets called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ISmartGangster(smartGangster).emergencyWithdraw();\n\n        uint256 hoesBal = IERC20(hoes).balanceOf(address(this));\n        IOriginalGangsterV2(originalGangster).leaveStaking(hoesBal);\n\n        uint256 drugsBal = IERC20(drugs).balanceOf(address(this));\n        IERC20(drugs).transfer(vault, drugsBal);\n    }\n\n    /**\n     * @dev Withdraws all funds from the SmartGangster & OriginalGangster, leaving rewards behind.\n     * It also reduces allowance of the unirouter\n     */\n    function panic() public onlyOwner {\n        pause();\n\n        ISmartGangster(smartGangster).emergencyWithdraw();\n\n        uint256 hoesBal = IERC20(hoes).balanceOf(address(this));\n        IOriginalGangsterV2(originalGangster).leaveStaking(hoesBal);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n}"
    },
    "contracts/BIFI/interfaces/thugs/ISmartGangster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ISmartGangster {\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _amount) external;\n    function pendingReward(address _user) external view returns (uint256);\n    function userInfo(address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw() external;\n    function rewardToken() external view returns (address);\n}"
    },
    "contracts/BIFI/strategies/Thugs/StrategyDoubleDrugs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/thugs/IOriginalGangsterV2.sol\";\nimport \"../../interfaces/thugs/ISmartGangster.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming a {hoes} pool + base {drugs} farming.\n *\n * The strategy simply deposits whatever {drugs} it receives from the vault into the OriginalGangster getting {hoes} in exchange.\n * This {hoes} is then allocated into the configured pool (SmartGangster). Rewards generated by the SmartGangster can be harvested,\n * and deposited again for compound farming. Rewards from the OriginalGangster are also compounded.\n * This strat is currently only compatible with the 'double drugs' {hoes} pool.\n */\ncontract StrategyDoubleDrugs is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {drugs} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {hoes} - Intermediate token generated by staking {drugs} in the OriginalGangster.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb  = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public drugs = address(0x339550404Ca4d831D12B1b2e4768869997390010);\n    address constant public hoes  = address(0xfE60B258204398F008581775F08D2b43fb7b422b);\n    address constant public bifi  = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - StreetSwap unirouter\n     * {originalGangster} - OriginalGangster contract. Stake {drugs}, get {hoes}.\n     * {smartGangster} - SmartGangster contract. Stake {hoes}, get more {drugs}.\n     */\n    address constant public unirouter = address(0x3bc677674df90A9e5D741f28f6CA303357D0E4Ec);\n    address constant public originalGangster = address(0x03edb31BeCc296d45670790c947150DAfEC2E238);\n    address constant public smartGangster = address(0xf1254DE60C5dfd3Af6E7608A308c6f16c6CB773F);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.5% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE = 667;\n    uint constant public CALL_FEE = 83;\n    uint constant public TREASURY_FEE = 250;\n    uint constant public MAX_FEE = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using StreetSwap.\n     * {drugsToWbnbRoute} - Route we take to get from {drugs} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public drugsToWbnbRoute = [drugs, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the vault that it will use.\n     */\n    constructor(address _vault) {\n        vault = _vault;\n\n        IERC20(drugs).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {drugs} in the OriginalGangster to receive {hoes}\n     * It then deposits the received {hoes} in the SmartGangster to farm more {drugs}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 drugsBal = IERC20(drugs).balanceOf(address(this));\n\n        if (drugsBal > 0) {\n            IERC20(drugs).safeApprove(originalGangster, 0);\n            IERC20(drugs).safeApprove(originalGangster, drugsBal);\n            IOriginalGangsterV2(originalGangster).enterStaking(drugsBal);\n\n            uint256 hoesBal = IERC20(hoes).balanceOf(address(this));\n            IERC20(hoes).safeApprove(smartGangster, 0);\n            IERC20(hoes).safeApprove(smartGangster, hoesBal);\n            ISmartGangster(smartGangster).deposit(hoesBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {hoes} from the SmartGangster, the {hoes} is switched back to {drugs}.\n     * The resulting {drugs} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 drugsBal = IERC20(drugs).balanceOf(address(this));\n\n        if (drugsBal < _amount) {\n            uint256 hoesBal = IERC20(hoes).balanceOf(address(this));\n            ISmartGangster(smartGangster).withdraw(_amount.sub(drugsBal).sub(hoesBal));\n\n            hoesBal = IERC20(hoes).balanceOf(address(this));\n            if (hoesBal > _amount) {\n                hoesBal = _amount;\n            }\n\n            IOriginalGangsterV2(originalGangster).leaveStaking(hoesBal);\n            drugsBal = IERC20(drugs).balanceOf(address(this));\n        }\n\n        if (drugsBal > _amount) {\n            drugsBal = _amount;\n        }\n\n        uint256 _fee = drugsBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(drugs).safeTransfer(vault, drugsBal.sub(_fee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the OriginalGangster & SmartGangster\n     * 2. It charges the system fee and sends it to BIFI stakers.\n     * 3. It re-invests the remaining profits.\n     */\n    function harvest() public whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IOriginalGangsterV2(originalGangster).leaveStaking(0);\n        ISmartGangster(smartGangster).deposit(0);\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.5% -> Treasury fee\n     * 4% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(drugs).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, drugsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {drugs} held by the strat.\n     * It takes into account both the funds at hand, as the funds allocated in the SmartGangster.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfDrugs().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {drugs} the contract holds.\n     */\n    function balanceOfDrugs() public view returns (uint256) {\n        return IERC20(drugs).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {drugs} the strategy has allocated in the OriginalGangster\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IOriginalGangsterV2(originalGangster).userInfo(0, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external onlyOwner {\n        panic();\n\n        uint256 drugsBal = IERC20(drugs).balanceOf(address(this));\n        IERC20(drugs).transfer(vault, drugsBal);\n    }\n\n    /**\n     * @dev Withdraws all funds from the SmartGangster & OriginalGangster, leaving rewards behind.\n     * It also reduces allowance of the unirouter\n     */\n    function panic() public onlyOwner {\n        pause();\n\n        ISmartGangster(smartGangster).emergencyWithdraw();\n\n        uint256 hoesBal = IERC20(hoes).balanceOf(address(this));\n        IOriginalGangsterV2(originalGangster).leaveStaking(hoesBal);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(drugs).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(drugs).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n}"
    },
    "contracts/BIFI/strategies/Snowball/StrategySnowballLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouter.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/pancake/IMasterChef.sol\";\r\n\r\n/**\r\n * @dev Strategy to farm snob through a MasterChef based rewards contract.\r\n */\r\ncontract StrategySnowballLP is Ownable, Pausable {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Tokens Used:\r\n     * {wavax} - Required for liquidity routing when doing swaps.\r\n     * {snob} - Token generated by staking our funds. In this case it's the snob token.\r\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\r\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\r\n     */\r\n    address constant public wavax = address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n    address constant public snob = address(0xC38f41A296A4493Ff429F1238e030924A1542e50);\r\n    address public lpPair;\r\n    address public lpToken0;\r\n    address public lpToken1;\r\n\r\n    /**\r\n     * @dev Third Party Contracts:\r\n     * {pngrouter} - Pangolin router\r\n     * {poolId} - PoolId for MasterChef contract\r\n     * {icequeen} - snob MasterChef contract IceQueen\r\n     */\r\n    address constant public pngrouter = address(0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106);\r\n    address constant public icequeen = address(0xB12531a2d758c7a8BF09f44FC88E646E1BF9D375);\r\n    uint8 public poolId;\r\n\r\n    /**\r\n     * @dev Beefy Contracts:\r\n     * {treasury} - Address of the Beefy treasury. Rewards accumulate here and are then sent to BSC.\r\n     * {vault} - Address of the vault that controls the strategy's funds.\r\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\r\n     */\r\n    address constant public treasury = address(0xA3e3Af161943CfB3941B631676134bb048739727);\r\n    address public vault;\r\n    address public strategist;\r\n\r\n    /**\r\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\r\n     * Current implementation separates 4.5% for fees.\r\n     *\r\n     * {TREASURY_FEE} - 3.75% goes to BIFI holders through the {treasury}.\r\n     * {CALL_FEE} - 0.25% goes to whoever executes the harvest function as gas subsidy.\r\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\r\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\r\n     *\r\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\r\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\r\n     */\r\n    uint constant public CALL_FEE       = 55;\r\n    uint constant public TREASURY_FEE   = 833;\r\n    uint constant public STRATEGIST_FEE = 112;\r\n    uint constant public MAX_FEE        = 1000;\r\n\r\n    uint constant public WITHDRAWAL_FEE = 10;\r\n    uint constant public WITHDRAWAL_MAX = 10000;\r\n\r\n    /**\r\n     * @dev Routes we take to swap tokens using Pangolin.\r\n     * {snobToWavaxRoute} - Route we take to get from {snob} into {wbnb}.\r\n     * {snobToLp0Route} - Route we take to get from {snob} into {lpToken0}.\r\n     * {snobToLp1Route} - Route we take to get from {snob} into {lpToken1}.\r\n     */\r\n    address[] public snobToWavaxRoute = [snob, wavax];\r\n    address[] public snobToLp0Route;\r\n    address[] public snobToLp1Route;\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    /**\r\n     * @dev Initializes the strategy with the token to maximize.\r\n     */\r\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\r\n        lpPair = _lpPair;\r\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\r\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\r\n        poolId = _poolId;\r\n        vault = _vault;\r\n        strategist = _strategist;\r\n\r\n        if (lpToken0 == wavax) {\r\n            snobToLp0Route = [snob, wavax];\r\n        } else if (lpToken0 != snob) {\r\n            snobToLp0Route = [snob, wavax, lpToken0];\r\n        }\r\n\r\n        if (lpToken1 == wavax) {\r\n            snobToLp1Route = [snob, wavax];\r\n        } else if (lpToken1 != snob) {\r\n            snobToLp1Route = [snob, wavax, lpToken1];\r\n        }\r\n\r\n        IERC20(lpPair).safeApprove(icequeen, type(uint).max);\r\n        IERC20(snob).safeApprove(pngrouter, type(uint).max);\r\n        IERC20(wavax).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken0).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken0).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken1).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken1).safeApprove(pngrouter, type(uint).max);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that puts the funds to work.\r\n     * It gets called whenever someone deposits in the strategy's vault contract.\r\n     * It deposits {lpPair} in the Reward Pool to farm {snob}\r\n     */\r\n    function deposit() public whenNotPaused {\r\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\r\n\r\n        if (pairBal > 0) {\r\n            IMasterChef(icequeen).deposit(poolId, pairBal);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws funds and sents them back to the vault.\r\n     * It withdraws {lpPair} from the Reward Pool.\r\n     * The available {lpPair} minus fees is returned to the vault.\r\n     */\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\r\n\r\n        if (pairBal < _amount) {\r\n            IMasterChef(icequeen).withdraw(poolId, _amount.sub(pairBal));\r\n            pairBal = IERC20(lpPair).balanceOf(address(this));\r\n        }\r\n\r\n        if (pairBal > _amount) {\r\n            pairBal = _amount;\r\n        }\r\n\r\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\r\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\r\n     * 1. It claims rewards from the Reward Pool.\r\n     * 2. It charges the system fees to simplify the split.\r\n     * 3. It swaps the {snob} token for {lpToken0} & {lpToken1}\r\n     * 4. Adds more liquidity to the pool.\r\n     * 5. It deposits the new LP tokens.\r\n     */\r\n    function harvest() external whenNotPaused {\r\n        require(!Address.isContract(msg.sender), \"!contract\");\r\n        IMasterChef(icequeen).deposit(poolId, 0);\r\n        chargeFees();\r\n        addLiquidity();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes out 4.5% as system fees from the rewards.\r\n     * 0.5% -> Call Fee\r\n     * 0.5% -> Treasury fee\r\n     * 0.5% -> Strategist fee\r\n     * 3.0% -> BIFI Holders\r\n     */\r\n    function chargeFees() internal {\r\n        uint256 toWavax = IERC20(snob).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouter(pngrouter).swapExactTokensForTokens(toWavax, 0, snobToWavaxRoute, address(this), block.timestamp.add(600));\r\n\r\n        uint256 wavaxBal = IERC20(wavax).balanceOf(address(this));\r\n\r\n        uint256 treasuryFee = wavaxBal.mul(TREASURY_FEE).div(MAX_FEE);\r\n        IERC20(wavax).safeTransfer(treasury, treasuryFee);\r\n\r\n        uint256 callFee = wavaxBal.mul(CALL_FEE).div(MAX_FEE);\r\n        IERC20(wavax).safeTransfer(msg.sender, callFee);\r\n\r\n        uint256 strategistFee = wavaxBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(wavax).safeTransfer(strategist, strategistFee);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps {png} for {lpToken0}, {lpToken1} & {wavax} using Pangolin.\r\n     */\r\n    function addLiquidity() internal {\r\n        uint256 snobHalf = IERC20(snob).balanceOf(address(this)).div(2);\r\n\r\n        if (lpToken0 != snob) {\r\n            IUniswapRouter(pngrouter).swapExactTokensForTokens(snobHalf, 0, snobToLp0Route, address(this), block.timestamp.add(600));\r\n        }\r\n\r\n        if (lpToken1 != snob) {\r\n            IUniswapRouter(pngrouter).swapExactTokensForTokens(snobHalf, 0, snobToLp1Route, address(this), block.timestamp.add(600));\r\n        }\r\n\r\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\r\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\r\n        IUniswapRouter(pngrouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\r\n    }\r\n\r\n    /**\r\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\r\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\r\n     */\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfLpPair().add(balanceOfPool());\r\n    }\r\n\r\n    /**\r\n     * @dev It calculates how much {lpPair} the contract holds.\r\n     */\r\n    function balanceOfLpPair() public view returns (uint256) {\r\n        return IERC20(lpPair).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev It calculates how much {lpPair} the strategy has allocated in the Reward Pool\r\n     */\r\n    function balanceOfPool() public view returns (uint256) {\r\n         (uint256 _amount, ) = IMasterChef(icequeen).userInfo(poolId, address(this));\r\n         return _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\r\n     * vault, ready to be migrated to the new strat.\r\n     */\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IMasterChef(icequeen).emergencyWithdraw(poolId);\r\n\r\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\r\n        IERC20(lpPair).transfer(vault, pairBal);\r\n    }\r\n\r\n    /**\r\n     * @dev Pauses deposits. Withdraws all funds from the Reward Pool, leaving rewards behind\r\n     */\r\n    function panic() public onlyOwner {\r\n        pause();\r\n        IMasterChef(icequeen).emergencyWithdraw(poolId);\r\n    }\r\n\r\n    /**\r\n     * @dev Pauses the strat.\r\n     */\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n\r\n        IERC20(lpPair).safeApprove(icequeen, 0);\r\n        IERC20(snob).safeApprove(pngrouter, 0);\r\n        IERC20(wavax).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken0).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken1).safeApprove(pngrouter, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses the strat.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n\r\n        IERC20(lpPair).safeApprove(icequeen, type(uint).max);\r\n        IERC20(snob).safeApprove(pngrouter, type(uint).max);\r\n        IERC20(wavax).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken0).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken0).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken1).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken1).safeApprove(pngrouter, type(uint).max);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates address where strategist fee earnings will go.\r\n     * @param _strategist new strategist address.\r\n     */\r\n    function setStrategist(address _strategist) external {\r\n        require(msg.sender == strategist, \"!strategist\");\r\n        strategist = _strategist;\r\n    }\r\n}"
    },
    "contracts/BIFI/interfaces/pancake/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMasterChef {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function enterStaking(uint256 _amount) external;\n    function leaveStaking(uint256 _amount) external;\n    function pendingCake(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Swipe/StrategySwipeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in SwipeSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategySwipeLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd, btcn} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the Swipe token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public btcb = address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\n    address constant public output = address(0x47BEAd2563dCBf3bF2c9407fEa4dC236fAbA485A);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {pcsrouter} - PancakeSwap unirouter\n     * {unirouter} - SwipeSwap unirouter\n     * {masterchef} - SwipeSwap contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public pcsrouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public unirouter  = address(0x816278BbBCc529f8cdEE8CC72C226fb01def6E6C);\n    address constant public masterchef = address(0xe6421c0CC2d647be51c11AE952927aB38Dd6f753);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using SwipeSwap and PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 == btcb) {\n            outputToLp0Route = [output, btcb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 == btcb) {\n            outputToLp1Route = [output, btcb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(pcsrouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(pcsrouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(pcsrouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(pcsrouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Snowball/StrategySnowball3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../interfaces/snob/ISnobLP.sol\";\n\n/**\n * @dev Strategy to farm snob through a MasterChef based rewards contract.\n */\ncontract StrategySnowball3Pool is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wavax, usdt} - Required for liquidity routing when doing swaps.\n     * {snob} - Token generated by staking our funds. In this case it's the snob token.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. s3D BUSD/USDT/DAI\n     */\n    address constant public wavax = address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    address constant public usdt = address(0xde3A24028580884448a5397872046a019649b084);\n    address constant public snob = address(0xC38f41A296A4493Ff429F1238e030924A1542e50);\n    address constant public want = address(0xdE1A11C331a0E45B9BA8FeE04D4B51A745f1e4A4);\n\n    /**\n     * @dev Third Party Contracts:\n     * {pngrouter} - Pangolin router\n     * {icequeen} - snob MasterChef contract IceQueen\n     * {poolLP} - 3Pool LP contract to deposit BUSD/USDC/USDT and mint {want}\n     * {poolId} - PoolId for MasterChef contract\n     */\n    address constant public pngrouter = address(0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106);\n    address constant public icequeen  = address(0xB12531a2d758c7a8BF09f44FC88E646E1BF9D375);\n    address constant public poolLp    = address(0x6B41E5c07F2d382B921DE5C34ce8E2057d84C042);\n    uint8 constant public poolId = 7;\n\n    /**\n     * @dev Beefy Contracts:\n     * {treasury} - Address of the Beefy treasury. Rewards accumulate here and are then sent to BSC.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public treasury = address(0xA3e3Af161943CfB3941B631676134bb048739727);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 3.75% goes to BIFI holders through the {treasury}.\n     * {CALL_FEE} - 0.25% goes to whoever executes the harvest function as gas subsidy.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public CALL_FEE       = 55;\n    uint constant public TREASURY_FEE   = 833;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Pangolin.\n     * {snobToWavaxRoute} - Route we take to get from {snob} into {wbnb}.\n     * {snobToUsdtRoute} - Route we take to get from {snob} into {usdt}.\n     */\n    address[] public snobToWavaxRoute = [snob, wavax];\n    address[] public snobToUsdtRoute = [snob, wavax, usdt];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(icequeen, type(uint).max);\n        IERC20(snob).safeApprove(pngrouter, type(uint).max);\n        IERC20(usdt).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the Reward Pool to farm {snob}\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(icequeen).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {want} from the Reward Pool.\n     * The available {want} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(icequeen).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Reward Pool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {snob} token for {usdt}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(icequeen).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.25% -> Call Fee\n     * 3.75% -> Treasury fee\n     * 0.5% -> Strategist fee\n     */\n    function chargeFees() internal {\n        uint256 toWavax = IERC20(snob).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(pngrouter).swapExactTokensForTokens(toWavax, 0, snobToWavaxRoute, address(this), block.timestamp.add(600));\n\n        uint256 wavaxBal = IERC20(wavax).balanceOf(address(this));\n\n        uint256 treasuryFee = wavaxBal.mul(TREASURY_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(treasury, treasuryFee);\n\n        uint256 callFee = wavaxBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(msg.sender, callFee);\n\n        uint256 strategistFee = wavaxBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(strategist, strategistFee);\n\n    }\n\n    /**\n     * @dev Swaps {snob} rewards earned for {usdt} and adds to 3Pool LP.\n     */\n    function addLiquidity() internal {\n        uint256 snobBal = IERC20(snob).balanceOf(address(this));\n        IUniswapRouter(pngrouter).swapExactTokensForTokens(snobBal, 0, snobToUsdtRoute, address(this), block.timestamp.add(600));\n\n        uint256 usdtBal = IERC20(usdt).balanceOf(address(this));\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = usdtBal;\n        ISnobLP(poolLp).addLiquidity(amounts, 0, block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the Reward Pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n         (uint256 _amount, ) = IMasterChef(icequeen).userInfo(poolId, address(this));\n         return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(icequeen).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Reward Pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(icequeen).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(icequeen, 0);\n        IERC20(snob).safeApprove(pngrouter, 0);\n        IERC20(usdt).safeApprove(poolLp, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(icequeen, type(uint).max);\n        IERC20(snob).safeApprove(pngrouter, type(uint).max);\n        IERC20(usdt).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/snob/ISnobLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ISnobLP {\n\n//    function add_liquidity(uint256[4] memory uamounts, uint256 min_mint_amount) external;\n    function addLiquidity(uint256[] calldata amounts, uint256 minToMint, uint256 deadline) external returns (uint256);\n}"
    },
    "contracts/BIFI/strategies/Olive/StrategyOliveLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Strategy to farm OLIVE through a MasterChef based rewards contract.\n */\ncontract StrategyOliveLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wavax, usdt} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the OLIVE token.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wavax  = address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    address constant public usdt   = address(0xde3A24028580884448a5397872046a019649b084);\n    address constant public output = address(0x617724974218A18769020A70162165A539c07E8a);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - OliveSwap router\n     * {masterchef} - MasterChef contract\n     * {poolId} - PoolId for MasterChef contract\n     */\n    address constant public unirouter = address(0x0c45FB63001b56a21e29c7dcc1727bfDA273a368);\n    address constant public masterchef = address(0x5A9710f3f23053573301C2aB5024D0a43A461E80);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {treasury} - Address of the Beefy treasury. Rewards accumulate here and are then sent to BSC.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public treasury = address(0xA3e3Af161943CfB3941B631676134bb048739727);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 3.75% goes to BIFI holders through the {treasury}.\n     * {CALL_FEE} - 0.25% goes to whoever executes the harvest function as gas subsidy.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public CALL_FEE       = 55;\n    uint constant public TREASURY_FEE   = 833;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Pangolin.\n     * {outputToWavaxRoute} - Route we take to get from {output} into {wbnb}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWavaxRoute = [output, wavax];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wavax) {\n            outputToLp0Route = [output, wavax];\n        } else if (lpToken0 == usdt) {\n            outputToLp0Route = [output, usdt];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wavax, lpToken0];\n        }\n\n        if (lpToken1 == wavax) {\n            outputToLp1Route = [output, wavax];\n        } else if (lpToken1 == usdt) {\n            outputToLp1Route = [output, usdt];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wavax, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.25% -> Call Fee\n     * 3.75% -> Treasury fee\n     * 0.5% -> Strategist fee\n     */\n    function chargeFees() internal {\n        uint256 toWavax = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWavax, 0, outputToWavaxRoute, address(this), block.timestamp.add(600));\n\n        uint256 wavaxBal = IERC20(wavax).balanceOf(address(this));\n\n        uint256 treasuryFee = wavaxBal.mul(TREASURY_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(treasury, treasuryFee);\n\n        uint256 callFee = wavaxBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(msg.sender, callFee);\n\n        uint256 strategistFee = wavaxBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(strategist, strategistFee);\n\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1}.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n         (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n         return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Kebab/StrategyKebabLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Kebab Finance.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyKebabLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd, btcb} - Required for liquidity routing when doing swaps.\n     * {kebab} - Token generated by staking our funds. In this case it's the KEBAB token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public btcb = address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\n    address constant public kebab = address(0x7979F6C54ebA05E18Ded44C4F986F49a5De551c2);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x76FCeffFcf5325c6156cA89639b17464ea833ECd);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {kebabToWbnbRoute} - Route we take to get from {kebab} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {kebabToLp0Route} - Route we take to get from {kebab} into {lpToken0}.\n     * {kebabToLp1Route} - Route we take to get from {kebab} into {lpToken1}.\n     */\n    address[] public kebabToWbnbRoute = [kebab, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public kebabToLp0Route;\n    address[] public kebabToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            kebabToLp0Route = [kebab, wbnb];\n        } else if (lpToken0 == btcb) {\n            kebabToLp0Route = [kebab, btcb];\n        } else if (lpToken0 == busd) {\n            kebabToLp0Route = [kebab, busd];\n        } else if (lpToken0 != kebab) {\n            kebabToLp0Route = [kebab, busd, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            kebabToLp1Route = [kebab, wbnb];\n        } else if (lpToken1 == btcb) {\n            kebabToLp1Route = [kebab, btcb];\n        } else if (lpToken1 == busd) {\n            kebabToLp1Route = [kebab, busd];\n        } else if (lpToken1 != kebab) {\n            kebabToLp1Route = [kebab, busd, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(kebab).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {kebab}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {kebab} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(kebab).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, kebabToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {kebab} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 kebabHalf = IERC20(kebab).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != kebab) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(kebabHalf, 0, kebabToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != kebab) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(kebabHalf, 0, kebabToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(kebab).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(kebab).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Kebab/StrategyKebab.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Strategy to farm Kebab through a Pancake based MasterChef contract.\n */\ncontract StrategyKebab is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {kebab} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public kebab = address(0x7979F6C54ebA05E18Ded44C4F986F49a5De551c2);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract. Stake Kebab, get rewards.\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x76FCeffFcf5325c6156cA89639b17464ea833ECd);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.0% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 667;\n    uint constant public CALL_FEE       = 83;\n    uint constant public TREASURY_FEE   = 167;\n    uint constant public STRATEGIST_FEE = 83;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {kebabToWbnbRoute} - Route we take to go from {kebab} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public kebabToWbnbRoute = [kebab, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(kebab).safeApprove(masterchef, type(uint).max);\n        IERC20(kebab).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits kebab in the MasterChef to earn rewards in kebab.\n     */\n    function deposit() public whenNotPaused {\n        uint256 kebabBal = IERC20(kebab).balanceOf(address(this));\n\n        if (kebabBal > 0) {\n            IMasterChef(masterchef).enterStaking(kebabBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws kebab from the MasterChef and sends it to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 kebabBal = IERC20(kebab).balanceOf(address(this));\n\n        if (kebabBal < _amount) {\n            IMasterChef(masterchef).leaveStaking(_amount.sub(kebabBal));\n            kebabBal = IERC20(kebab).balanceOf(address(this));\n        }\n\n        if (kebabBal > _amount) {\n            kebabBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(kebab).safeTransfer(vault, kebabBal);\n        } else {\n            uint256 withdrawalFee = kebabBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(kebab).safeTransfer(vault, kebabBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).leaveStaking(0);\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.0% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 4.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(kebab).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, kebabToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {kebab} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfKebab().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {kebab} the contract holds.\n     */\n    function balanceOfKebab() public view returns (uint256) {\n        return IERC20(kebab).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {kebab} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(0, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(0);\n\n        uint256 kebabBal = IERC20(kebab).balanceOf(address(this));\n        IERC20(kebab).transfer(vault, kebabBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(0);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(kebab).safeApprove(masterchef, 0);\n        IERC20(kebab).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(kebab).safeApprove(masterchef, type(uint).max);\n        IERC20(kebab).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Jetfuel/StrategyJetfuelLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyJetfuelLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x2090c8295769791ab7A3CF1CC6e0AA19F35e441A);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x86f4bC1EBf2C209D12d3587B7085aEA5707d4B56);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyZefiLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyZefiLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x0288D3E353fE2299F11eA2c2e1696b4A648eCC07);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x05a8ba2DEf87f8AdaF223Edcd04F7Fc82eA6aee8);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyTofyLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyTofyLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public mash = address(0x787732f27D18495494cea3792ed7946BbCFF8db2);\n    address constant public output = address(0xE1F2d89a6c79b4242F300f880e490A70083E9A1c);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xEE49Aa34833Ca3b7d873ED63CDBc031A09226a5d);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 == mash) {\n            outputToLp0Route = [output, mash];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 == mash) {\n            outputToLp1Route = [output, mash];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyTofy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyTofy is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0xE1F2d89a6c79b4242F300f880e490A70083E9A1c);\n\n    // Third party contracts\n    address constant public masterchef = address(0xEE49Aa34833Ca3b7d873ED63CDBc031A09226a5d);\n    uint256 constant public poolId = 2;\n\n    // Routes\n    address[] public wantToWbnbRoute = [want, wbnb];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    function beforeDeposit() external override {\n        harvest();\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() public whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(tx.origin, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategySpaceLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in SpaceFarm.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategySpaceLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the SPACE token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x0abd3E3502c15ec252f90F64341cbA74a24fba06);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0xc8cf0767fB2258b23B90636A5e21cfaD113e8182);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategySaltLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in SaltSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategySaltLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the Salt token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x2849b1aE7E04A3D9Bc288673A92477CF63F28aF4);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0xB4405445fFAcF2B86BC2bD7D1C874AC739265658);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyRamenLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in RamenSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyRamenLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the Ramen token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x4F47A0d15c1E53F3d94c069C7D16977c29F9CB6B);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x97DD424B4628C8D3bD7fCf3A4e974Cebba011651);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyPalmLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in YieldBay.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyPalmLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the PALM token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x9768E5b2d8e761905BC81Dfc554f9437A46CdCC6);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0xf1530E2826920847Ba3Eaf9f60101Bf557332E67);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyPalm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Strategy to farm PALM through a Pancake based MasterChef contract.\n */\ncontract StrategyPalm is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. PALM\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x9768E5b2d8e761905BC81Dfc554f9437A46CdCC6);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0xf1530E2826920847Ba3Eaf9f60101Bf557332E67);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.0% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 667;\n    uint constant public CALL_FEE       = 83;\n    uint constant public TREASURY_FEE   = 167;\n    uint constant public STRATEGIST_FEE = 83;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap\n     * {wantToWbnbRoute} - Route we take to go from {want} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public wantToWbnbRoute = [want, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the MasterChef to earn rewards in {want}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).enterStaking(wantBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws {want} from the MasterChef and sends it to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).leaveStaking(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChef(masterchef).leaveStaking(0);\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.0% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 4.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to synchronize balance of {want}.\n     * It harvests pending rewards from the pool.\n     */\n    function updateBalance() public {\n        harvest();\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(0, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(0);\n\n        uint256 wanBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wanBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(0);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyMasterChefApeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyMasterChefApeLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wrapped = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x5c8D727b265DBAfaba67E050f2f739cAeEB4A6F9);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWrappedRoute = [output, wrapped];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wrapped) {\n            outputToLp0Route = [output, wrapped];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wrapped, lpToken0];\n        }\n\n        if (lpToken1 == wrapped) {\n            outputToLp1Route = [output, wrapped];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wrapped, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWrapped = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWrapped, 0, outputToWrappedRoute, address(this), block.timestamp);\n\n        uint256 wrappedBal = IERC20(wrapped).balanceOf(address(this));\n\n        uint256 callFeeAmount = wrappedBal.mul(callFee).div(MAX_FEE);\n        IERC20(wrapped).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wrappedBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wrapped).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wrappedBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wrapped).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyMashLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Marshmallow.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyMashLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the MASH token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x787732f27D18495494cea3792ed7946BbCFF8db2);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x8932a6265b01D1D4e1650fEB8Ac38f9D79D3957b);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     *\n     * {callFee} - 0.25% goes to whoever executes the harvest. Can be lowered.\n     * {rewardsFee} - 3% that goes to BIFI holders. Can be increased by decreasing {callFee}.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n    uint constant public MAX_CALL_FEE = 111;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    uint public callFee = 55;\n    uint public rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external onlyOwner {\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyMash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Strategy to farm MASH through a Pancake based MasterChef contract.\n */\ncontract StrategyMash is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. MASH\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x787732f27D18495494cea3792ed7946BbCFF8db2);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id for single {want} staking\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x8932a6265b01D1D4e1650fEB8Ac38f9D79D3957b);\n    uint8 constant public poolId = 4;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     *\n     * {callFee} - 0.25% goes to whoever executes the harvest. Can be lowered.\n     * {rewardsFee} - 3% that goes to BIFI holders. Can be increased by decreasing {callFee}.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n    uint constant public MAX_CALL_FEE = 111;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    uint public callFee = 55;\n    uint public rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap\n     * {wantToWbnbRoute} - Route we take to go from {want} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public wantToWbnbRoute = [want, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the MasterChef to earn rewards in {want}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws {want} from the MasterChef and sends it to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to synchronize balance of {want}.\n     * It harvests pending rewards from the pool.\n     */\n    function updateBalance() public {\n        harvest();\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wanBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wanBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external onlyOwner {\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyJetswapWings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyJetswapWings is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x0487b824c8261462F88940f97053E65bDb498446);\n\n    // Third party contracts\n    address constant public masterchef = address(0x63d6EC1cDef04464287e2af710FFef9780B6f9F5);\n    uint256 constant public poolId = 0;\n\n    // Routes\n    address[] public wantToWbnbRoute = [want, wbnb];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).enterStaking(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).leaveStaking(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    function beforeDeposit() external override {\n        harvest();\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() public whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChef(masterchef).leaveStaking(0);\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(tx.origin, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyJetswapLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyJetswapLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x0487b824c8261462F88940f97053E65bDb498446);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x63d6EC1cDef04464287e2af710FFef9780B6f9F5);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyJetswapBusdLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyJetswapBusdLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x0487b824c8261462F88940f97053E65bDb498446);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x63d6EC1cDef04464287e2af710FFef9780B6f9F5);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, busd, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, busd, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyIronLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyIronLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public iron = address(0x7b65B489fE53fCE1F6548Db886C08aD73111DDd8);\n    address constant public output = address(0x9001eE054F1692feF3A48330cB543b6FEc6287eb);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xC5a992dD7ba108e3349D2Fd8e8E126753Ca8Ce34);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == iron) {\n            outputToLp0Route = [output, iron];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == iron) {\n            outputToLp1Route = [output, iron];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyIronDNDLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyIronDNDLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x34EA3F7162E6f6Ed16bD171267eC180fD5c848da);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xAA8b49a4FC0A4C94087B2A01AaC760D89D491432);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyIronDND.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyIronDND is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x34EA3F7162E6f6Ed16bD171267eC180fD5c848da);\n\n    // Third party contracts\n    address constant public masterchef = address(0x5d8b018BF2058Cd5264AA8c97A29E23cE660B3Ea);\n    uint256 constant public poolId = 0;\n\n    // Routes\n    address[] public wantToWbnbRoute = [want, wbnb];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    function beforeDeposit() external override {\n        harvest();\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() public whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(tx.origin, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyGoalLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyGoalLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0xE5b57E6e1b945B91FEE368aC108d2ebCcA78Aa8F);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x23A88eDd92559d18A36B3B1B3DD957AF6459465e);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, busd, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, busd, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyCafeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in CafeSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyCafeLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {brew} - Token generated by staking our funds. In this case it's the BREW token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public brew = address(0x790Be81C3cA0e53974bE2688cDb954732C9862e1);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0xc772955c33088a97D56d0BBf473d05267bC4feBB);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {brewToWbnbRoute} - Route we take to get from {brew} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {brewToLp0Route} - Route we take to get from {brew} into {lpToken0}.\n     * {brewToLp1Route} - Route we take to get from {brew} into {lpToken1}.\n     */\n    address[] public brewToWbnbRoute = [brew, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public brewToLp0Route;\n    address[] public brewToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            brewToLp0Route = [brew, wbnb];\n        } else if (lpToken0 == busd) {\n            brewToLp0Route = [brew, busd];\n        } else if (lpToken0 != brew) {\n            brewToLp0Route = [brew, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            brewToLp1Route = [brew, wbnb];\n        } else if (lpToken1 == busd) {\n            brewToLp1Route = [brew, busd];\n        } else if (lpToken1 != brew) {\n            brewToLp1Route = [brew, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(brew).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {brew}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {brew} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(brew).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, brewToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {brew} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 brewHalf = IERC20(brew).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != brew) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(brewHalf, 0, brewToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != brew) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(brewHalf, 0, brewToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(brew).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(brew).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyCafeDexLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in CafeSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyCafeDexLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {brew} - Token generated by staking our funds. In this case it's the BREW token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public brew = address(0x790Be81C3cA0e53974bE2688cDb954732C9862e1);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {caferouter} - CafeSwap router\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public caferouter = address(0x933DAea3a5995Fb94b14A7696a5F3ffD7B1E385A);\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0xc772955c33088a97D56d0BBf473d05267bC4feBB);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using CafeSwap and PancakeSwap.\n     * {brewToWbnbRoute} - Route we take to get from {brew} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {brewToLp0Route} - Route we take to get from {brew} into {lpToken0}.\n     * {brewToLp1Route} - Route we take to get from {brew} into {lpToken1}.\n     */\n    address[] public brewToWbnbRoute = [brew, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public brewToLp0Route;\n    address[] public brewToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            brewToLp0Route = [brew, wbnb];\n        } else if (lpToken0 == busd) {\n            brewToLp0Route = [brew, busd];\n        } else if (lpToken0 != brew) {\n            brewToLp0Route = [brew, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            brewToLp1Route = [brew, wbnb];\n        } else if (lpToken1 == busd) {\n            brewToLp1Route = [brew, busd];\n        } else if (lpToken1 != brew) {\n            brewToLp1Route = [brew, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(brew).safeApprove(caferouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(caferouter, 0);\n        IERC20(lpToken0).safeApprove(caferouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(caferouter, 0);\n        IERC20(lpToken1).safeApprove(caferouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {brew}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {brew} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(brew).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(caferouter).swapExactTokensForTokens(toWbnb, 0, brewToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {brew} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 brewHalf = IERC20(brew).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != brew) {\n            IUniswapRouterETH(caferouter).swapExactTokensForTokens(brewHalf, 0, brewToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != brew) {\n            IUniswapRouterETH(caferouter).swapExactTokensForTokens(brewHalf, 0, brewToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(caferouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(brew).safeApprove(caferouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(caferouter, 0);\n        IERC20(lpToken1).safeApprove(caferouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(brew).safeApprove(caferouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(caferouter, 0);\n        IERC20(lpToken0).safeApprove(caferouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(caferouter, 0);\n        IERC20(lpToken1).safeApprove(caferouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyBlizzard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Strategy to farm xBLZD on Blizzard.Money.\n */\ncontract StrategyBlizzard is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {want} - Token that the strategy maximizes. In this case, xBLZD.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x9a946c3Cb16c08334b69aE249690C236Ebd5583E);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x367CdDA266ADa588d380C7B970244434e4Dde790);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     * {keeper} - Address used as an extra strat manager.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n    address public keeper;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     * {callFee} - 0.25% goes to whoever executes the harvest. Can be adjusted.\n     * {rewardsFee} - 3.25% goes to BIFI holders through the {rewards} pool. Adjusted by callFee changes.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_CALL_FEE   = 111;\n    uint constant public MAX_FEE        = 1000;\n    uint public callFee                 = 56;\n    uint public rewardsFee              = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {wantToWbnbRoute} - Route we take to get from {want} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public wantToWbnbRoute = [want, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest();\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(uint8 _poolId, address _vault, address _strategist) {\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws {want} from the MasterChef and sends it to the Vault.\n     * Fees are not assessed if the Vault is paused.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Public harvest. Doesn't work when the strat is paused.\n     */\n    function harvest() external whenNotPaused {\n        _harvest();\n    }\n\n    /**\n     * @dev Harvest to keep the strat working while paused. Helpful in some cases.\n     */\n    function sudoHarvest() external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _harvest();\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fee and sends it to BIFI stakers.\n     * 3. It re-invests the remaining profits.\n     */\n    function _harvest() internal gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        deposit();\n\n        emit StratHarvest();\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.25% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.25% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _pause();\n\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _unpause();\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates address of the strat keeper.\n     * @param _keeper new keeper address.\n     */\n    function setKeeper(address _keeper) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        keeper = _keeper;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n        require(_fee < MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        require(_token != want, \"!want\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyBitiLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in BitiBots.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyBitiLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the BITI token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0xA25Dab5B75aC0E0738E58E49734295baD43d73F1);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x2Dc2d579e0e0EA9Ab2EF5CcA4e813Ca7769148cB);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     *\n     * {callFee} - 0.25% goes to whoever executes the harvest. Can be lowered.\n     * {rewardsFee} - 3% that goes to BIFI holders. Can be increased by decreasing {callFee}.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n    uint constant public MAX_CALL_FEE = 111;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    uint public callFee = 55;\n    uint public rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external onlyOwner {\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyApeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in ApeSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyApeLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the BANANA token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {aperouter} - ApeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public aperouter  = address(0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607);\n    address constant public masterchef = address(0x5c8D727b265DBAfaba67E050f2f739cAeEB4A6F9);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using ApeSwap and PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(aperouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(aperouter, 0);\n        IERC20(lpToken0).safeApprove(aperouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(aperouter, 0);\n        IERC20(lpToken1).safeApprove(aperouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(aperouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(aperouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(aperouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(aperouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(aperouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(aperouter, 0);\n        IERC20(lpToken1).safeApprove(aperouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(aperouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(aperouter, 0);\n        IERC20(lpToken0).safeApprove(aperouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(aperouter, 0);\n        IERC20(lpToken1).safeApprove(aperouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyApe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Strategy to farm BANANA through a Pancake based MasterChef contract.\n */\ncontract StrategyApe is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. BANANA\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x603c7f932ED1fc6575303D8Fb018fDCBb0f39a95);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {aperouter} - ApeSwap unirouter\n     * {masterchef} - MasterChef contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public aperouter  = address(0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607);\n    address constant public masterchef = address(0x5c8D727b265DBAfaba67E050f2f739cAeEB4A6F9);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.0% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 667;\n    uint constant public CALL_FEE       = 83;\n    uint constant public TREASURY_FEE   = 167;\n    uint constant public STRATEGIST_FEE = 83;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap and ApeSwap.\n     * {wantToWbnbRoute} - Route we take to go from {want} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public wantToWbnbRoute = [want, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(aperouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the MasterChef to earn rewards in {want}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).enterStaking(wantBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws {want} from the MasterChef and sends it to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).leaveStaking(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).leaveStaking(0);\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.0% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 4.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouter(aperouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(0, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(0);\n\n        uint256 wanBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wanBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(0);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(aperouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(want).safeApprove(aperouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Complus/StrategyComBscLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Complus.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyComBscLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the COM token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x7fa892544D49598460B821De4D99E8c28b1Decaa);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {comrouter} - Complus unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public comrouter  = address(0x07DC75E8bc57A21A183129Ec29bbCC232d79eE56);\n    address constant public masterchef = address(0x110650bBAfCe4Ec7e864fe4A4A88BBD4AF547159);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Complus and PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(comrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(comrouter, 0);\n        IERC20(lpToken0).safeApprove(comrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(comrouter, 0);\n        IERC20(lpToken1).safeApprove(comrouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(comrouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using Complus.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(comrouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(comrouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(comrouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(comrouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(comrouter, 0);\n        IERC20(lpToken1).safeApprove(comrouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(comrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(comrouter, 0);\n        IERC20(lpToken0).safeApprove(comrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(comrouter, 0);\n        IERC20(lpToken1).safeApprove(comrouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakeV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouter.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/pancake/IMasterChef.sol\";\r\nimport \"../Common/FeeManagerCake.sol\";\r\nimport \"../Common/StratManagerCake.sol\";\r\n\r\ncontract StrategyCakeV2 is StratManagerCake, FeeManagerCake {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public wrapped = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n    address constant public want = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\r\n\r\n    // Third party contracts\r\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\r\n\r\n    // Routes\r\n    address[] public wantToWrappedRoute = [want, wrapped];\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester, uint256 indexed timestamp);\r\n\r\n    constructor(\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _beefyFeeRecipient\r\n    ) StratManagerCake(_keeper, _unirouter, _vault, _beefyFeeRecipient) {\r\n        _giveAllowances();\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal > 0) {\r\n            IMasterChef(masterchef).enterStaking(wantBal);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal < _amount) {\r\n            IMasterChef(masterchef).leaveStaking(_amount.sub(wantBal));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n        if (tx.origin == owner() || paused()) {\r\n            IERC20(want).safeTransfer(vault, wantBal);\r\n        } else {\r\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\r\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\r\n        }\r\n    }\r\n\r\n    function beforeDeposit() external override {\r\n        harvest();\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() public whenNotPaused {\r\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\r\n        IMasterChef(masterchef).leaveStaking(0);\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        if (wantBal > 0) {\r\n            chargeFees();\r\n            deposit();\r\n            emit StratHarvest(msg.sender, block.timestamp);\r\n        }\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toWrapped = IERC20(want).balanceOf(address(this)).mul(10).div(1000);\r\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWrapped, 0, wantToWrappedRoute, address(this), block.timestamp);\r\n\r\n        uint256 wrappedBal = IERC20(wrapped).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = wrappedBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(tx.origin, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = wrappedBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n    }\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool());\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // it calculates how much 'want' the strategy has working in the farm.\r\n    function balanceOfPool() public view returns (uint256) {\r\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(0, address(this));\r\n        return _amount;\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IMasterChef(masterchef).emergencyWithdraw(0);\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        pause();\r\n        IMasterChef(masterchef).emergencyWithdraw(0);\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\r\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, 0);\r\n        IERC20(want).safeApprove(unirouter, 0);\r\n    }\r\n}"
    },
    "contracts/BIFI/strategies/Common/FeeManagerCake.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"./StratManagerCake.sol\";\r\n\r\nabstract contract FeeManagerCake is StratManagerCake {\r\n    uint constant public MAX_FEE = 1000;\r\n    uint constant public MAX_CALL_FEE = 111;\r\n\r\n    uint constant public WITHDRAWAL_FEE_CAP = 50;\r\n    uint constant public WITHDRAWAL_MAX = 10000;\r\n\r\n    uint public withdrawalFee = 0;\r\n\r\n    uint public callFee = 0;\r\n    uint public beefyFee = MAX_FEE - callFee;\r\n\r\n    function setCallFee(uint256 _fee) external onlyManager {\r\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\r\n\r\n        callFee = _fee;\r\n        beefyFee = MAX_FEE - callFee;\r\n    }\r\n\r\n    function setWithdrawalFee(uint256 _fee) external onlyManager {\r\n        require(_fee <= WITHDRAWAL_FEE_CAP, \"!cap\");\r\n\r\n        withdrawalFee = _fee;\r\n    }\r\n}"
    },
    "contracts/BIFI/strategies/Common/StratManagerCake.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\ncontract StratManagerCake is Ownable, Pausable {\r\n    /**\r\n     * @dev Beefy Contracts:\r\n     * {keeper} - Address to manage a few lower risk features of the strat\r\n     * {vault} - Address of the vault that controls the strategy's funds.\r\n     * {unirouter} - Address of exchange to execute swaps.\r\n     */\r\n    address public keeper;\r\n    address public unirouter;\r\n    address public vault;\r\n    address public beefyFeeRecipient;\r\n\r\n    /**\r\n     * @dev Initializes the base strategy.\r\n     * @param _keeper address to use as alternative owner.\r\n     * @param _unirouter router to use for swaps\r\n     * @param _vault address of parent vault.\r\n     * @param _beefyFeeRecipient address where to send Beefy's fees.\r\n     */\r\n    constructor(\r\n        address _keeper,\r\n        address _unirouter,\r\n        address _vault,\r\n        address _beefyFeeRecipient\r\n    ) {\r\n        keeper = _keeper;\r\n        unirouter = _unirouter;\r\n        vault = _vault;\r\n        beefyFeeRecipient = _beefyFeeRecipient;\r\n    }\r\n\r\n    // checks that caller is either owner or keeper.\r\n    modifier onlyManager() {\r\n        require(msg.sender == owner() || msg.sender == keeper, \"!manager\");\r\n        _;\r\n    }\r\n\r\n    // verifies that the caller is not a contract.\r\n    modifier onlyEOA() {\r\n        require(msg.sender == tx.origin, \"!EOA\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates address of the strat keeper.\r\n     * @param _keeper new keeper address.\r\n     */\r\n    function setKeeper(address _keeper) external onlyManager {\r\n        keeper = _keeper;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates router that will be used for swaps.\r\n     * @param _unirouter new unirouter address.\r\n     */\r\n    function setUnirouter(address _unirouter) external onlyOwner {\r\n        unirouter = _unirouter;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates parent vault.\r\n     * @param _vault new vault address.\r\n     */\r\n    function setVault(address _vault) external onlyOwner {\r\n        vault = _vault;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates beefy fee recipient.\r\n     * @param _beefyFeeRecipient new beefy fee recipient address.\r\n     */\r\n    function setBeefyFeeRecipient(address _beefyFeeRecipient) external onlyOwner {\r\n        beefyFeeRecipient = _beefyFeeRecipient;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to synchronize balances before new user deposit.\r\n     * Can be overridden in the strategy.\r\n     */\r\n    function beforeDeposit() external virtual {}\r\n}"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakePBtcLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCakePBtcLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public pbtc = address(0xeD28A457A5A76596ac48d87C0f577020F6Ea1c4C);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n    uint256 public poolId;\n\n    // Routes\n    address[] public cakeToWbnbRoute = [cake, wbnb];\n    address[] public cakeToLp0Route;\n    address[] public cakeToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == pbtc) {\n            cakeToLp0Route = [cake, wbnb, pbtc];\n        } else if (lpToken0 != cake) {\n            cakeToLp0Route = [cake, wbnb, pbtc, lpToken0];\n        }\n\n        if (lpToken1 == pbtc) {\n            cakeToLp1Route = [cake, wbnb, pbtc];\n        } else if (lpToken1 != cake) {\n            cakeToLp1Route = [cake, wbnb, pbtc, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(cake).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 cakeHalf = IERC20(cake).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(cake).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(cake).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakeMirrorLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCakeMirrorLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public ust = address(0x23396cF899Ca06c4472205fC903bDB4de249D6fC);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n    uint256 public poolId;\n\n    // Routes\n    address[] public cakeToWbnbRoute = [cake, wbnb];\n    address[] public cakeToLp0Route;\n    address[] public cakeToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == ust) {\n            cakeToLp0Route = [cake, wbnb, busd, ust];\n        } else if (lpToken0 != cake) {\n            cakeToLp0Route = [cake, wbnb, busd, ust, lpToken0];\n        }\n\n        if (lpToken1 == ust) {\n            cakeToLp1Route = [cake, wbnb, busd, ust];\n        } else if (lpToken1 != cake) {\n            cakeToLp1Route = [cake, wbnb, busd, ust, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(cake).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 cakeHalf = IERC20(cake).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(cake).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(cake).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCakeLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n    uint256 public poolId;\n\n    // Routes\n    address[] public cakeToWbnbRoute = [cake, wbnb];\n    address[] public cakeToLp0Route;\n    address[] public cakeToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            cakeToLp0Route = [cake, wbnb];\n        } else if (lpToken0 != cake) {\n            cakeToLp0Route = [cake, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            cakeToLp1Route = [cake, wbnb];\n        } else if (lpToken1 != cake) {\n            cakeToLp1Route = [cake, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(cake).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 cakeHalf = IERC20(cake).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(cake).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(cake).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakeCommunityLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in PancakeSwap.\n * PancakeSwap is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. PancakeSwap is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected MasterChef pool.\n * CAKE rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the MasterChef pool.\n *\n * This strat is an adaptation that only works with the CAKE community pools. This assets have pool liquidity through BNB\n * so we route directly through CAKE.\n */\ncontract StrategyCakeCommunityLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {cake} - Token generated by staking our funds. In this case it's the CAKEs token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {cakeToWbnbRoute} - Route we take to get from {cake} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {cakeToLp0Route} - Route we take to get from {cake} into {lpToken0}.\n     * {cakeToLp1Route} - Route we take to get from {cake} into {lpToken1}.\n     */\n    address[] public cakeToWbnbRoute = [cake, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public cakeToLp0Route;\n    address[] public cakeToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 != cake) {\n            cakeToLp0Route = [cake, lpToken0];\n        }\n\n        if (lpToken1 != cake) {\n            cakeToLp1Route = [cake, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(cake).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {cake}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {cake} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(cake).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {cake} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 cakeHalf = IERC20(cake).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(cake).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(cake).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakeBusdLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCakeBusdLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n    uint256 public poolId;\n\n    // Routes\n    address[] public cakeToWbnbRoute = [cake, wbnb];\n    address[] public cakeToLp0Route;\n    address[] public cakeToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == busd) {\n            cakeToLp0Route = [cake, busd];\n        } else if (lpToken0 != cake) {\n            cakeToLp0Route = [cake, busd, lpToken0];\n        }\n\n        if (lpToken1 == busd) {\n            cakeToLp1Route = [cake, busd];\n        } else if (lpToken1 != cake) {\n            cakeToLp1Route = [cake, busd, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(cake).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 cakeHalf = IERC20(cake).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(cake).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(cake).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakeBtcLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCakeBtcLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public btcb = address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n    uint256 public poolId;\n\n    // Routes\n    address[] public cakeToWbnbRoute = [cake, wbnb];\n    address[] public cakeToLp0Route;\n    address[] public cakeToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == btcb) {\n            cakeToLp0Route = [cake, wbnb, btcb];\n        } else if (lpToken0 != cake) {\n            cakeToLp0Route = [cake, wbnb, btcb, lpToken0];\n        }\n\n        if (lpToken1 == btcb) {\n            cakeToLp1Route = [cake, wbnb, btcb];\n        } else if (lpToken1 != cake) {\n            cakeToLp1Route = [cake, wbnb, btcb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(cake).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, cakeToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 cakeHalf = IERC20(cake).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != cake) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeHalf, 0, cakeToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(cake).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(cake).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Auto/StrategyAutoCake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/auto/IAutoFarmV2.sol\";\nimport \"../../interfaces/auto/IStratX.sol\";\nimport \"../../interfaces/pancake/IMasterChef.sol\";\n\n/**\n * @dev Strategy to farm Cake through AutoFarm contract.\n */\ncontract StrategyAutoCake is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {Auto} - Token generated by staking our funds. In this case it's the AUTO token.\n     * {want} - Token that the strategy maximizes.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public Auto = address(0xa184088a740c695E156F91f5cC086a06bb78b827);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {autofarm} - AutoFarm contract\n     * {masterchef} - PancakeSwap MasterChef contract\n     * {autostrat} - AutoFarm underlying strategy contract\n     * {poolId} - AutoFarm pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public autofarm = address(0x0895196562C7868C5Be92459FaE7f877ED450452);\n    address constant public masterchef = address(0x73feaa1eE314F8c655E354234017bE2193C9E24E);\n    address public autostrat;\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {autoToWbnbRoute} - Route we take to go from {auto} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {autoToWantRoute} - Route we take to go from {auto} into {want}.\n     */\n    address[] public autoToWbnbRoute = [Auto, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public autoToWantRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _want, uint8 _poolId, address _vault, address _strategist) {\n        want = _want;\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        (, , , , address _autostrat) = IAutoFarmV2(autofarm).poolInfo(poolId);\n        autostrat = _autostrat;\n\n        if (want == wbnb) {\n            autoToWantRoute = [Auto, wbnb];\n        } else {\n            autoToWantRoute = [Auto, wbnb, want];\n        }\n\n        IERC20(want).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the AutoFarm to earn rewards in {auto}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IAutoFarmV2(autofarm).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It redeposits harvested and pending cakes in AutoFarm strategy via farm()\n     * It withdraws {want} from the AutoFarm.\n     * The available {want} is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        IStratX(autostrat).farm();\n        IStratX(autostrat).farm();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IAutoFarmV2(autofarm).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        IERC20(want).safeTransfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the AutoFarm\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IAutoFarmV2(autofarm).deposit(poolId, 0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(Auto).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, autoToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {auto} rewards earned for more {want}.\n     */\n    function swapRewards() internal {\n        uint256 autoBal = IERC20(Auto).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(autoBal, 0, autoToWantRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in AutoFarm.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool()).add(balanceOfPoolPending());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the AutoFarm\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IAutoFarmV2(autofarm).stakedWantTokens(poolId, address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has on the AutoFarm balance not staked yet\n     */\n    function balanceOfPoolPending() public view returns (uint256) {\n        (uint256 shares,) = IAutoFarmV2(autofarm).userInfo(poolId, address(this));\n        uint256 totalShares = IStratX(autostrat).sharesTotal();\n\n        uint256 wantBalInAuto = IERC20(want).balanceOf(autostrat);\n        uint256 harvestedBal = wantBalInAuto.mul(shares).div(totalShares);\n\n        uint256 wantPendingInPCS = IMasterChef(masterchef).pendingCake(0, autostrat);\n        uint256 pendingBal = wantPendingInPCS.mul(shares).div(totalShares);\n\n        return harvestedBal.add(pendingBal);\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(autofarm, 0);\n        IERC20(Auto).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/auto/IAutoFarmV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IAutoFarmV2 {\n    function poolInfo(uint256 _pid) external view returns (address, uint256, uint256, uint256, address);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function pendingAUTO(uint256 _pid, address _user) external view returns (uint256);\n    function stakedWantTokens(uint256 _pid, address _user) external view returns (uint256);\n    function deposit(uint256 _pid, uint256 _wantAmt) external;\n    function withdraw(uint256 _pid, uint256 _wantAmt) external;\n    function withdrawAll(uint256 _pid) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/interfaces/auto/IStratX.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IStratX {\n    function sharesTotal() external view returns(uint256);\n    function farm() external;\n}"
    },
    "contracts/BIFI/strategies/Pumpy/StrategyPumpyCakeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/auto/IAutoFarmV2.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming PancakeSwap LP Pools in Pumpy.\n */\ncontract StrategyPumpyCakeLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, eth, beth} - Required for liquidity routing when doing swaps.\n     * {pmp} - Token generated by staking our funds. In this case it's the PMP token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public eth  = address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\n    address constant public beth = address(0x250632378E573c6Be1AC2f97Fcdf00515d0Aa91B);\n    address constant public pmp  = address(0x8d4FBB3AC63bf33851dCE80D63613Df1A515BC00);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {pumpyfarm} - PumpyFarm contract\n     * {poolId} - PumpyFarm pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public pumpyfarm  = address(0x29142471a5c33a2a4cD7C8f18Ce881F699b0c681);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {pmpToWbnbRoute} - Route we take to go from {pmp} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {pmpToLp0Route} - Route we take to get from {pmp} into {lpToken0}.\n     * {pmpToLp1Route} - Route we take to get from {pmp} into {lpToken1}.\n     */\n    address[] public pmpToWbnbRoute = [pmp, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public pmpToLp0Route;\n    address[] public pmpToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            pmpToLp0Route = [pmp, wbnb];\n        } else if (lpToken0 == beth) {\n            pmpToLp0Route = [pmp, wbnb, eth, beth];\n        } else if (lpToken0 != pmp) {\n            pmpToLp0Route = [pmp, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            pmpToLp1Route = [pmp, wbnb];\n        } else if (lpToken1 == beth) {\n            pmpToLp1Route = [pmp, wbnb, eth, beth];\n        } else if (lpToken1 != pmp) {\n            pmpToLp1Route = [pmp, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(pumpyfarm, type(uint).max);\n        IERC20(pmp).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the PumpyFarm to earn rewards in {pmp}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IAutoFarmV2(pumpyfarm).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the PumpyFarm.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IAutoFarmV2(pumpyfarm).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the PumpyFarm\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IAutoFarmV2(pumpyfarm).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(pmp).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, pmpToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {pmp} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 pmpHalf = IERC20(pmp).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != pmp) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(pmpHalf, 0, pmpToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != pmp) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(pmpHalf, 0, pmpToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize PumpyFarm balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying Pumpy strategy doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in PumpyFarm.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the PumpyFarm\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IAutoFarmV2(pumpyfarm).stakedWantTokens(poolId, address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IAutoFarmV2(pumpyfarm).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IAutoFarmV2(pumpyfarm).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(pumpyfarm, 0);\n        IERC20(pmp).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(pumpyfarm, type(uint).max);\n        IERC20(pmp).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyTenfiLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/auto/IAutoFarmV2.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyTenfiLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0xd15C444F1199Ae72795eba15E8C1db44E47abF62);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x264A1b3F6db28De4D3dD4eD23Ab31A468B0C1A96);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb || lpToken0 == busd) {\n            outputToLp0Route = [output, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb || lpToken1 == busd) {\n            outputToLp1Route = [output, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IAutoFarmV2(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IAutoFarmV2(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IAutoFarmV2(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IAutoFarmV2(masterchef).stakedWantTokens(poolId, address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IAutoFarmV2(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IAutoFarmV2(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Auto/StrategyAutoVenus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/auto/IAutoFarmV2.sol\";\nimport \"../../interfaces/auto/IStratVLEV.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Strategy to farm single tokens through AutoFarm contract.\n */\ncontract StrategyAutoVenus is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {Auto} - Token generated by staking our funds. In this case it's the AUTO token.\n     * {want} - Token that the strategy maximizes.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public Auto = address(0xa184088a740c695E156F91f5cC086a06bb78b827);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {autofarm} - AutoFarm contract\n     * {autostrat} - AutoFarm underlying strategy contract\n     * {poolId} - AutoFarm pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public autofarm = address(0x0895196562C7868C5Be92459FaE7f877ED450452);\n    address public autostrat;\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {autoToWbnbRoute} - Route we take to go from {auto} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {autoToWantRoute} - Route we take to go from {auto} into {want}.\n     */\n    address[] public autoToWbnbRoute = [Auto, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public autoToWantRoute;\n\n    /**\n     * @dev If rewards are locked in AutoFarm, retire() will use emergencyWithdraw.\n     */\n    bool public rewardsLocked = false;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _want, uint8 _poolId, address _vault, address _strategist) {\n        want = _want;\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        (, , , , address _autostrat) = IAutoFarmV2(autofarm).poolInfo(poolId);\n        autostrat = _autostrat;\n\n        if (want == wbnb) {\n            autoToWantRoute = [Auto, wbnb];\n        } else {\n            autoToWantRoute = [Auto, wbnb, want];\n        }\n\n        IERC20(want).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the AutoFarm to earn rewards in {auto}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IAutoFarmV2(autofarm).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It redeposits harvested and pending cakes in AutoFarm strategy via farm()\n     * It withdraws {want} from the AutoFarm.\n     * The available {want} is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IAutoFarmV2(autofarm).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        IERC20(want).safeTransfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the AutoFarm\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IAutoFarmV2(autofarm).deposit(poolId, 0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(Auto).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, autoToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {auto} rewards earned for more {want}.\n     */\n    function swapRewards() internal {\n        uint256 autoBal = IERC20(Auto).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(autoBal, 0, autoToWantRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize AutoFarm balance of {want}.\n     * It should be called by the vault before minting shares.\n     */\n    function updateBalance() public {\n        IStratVLEV(autostrat).updateBalance();\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in AutoFarm.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the AutoFarm\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IAutoFarmV2(autofarm).stakedWantTokens(poolId, address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n        if (rewardsLocked) {\n            _retireStratEmergency();\n        } else {\n            _retireStrat();\n        }\n    }\n\n    function setRewardsLocked(bool _rewardsLocked) external onlyOwner {\n        rewardsLocked = _rewardsLocked;\n    }\n\n    function _retireStrat() internal {\n        IAutoFarmV2(autofarm).withdraw(poolId, type(uint).max);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    function _retireStratEmergency() internal {\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IAutoFarmV2(autofarm).withdraw(poolId, type(uint).max);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panicEmergency() public onlyOwner {\n        pause();\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(autofarm, 0);\n        IERC20(Auto).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/auto/IStratVLEV.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IStratVLEV {\n    function updateBalance() external;\n}"
    },
    "contracts/BIFI/strategies/Auto/StrategyAutoCakeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/auto/IAutoFarmV2.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming PancakeSwap LP Pools in AutoFarm.\n */\ncontract StrategyAutoCakeLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, eth, beth} - Required for liquidity routing when doing swaps.\n     * {Auto} - Token generated by staking our funds. In this case it's the AUTO token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public eth  = address(0x2170Ed0880ac9A755fd29B2688956BD959F933F8);\n    address constant public beth = address(0x250632378E573c6Be1AC2f97Fcdf00515d0Aa91B);\n    address constant public Auto = address(0xa184088a740c695E156F91f5cC086a06bb78b827);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {autofarm} - AutoFarm contract\n     * {poolId} - AutoFarm pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public autofarm = address(0x0895196562C7868C5Be92459FaE7f877ED450452);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {autoToWbnbRoute} - Route we take to go from {auto} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {autoToLp0Route} - Route we take to get from {auto} into {lpToken0}.\n     * {autoToLp1Route} - Route we take to get from {auto} into {lpToken1}.\n     */\n    address[] public autoToWbnbRoute = [Auto, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public autoToLp0Route;\n    address[] public autoToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            autoToLp0Route = [Auto, wbnb];\n        } else if (lpToken0 == beth) {\n            autoToLp0Route = [Auto, wbnb, eth, beth];\n        } else if (lpToken0 != Auto) {\n            autoToLp0Route = [Auto, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            autoToLp1Route = [Auto, wbnb];\n        } else if (lpToken1 == beth) {\n            autoToLp1Route = [Auto, wbnb, eth, beth];\n        } else if (lpToken1 != Auto) {\n            autoToLp1Route = [Auto, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the AutoFarm to earn rewards in {auto}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IAutoFarmV2(autofarm).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the AutoFarm.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IAutoFarmV2(autofarm).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the AutoFarm\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IAutoFarmV2(autofarm).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(Auto).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, autoToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {auto} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 autoHalf = IERC20(Auto).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != Auto) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(autoHalf, 0, autoToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != Auto) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(autoHalf, 0, autoToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize AutoFarm balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying Auto strategy doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in AutoFarm.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the AutoFarm\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IAutoFarmV2(autofarm).stakedWantTokens(poolId, address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(autofarm, 0);\n        IERC20(Auto).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Auto/StrategyAutoBeltToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/auto/IAutoFarmV2.sol\";\nimport \"../../interfaces/belt/IBeltToken.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyAutoBeltToken is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public Auto = address(0xa184088a740c695E156F91f5cC086a06bb78b827);\n    address public want;\n    address public wantToken;\n\n    // Third party contracts\n    address constant public autofarm = address(0x0895196562C7868C5Be92459FaE7f877ED450452);\n    uint256 public poolId;\n\n    // Routes\n    address[] public AutoToWbnbRoute = [Auto, wbnb];\n    address[] public AutoToWantTokenRoute;\n\n    /**\n     * @dev If rewards are locked in AutoFarm, retire() will use emergencyWithdraw.\n     */\n    bool public rewardsLocked = false;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        wantToken = IBeltToken(want).token();\n        poolId = _poolId;\n\n        if (wantToken == wbnb) {\n            AutoToWantTokenRoute = [Auto, wbnb];\n        } else {\n            AutoToWantTokenRoute = [Auto, wbnb, wantToken];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IAutoFarmV2(autofarm).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IAutoFarmV2(autofarm).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IAutoFarmV2(autofarm).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(Auto).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, AutoToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 autoBal = IERC20(Auto).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(autoBal, 0, AutoToWantTokenRoute, address(this), block.timestamp);\n\n        uint256 wantTokenBal = IERC20(wantToken).balanceOf(address(this));\n        IBeltToken(want).deposit(wantTokenBal, 0);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IAutoFarmV2(autofarm).stakedWantTokens(poolId, address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n        if (rewardsLocked) {\n            _retireStratEmergency();\n        } else {\n            _retireStrat();\n        }\n    }\n\n    function setRewardsLocked(bool _rewardsLocked) external onlyOwner {\n        rewardsLocked = _rewardsLocked;\n    }\n\n    function _retireStrat() internal {\n        IAutoFarmV2(autofarm).withdraw(poolId, type(uint).max);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    function _retireStratEmergency() internal {\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IAutoFarmV2(autofarm).withdraw(poolId, type(uint).max);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panicEmergency() public onlyManager {\n        pause();\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(wantToken).safeApprove(want, type(uint).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(autofarm, 0);\n        IERC20(Auto).safeApprove(unirouter, 0);\n        IERC20(wantToken).safeApprove(want, 0);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/belt/IBeltToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBeltToken {\n    function token() external view returns (address);\n    function deposit(uint256 amount, uint256 min_mint_amount) external;\n}"
    },
    "contracts/BIFI/strategies/Belt/StrategyBeltToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/belt/IMasterBelt.sol\";\nimport \"../../interfaces/belt/IBeltToken.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyBeltToken is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public belt = address(0xE0e514c71282b6f4e823703a39374Cf58dc3eA4f);\n    address public want;\n    address public wantToken;\n\n    // Third party contracts\n    address constant public masterbelt = address(0xD4BbC80b9B102b77B21A06cb77E954049605E6c1);\n    uint256 public poolId;\n\n    // Routes\n    address[] public beltToWbnbRoute = [belt, wbnb];\n    address[] public beltToWantTokenRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        wantToken = IBeltToken(want).token();\n        poolId = _poolId;\n\n        if (wantToken == wbnb) {\n            beltToWantTokenRoute = [belt, wbnb];\n        } else {\n            beltToWantTokenRoute = [belt, wbnb, wantToken];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterBelt(masterbelt).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterBelt(masterbelt).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterBelt(masterbelt).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(belt).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, beltToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 beltBal = IERC20(belt).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(beltBal, 0, beltToWantTokenRoute, address(this), block.timestamp);\n\n        uint256 wantTokenBal = IERC20(wantToken).balanceOf(address(this));\n        IBeltToken(want).deposit(wantTokenBal, 0);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IMasterBelt(masterbelt).stakedWantTokens(poolId, address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterBelt(masterbelt).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterBelt(masterbelt).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterbelt, type(uint).max);\n        IERC20(belt).safeApprove(unirouter, type(uint).max);\n        IERC20(wantToken).safeApprove(want, type(uint).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterbelt, 0);\n        IERC20(belt).safeApprove(unirouter, 0);\n        IERC20(wantToken).safeApprove(want, 0);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/belt/IMasterBelt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMasterBelt {\n    function poolInfo(uint256 _pid) external view returns (address, uint256, uint256, uint256, address);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function pendingBELT(uint256 _pid, address _user) external view returns (uint256);\n    function stakedWantTokens(uint256 _pid, address _user) external view returns (uint256);\n    function deposit(uint256 _pid, uint256 _wantAmt) external;\n    function withdraw(uint256 _pid, uint256 _wantAmt) external;\n    function withdrawAll(uint256 _pid) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Belt/StrategyBeltVenusBLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/belt/IMasterBelt.sol\";\nimport \"../../interfaces/belt/IBeltLP.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming Venus BLP on Belt.\n */\ncontract StrategyBeltVenusBLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {belt} - Token generated by staking our funds. In this case it's the BELT token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. bDAI+bUSDC+bUSDT+bBUSD\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public belt = address(0xE0e514c71282b6f4e823703a39374Cf58dc3eA4f);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public want = address(0x86aFa7ff694Ab8C985b79733745662760e454169);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterbelt} - MasterBelt contract\n     * {beltLP} - BeltLP contract, to deposit and withdraw bDAI+bUSDC+bUSDT+bBUSD\n     * {poolId} - MasterBelt pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterbelt = address(0xD4BbC80b9B102b77B21A06cb77E954049605E6c1);\n    address constant public beltLP     = address(0xf157A4799bE445e3808592eDd7E7f72150a7B050);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {beltToWbnbRoute} - Route we take to go from {belt} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {beltToBusdRoute} - Route we take to get from {belt} into {busd}.\n     */\n    address[] public beltToWbnbRoute = [belt, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public beltToBusdRoute = [belt, wbnb, busd];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(uint8 _poolId, address _vault, address _strategist) {\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(masterbelt, type(uint).max);\n        IERC20(belt).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(beltLP, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the MasterBelt to earn rewards in {belt}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterBelt(masterbelt).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {want} from the MasterBelt.\n     * The available {want} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterBelt(masterbelt).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterBelt\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterBelt(masterbelt).deposit(poolId, 0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(belt).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, beltToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {belt} rewards earned for {busd} and adds to VenusBeltLP.\n     */\n    function swapRewards() internal {\n        uint256 beltBal = IERC20(belt).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(beltBal, 0, beltToBusdRoute, address(this), block.timestamp.add(600));\n\n        uint256 busdBal = IERC20(busd).balanceOf(address(this));\n        uint256[4] memory uamounts = [0, 0, 0, busdBal];\n        IBeltLP(beltLP).add_liquidity(uamounts, 0);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in AutoFarm.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the MasterBelt\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IMasterBelt(masterbelt).stakedWantTokens(poolId, address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterBelt(masterbelt).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterBelt, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterBelt(masterbelt).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(masterbelt, uint(0));\n        IERC20(belt).safeApprove(unirouter, uint(0));\n        IERC20(wbnb).safeApprove(unirouter, uint(0));\n        IERC20(busd).safeApprove(beltLP, uint(0));\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(masterbelt, type(uint).max);\n        IERC20(belt).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(beltLP, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/belt/IBeltLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBeltLP {\n    function add_liquidity(uint256[4] memory uamounts, uint256 min_mint_amount) external;\n}"
    },
    "contracts/BIFI/strategies/Auto/StrategyAuto4Belt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/auto/IAutoFarmV2.sol\";\nimport \"../../interfaces/belt/IBeltLP.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyAuto4Belt is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public Auto = address(0xa184088a740c695E156F91f5cC086a06bb78b827);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public want = address(0x9cb73F20164e399958261c289Eb5F9846f4D1404);\n\n    // Third party contracts\n    address constant public autofarm = address(0x0895196562C7868C5Be92459FaE7f877ED450452);\n    address constant public beltLP   = address(0xF6e65B33370Ee6A49eB0dbCaA9f43839C1AC04d5);\n    uint256 constant public poolId = 341;\n\n    // Routes\n    address[] public AutoToWbnbRoute = [Auto, wbnb];\n    address[] public AutoToBusdRoute = [Auto, wbnb, busd];\n\n    /**\n     * @dev If rewards are locked in AutoFarm, retire() will use emergencyWithdraw.\n     */\n    bool public rewardsLocked = false;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IAutoFarmV2(autofarm).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IAutoFarmV2(autofarm).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IAutoFarmV2(autofarm).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(Auto).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, AutoToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 autoBal = IERC20(Auto).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(autoBal, 0, AutoToBusdRoute, address(this), block.timestamp);\n\n        uint256 busdBal = IERC20(busd).balanceOf(address(this));\n        uint256[4] memory uamounts = [0, 0, 0, busdBal];\n        IBeltLP(beltLP).add_liquidity(uamounts, 0);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IAutoFarmV2(autofarm).stakedWantTokens(poolId, address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n        if (rewardsLocked) {\n            _retireStratEmergency();\n        } else {\n            _retireStrat();\n        }\n    }\n\n    function setRewardsLocked(bool _rewardsLocked) external onlyOwner {\n        rewardsLocked = _rewardsLocked;\n    }\n\n    function _retireStrat() internal {\n        IAutoFarmV2(autofarm).withdraw(poolId, type(uint).max);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    function _retireStratEmergency() internal {\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IAutoFarmV2(autofarm).withdraw(poolId, type(uint).max);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panicEmergency() public onlyManager {\n        pause();\n        IAutoFarmV2(autofarm).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(autofarm, type(uint).max);\n        IERC20(Auto).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(beltLP, type(uint).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(autofarm, 0);\n        IERC20(Auto).safeApprove(unirouter, 0);\n        IERC20(busd).safeApprove(beltLP, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Belt/StrategyBeltCakeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/belt/IMasterBelt.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyBeltCakeLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public belt = address(0xE0e514c71282b6f4e823703a39374Cf58dc3eA4f);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterbelt = address(0xD4BbC80b9B102b77B21A06cb77E954049605E6c1);\n    uint256 public poolId;\n\n    // Routes\n    address[] public beltToWbnbRoute = [belt, wbnb];\n    address[] public beltToLp0Route;\n    address[] public beltToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            beltToLp0Route = [belt, wbnb];\n        } else if (lpToken0 != belt) {\n            beltToLp0Route = [belt, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            beltToLp1Route = [belt, wbnb];\n        } else if (lpToken1 != belt) {\n            beltToLp1Route = [belt, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterBelt(masterbelt).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterBelt(masterbelt).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterBelt(masterbelt).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(belt).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, beltToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 beltHalf = IERC20(belt).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != belt) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(beltHalf, 0, beltToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != belt) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(beltHalf, 0, beltToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IMasterBelt(masterbelt).stakedWantTokens(poolId, address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterBelt(masterbelt).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterBelt(masterbelt).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterbelt, type(uint256).max);\n        IERC20(belt).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterbelt, 0);\n        IERC20(belt).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Pangolin/StrategyPangolinLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouter.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/common/IRewardPool.sol\";\r\n\r\n/**\r\n * @dev Strategy to farm PNG through a Synthetix based rewards pool contract.\r\n */\r\ncontract StrategyPangolinLP is Ownable, Pausable {\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Tokens Used:\r\n     * {wavax} - Required for liquidity routing when doing swaps.\r\n     * {png} - Token generated by staking our funds. In this case it's the png token.\r\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\r\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\r\n     */\r\n    address constant public wavax = address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\r\n    address constant public png = address(0x60781C2586D68229fde47564546784ab3fACA982);\r\n    address public lpPair;\r\n    address public lpToken0;\r\n    address public lpToken1;\r\n\r\n    /**\r\n     * @dev Third Party Contracts:\r\n     * {pngrouter} - Pangolin router\r\n     * {rewardPool} - Reward Pool contract\r\n     */\r\n    address constant public pngrouter = address(0xE54Ca86531e17Ef3616d22Ca28b0D458b6C89106);\r\n    address public rewardPool;\r\n\r\n    /**\r\n     * @dev Beefy Contracts:\r\n     * {treasury} - Address of the Beefy treasury. Rewards accumulate here and are then sent to BSC.\r\n     * {vault} - Address of the vault that controls the strategy's funds.\r\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\r\n     */\r\n    address constant public treasury = address(0xA3e3Af161943CfB3941B631676134bb048739727);\r\n    address public vault;\r\n    address public strategist;\r\n\r\n    /**\r\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\r\n     * Current implementation separates 4.5% for fees.\r\n     *\r\n     * {TREASURY_FEE} - 3.75% goes to BIFI holders through the {treasury}.\r\n     * {CALL_FEE} - 0.25% goes to whoever executes the harvest function as gas subsidy.\r\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\r\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\r\n     *\r\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\r\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\r\n     */\r\n    uint constant public CALL_FEE       = 55;\r\n    uint constant public TREASURY_FEE   = 833;\r\n    uint constant public STRATEGIST_FEE = 112;\r\n    uint constant public MAX_FEE        = 1000;\r\n\r\n    uint constant public WITHDRAWAL_FEE = 10;\r\n    uint constant public WITHDRAWAL_MAX = 10000;\r\n\r\n    /**\r\n     * @dev Routes we take to swap tokens using Pangolin.\r\n     * {pngToWavaxRoute} - Route we take to get from {png} into {wbnb}.\r\n     * {pngToLp0Route} - Route we take to get from {png} into {lpToken0}.\r\n     * {pngToLp1Route} - Route we take to get from {png} into {lpToken1}.\r\n     */\r\n    address[] public pngToWavaxRoute = [png, wavax];\r\n    address[] public pngToLp0Route;\r\n    address[] public pngToLp1Route;\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    /**\r\n     * @dev Initializes the strategy with the token to maximize.\r\n     */\r\n    constructor(address _lpPair, address _rewardPool, address _vault, address _strategist) {\r\n        lpPair = _lpPair;\r\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\r\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\r\n        rewardPool = _rewardPool;\r\n        vault = _vault;\r\n        strategist = _strategist;\r\n\r\n        if (lpToken0 == wavax) {\r\n            pngToLp0Route = [png, wavax];\r\n        } else if (lpToken0 != png) {\r\n            pngToLp0Route = [png, wavax, lpToken0];\r\n        }\r\n\r\n        if (lpToken1 == wavax) {\r\n            pngToLp1Route = [png, wavax];\r\n        } else if (lpToken1 != png) {\r\n            pngToLp1Route = [png, wavax, lpToken1];\r\n        }\r\n\r\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\r\n        IERC20(png).safeApprove(pngrouter, type(uint).max);\r\n        IERC20(wavax).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken0).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken0).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken1).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken1).safeApprove(pngrouter, type(uint).max);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that puts the funds to work.\r\n     * It gets called whenever someone deposits in the strategy's vault contract.\r\n     * It deposits {lpPair} in the Reward Pool to farm {png}\r\n     */\r\n    function deposit() public whenNotPaused {\r\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\r\n\r\n        if (pairBal > 0) {\r\n            IRewardPool(rewardPool).stake(pairBal);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws funds and sents them back to the vault.\r\n     * It withdraws {lpPair} from the Reward Pool.\r\n     * The available {lpPair} minus fees is returned to the vault.\r\n     */\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\r\n\r\n        if (pairBal < _amount) {\r\n            IRewardPool(rewardPool).withdraw(_amount.sub(pairBal));\r\n            pairBal = IERC20(lpPair).balanceOf(address(this));\r\n        }\r\n\r\n        if (pairBal > _amount) {\r\n            pairBal = _amount;\r\n        }\r\n\r\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\r\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\r\n     * 1. It claims rewards from the Reward Pool.\r\n     * 2. It charges the system fees to simplify the split.\r\n     * 3. It swaps the {png} token for {lpToken0} & {lpToken1}\r\n     * 4. Adds more liquidity to the pool.\r\n     * 5. It deposits the new LP tokens.\r\n     */\r\n    function harvest() external whenNotPaused {\r\n        require(!Address.isContract(msg.sender), \"!contract\");\r\n        IRewardPool(rewardPool).getReward();\r\n        chargeFees();\r\n        addLiquidity();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Takes out 4.5% as system fees from the rewards.\r\n     * 0.5% -> Call Fee\r\n     * 0.5% -> Treasury fee\r\n     * 0.5% -> Strategist fee\r\n     * 3.0% -> BIFI Holders\r\n     */\r\n    function chargeFees() internal {\r\n        uint256 toWavax = IERC20(png).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouter(pngrouter).swapExactTokensForTokens(toWavax, 0, pngToWavaxRoute, address(this), block.timestamp.add(600));\r\n\r\n        uint256 wavaxBal = IERC20(wavax).balanceOf(address(this));\r\n\r\n        uint256 treasuryFee = wavaxBal.mul(TREASURY_FEE).div(MAX_FEE);\r\n        IERC20(wavax).safeTransfer(treasury, treasuryFee);\r\n\r\n        uint256 callFee = wavaxBal.mul(CALL_FEE).div(MAX_FEE);\r\n        IERC20(wavax).safeTransfer(msg.sender, callFee);\r\n\r\n        uint256 strategistFee = wavaxBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(wavax).safeTransfer(strategist, strategistFee);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Swaps {png} for {lpToken0}, {lpToken1} & {wavax} using Pangolin.\r\n     */\r\n    function addLiquidity() internal {\r\n        uint256 pngHalf = IERC20(png).balanceOf(address(this)).div(2);\r\n\r\n        if (lpToken0 != png) {\r\n            IUniswapRouter(pngrouter).swapExactTokensForTokens(pngHalf, 0, pngToLp0Route, address(this), block.timestamp.add(600));\r\n        }\r\n\r\n        if (lpToken1 != png) {\r\n            IUniswapRouter(pngrouter).swapExactTokensForTokens(pngHalf, 0, pngToLp1Route, address(this), block.timestamp.add(600));\r\n        }\r\n\r\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\r\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\r\n        IUniswapRouter(pngrouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\r\n    }\r\n\r\n    /**\r\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\r\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\r\n     */\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfLpPair().add(balanceOfPool());\r\n    }\r\n\r\n    /**\r\n     * @dev It calculates how much {lpPair} the contract holds.\r\n     */\r\n    function balanceOfLpPair() public view returns (uint256) {\r\n        return IERC20(lpPair).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev It calculates how much {lpPair} the strategy has allocated in the Reward Pool\r\n     */\r\n    function balanceOfPool() public view returns (uint256) {\r\n        return IRewardPool(rewardPool).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\r\n     * vault, ready to be migrated to the new strat.\r\n     */\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n\r\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\r\n        IERC20(lpPair).transfer(vault, pairBal);\r\n    }\r\n\r\n    /**\r\n     * @dev Pauses deposits. Withdraws all funds from the Reward Pool, leaving rewards behind\r\n     */\r\n    function panic() public onlyOwner {\r\n        pause();\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n    }\r\n\r\n    /**\r\n     * @dev Pauses the strat.\r\n     */\r\n    function pause() public onlyOwner {\r\n        _pause();\r\n\r\n        IERC20(lpPair).safeApprove(rewardPool, 0);\r\n        IERC20(png).safeApprove(pngrouter, 0);\r\n        IERC20(wavax).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken0).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken1).safeApprove(pngrouter, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses the strat.\r\n     */\r\n    function unpause() external onlyOwner {\r\n        _unpause();\r\n\r\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\r\n        IERC20(png).safeApprove(pngrouter, type(uint).max);\r\n        IERC20(wavax).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken0).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken0).safeApprove(pngrouter, type(uint).max);\r\n\r\n        IERC20(lpToken1).safeApprove(pngrouter, 0);\r\n        IERC20(lpToken1).safeApprove(pngrouter, type(uint).max);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates address where strategist fee earnings will go.\r\n     * @param _strategist new strategist address.\r\n     */\r\n    function setStrategist(address _strategist) external {\r\n        require(msg.sender == strategist, \"!strategist\");\r\n        strategist = _strategist;\r\n    }\r\n}\r\n"
    },
    "contracts/BIFI/interfaces/common/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IRewardPool {\n    function deposit(uint256 amount) external;\n    function stake(uint256 amount) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/BIFI/strategies/QuickSwap/StrategyRewardPoolPolygonETHLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\n\ncontract StrategyRewardPoolPolygonETHLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    address constant public matic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public output = address(0x831753DD7087CaC61aB5644b308642cc1c33Dc13);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address public rewardPool;\n\n    // Routes\n    address[] public outputToMaticRoute = [output, matic];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        rewardPool = _rewardPool;\n\n        if (lpToken0 == matic) {\n            outputToLp0Route = [output, matic];\n        } else if (lpToken0 == eth) {\n            outputToLp0Route = [output, eth];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, eth, lpToken0];\n        }\n\n        if (lpToken1 == matic) {\n            outputToLp1Route = [output, matic];\n        } else if (lpToken1 == eth) {\n            outputToLp1Route = [output, eth];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, eth, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IRewardPool(rewardPool).stake(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toMatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toMatic, 0, outputToMaticRoute, address(this), block.timestamp);\n\n        uint256 maticBal = IERC20(matic).balanceOf(address(this));\n\n        uint256 callFeeAmount = maticBal.mul(callFee).div(MAX_FEE);\n        IERC20(matic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = maticBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(matic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = maticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(matic).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/QuickSwap/StrategyPolygonQuickLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/common/IRewardPool.sol\";\r\nimport \"../Common/StratManager.sol\";\r\nimport \"../Common/FeeManager.sol\";\r\n\r\n\r\ncontract StrategyRewardPoolPolygonQuickLP is StratManager, FeeManager {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\r\n    address constant public matic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\r\n    address constant public output = address(0x831753DD7087CaC61aB5644b308642cc1c33Dc13);\r\n    address public want;\r\n    address public lpToken0;\r\n    address public lpToken1;\r\n\r\n    // Third party contracts\r\n    address public rewardPool;\r\n\r\n    // Routes\r\n    address[] public outputToMaticRoute = [output, matic];\r\n    address[] public outputToLp0Route;\r\n    address[] public outputToLp1Route;\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    constructor(\r\n        address _want,\r\n        address _rewardPool,\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _strategist,\r\n        address _beefyFeeRecipient\r\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\r\n        want = _want;\r\n        lpToken0 = IUniswapV2Pair(want).token0();\r\n        lpToken1 = IUniswapV2Pair(want).token1();\r\n        rewardPool = _rewardPool;\r\n\r\n        if (lpToken0 == matic) {\r\n            outputToLp0Route = [output, matic];\r\n        } else if (lpToken0 == eth) {\r\n            outputToLp0Route = [output, eth];\r\n        } else if (lpToken0 != output) {\r\n            outputToLp0Route = [output, lpToken0];\r\n        }\r\n\r\n        if (lpToken1 == matic) {\r\n            outputToLp1Route = [output, matic];\r\n        } else if (lpToken1 == eth) {\r\n            outputToLp1Route = [output, eth];\r\n        } else if (lpToken1 != output) {\r\n            outputToLp1Route = [output, lpToken1];\r\n        }\r\n\r\n        _giveAllowances();\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal > 0) {\r\n            IRewardPool(rewardPool).stake(wantBal);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal < _amount) {\r\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n        if (tx.origin == owner() || paused()) {\r\n            IERC20(want).safeTransfer(vault, wantBal);\r\n        } else {\r\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\r\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\r\n        }\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() external whenNotPaused onlyEOA {\r\n        IRewardPool(rewardPool).getReward();\r\n        chargeFees();\r\n        addLiquidity();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toMatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toMatic, 0, outputToMaticRoute, address(this), block.timestamp);\r\n\r\n        uint256 maticBal = IERC20(matic).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = maticBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(msg.sender, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = maticBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n\r\n        uint256 strategistFee = maticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(strategist, strategistFee);\r\n    }\r\n\r\n    // Adds liquidity to AMM and gets more LP tokens.\r\n    function addLiquidity() internal {\r\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\r\n\r\n        if (lpToken0 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\r\n        }\r\n\r\n        if (lpToken1 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\r\n        }\r\n\r\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\r\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\r\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\r\n    }\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool());\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // it calculates how much 'want' the strategy has working in the farm.\r\n    function balanceOfPool() public view returns (uint256) {\r\n        return IRewardPool(rewardPool).balanceOf(address(this));\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        pause();\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\r\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(rewardPool, 0);\r\n        IERC20(output).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/BIFI/strategies/JulSwap/StrategyJulSwapLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\n\n/**\n * @dev Strategy to farm JulD through a Synthetix based rewards pool contract.\n */\ncontract StrategyJulSwapLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {juld} - Token generated by staking our funds. In this case it's the JulD token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public juld = address(0x5A41F637C3f7553dBa6dDC2D3cA92641096577ea);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {julrouter} - JulSwap router\n     * {rewardPool} - Reward Pool contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public julrouter = address(0xbd67d157502A23309Db761c41965600c2Ec788b2);\n    address public rewardPool;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {juldToWbnbRoute} - Route we take to get from {juld} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {juldToLp0Route} - Route we take to get from {juld} into {lpToken0}.\n     * {juldToLp1Route} - Route we take to get from {juld} into {lpToken1}.\n     */\n    address[] public juldToWbnbRoute = [juld, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public juldToLp0Route;\n    address[] public juldToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, address _rewardPool, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        rewardPool = _rewardPool;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            juldToLp0Route = [juld, wbnb];\n        } else if (lpToken0 != juld) {\n            juldToLp0Route = [juld, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            juldToLp1Route = [juld, wbnb];\n        } else if (lpToken1 != juld) {\n            juldToLp1Route = [juld, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(juld).safeApprove(julrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(julrouter, 0);\n        IERC20(lpToken0).safeApprove(julrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(julrouter, 0);\n        IERC20(lpToken1).safeApprove(julrouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the Reward Pool to farm {juld}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IRewardPool(rewardPool).stake(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the Reward Pool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Reward Pool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {juld} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(juld).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(julrouter).swapExactTokensForTokens(toWbnb, 0, juldToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {juld} for {lpToken0}, {lpToken1} & {wbnb} using JulSwap.\n     */\n    function addLiquidity() internal {\n        uint256 juldHalf = IERC20(juld).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != juld) {\n            IUniswapRouter(julrouter).swapExactTokensForTokens(juldHalf, 0, juldToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != juld) {\n            IUniswapRouter(julrouter).swapExactTokensForTokens(juldHalf, 0, juldToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(julrouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the Reward Pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Reward Pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(rewardPool, 0);\n        IERC20(juld).safeApprove(julrouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(julrouter, 0);\n        IERC20(lpToken1).safeApprove(julrouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(juld).safeApprove(julrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(julrouter, 0);\n        IERC20(lpToken0).safeApprove(julrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(julrouter, 0);\n        IERC20(lpToken1).safeApprove(julrouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/JulSwap/StrategyJulD.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\n\n/**\n * @dev Strategy to farm JulD through a Synthetix based rewards pool contract.\n */\ncontract StrategyJulD is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing and to pay out fees.\n     * {juld} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public juld = address(0x5A41F637C3f7553dBa6dDC2D3cA92641096577ea);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter to swap from {wbnb} into {bifi}\n     * {julrouter} - JulSwap router to swap from {juld} into {wbnb}\n     * {rewardPool} - Reward pool contract. Stake {juld}, get {juld}.\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public julrouter  = address(0xbd67d157502A23309Db761c41965600c2Ec788b2);\n    address constant public rewardPool = address(0xc08fa1D120e83e13b28d77BE3B2837bC3e07127F);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 667;\n    uint constant public CALL_FEE     = 111;\n    uint constant public TREASURY_FEE = 111;\n    uint constant public STRATEGIST_FEE = 111;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens JulSwap and PancakeSwap.\n     * {juldToWbnbRoute} - Route we take to go from {juld} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public juldToWbnbRoute = [juld, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(juld).safeApprove(rewardPool, type(uint256).max);\n        IERC20(juld).safeApprove(julrouter, type(uint256).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint256).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {juld} in the reward pool to earn {juld}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 juldBal = IERC20(juld).balanceOf(address(this));\n\n        if (juldBal > 0) {\n            IRewardPool(rewardPool).stake(juldBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws {juld} from the reward pool and sends it to the vault.\n     * @param _amount How much {juld} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 juldBal = IERC20(juld).balanceOf(address(this));\n\n        if (juldBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(juldBal));\n            juldBal = IERC20(juld).balanceOf(address(this));\n        }\n\n        if (juldBal > _amount) {\n            juldBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(juld).safeTransfer(vault, juldBal);\n        } else {\n            uint256 withdrawalFee = juldBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(juld).safeTransfer(vault, juldBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev In charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the IRewardPool.\n     * 3. It charges and distributes system fees.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        deposit();\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 3.0% -> BIFI Holders\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist Fee\n     * 0.5% -> Call Fee\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(juld).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(julrouter).swapExactTokensForTokens(toWbnb, 0, juldToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {juld} held by the strat.\n     * It takes into account both the funds at hand, and the funds allocated in the reward pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfJuld().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {juld} the contract holds.\n     */\n    function balanceOfJuld() public view returns (uint256) {\n        return IERC20(juld).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {juld} the strategy has allocated in the reward pool.\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 juldBal = IERC20(juld).balanceOf(address(this));\n        IERC20(juld).transfer(vault, juldBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the reward pool, leaving rewards behind\n     */\n    function panic() external onlyOwner {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(juld).safeApprove(rewardPool, 0);\n        IERC20(juld).safeApprove(julrouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(juld).safeApprove(rewardPool, type(uint256).max);\n        IERC20(juld).safeApprove(julrouter, type(uint256).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint256).max);\n\n        deposit();\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Icarus/StrategyIcarusLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyIcarusLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x95111f630aC215Eb74599ED42C67E2c2790d69e2);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address public rewardPool;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, busd, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        rewardPool = _rewardPool;\n\n        if (lpToken0 != output) {\n            outputToLp0Route = [output, lpToken0];\n        }\n\n        if (lpToken1 != output) {\n            outputToLp1Route = [output, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IRewardPool(rewardPool).stake(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Elk/StrategyRewardPoolElkLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyRewardPoolElkLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public matic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public output = address(0xE1C8f3d529BEa8E3fA1FAC5B416335a2f998EE1C); // elk\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address public rewardPool;\n\n    // Routes\n    address[] public outputToMaticRoute = [output, matic];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        rewardPool = _rewardPool;\n\n        outputToLp0Route = [output, lpToken0];\n        outputToLp1Route = [output, lpToken1];\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IRewardPool(rewardPool).stake(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toMatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toMatic, 0, outputToMaticRoute, address(this), block.timestamp);\n\n        uint256 maticBal = IERC20(matic).balanceOf(address(this));\n\n        uint256 callFeeAmount = maticBal.mul(callFee).div(MAX_FEE);\n        IERC20(matic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = maticBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(matic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = maticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(matic).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Common/StrategyRewardPoolBsc.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"./StratManager.sol\";\nimport \"./FeeManager.sol\";\n\ncontract StrategyRewardPoolBsc is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address public want;\n    address public output;\n\n    // Third party contracts\n    address public rewardPool;\n\n    // Routes\n    address[] public outputToWantRoute;\n    address[] public outputToWbnbRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _output,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        output = _output;\n        rewardPool = _rewardPool;\n\n        if (output != wbnb) {\n            outputToWbnbRoute = [output, wbnb];\n        }\n\n        if (output != want) {\n            if (output != wbnb) {\n                outputToWantRoute = [output, wbnb, want];\n            } else {\n                outputToWantRoute = [wbnb, want];\n            }\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = balanceOfWant();\n\n        if (wantBal > 0) {\n            IRewardPool(rewardPool).deposit(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = balanceOfWant();\n\n        if (wantBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\n            wantBal = balanceOfWant();\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IRewardPool(rewardPool).getReward();\n        _chargeFees();\n        _swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function _chargeFees() internal {\n        uint256 wbnbBal;\n\n        if (output != wbnb) {\n            uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n            wbnbBal = IERC20(wbnb).balanceOf(address(this));\n        } else {\n            wbnbBal = IERC20(wbnb).balanceOf(address(this)).mul(45).div(1000);\n        }\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // optionally swaps rewards if output != want.\n    function _swapRewards() internal {\n        if (output != want) {\n            uint256 toWant = IERC20(output).balanceOf(address(this));\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWant, 0, outputToWantRoute, address(this), block.timestamp);\n        }\n    }\n\n    // calculate the total underlaying {want} held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much {want} the contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much {want} the strategy has allocated in the {targetRewardPool}\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 wantBal = balanceOfWant();\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() external onlyManager {\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n        pause();\n    }\n\n    function pause() public onlyManager {\n        _pause();\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n        _giveAllowances();\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n    }\n\n    function inCaseTokensGetStuck(address _token) external onlyManager {\n        require(_token != want, \"!safe\");\n        require(_token != output, \"!safe\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Common/StrategyCommonRewardPoolLP.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCommonRewardPoolLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public native;\n    address public output;\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address public rewardPool;\n\n    // Routes\n    address[] public outputToNativeRoute;\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute,\n        address[] memory _outputToLp0Route,\n        address[] memory _outputToLp1Route\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        rewardPool = _rewardPool;\n\n        output = _outputToNativeRoute[0];\n        native = _outputToNativeRoute[_outputToNativeRoute.length - 1];\n        outputToNativeRoute = _outputToNativeRoute;\n\n        // setup lp routing\n        lpToken0 = IUniswapV2Pair(want).token0();\n        outputToLp0Route = _outputToLp0Route;\n\n        lpToken1 = IUniswapV2Pair(want).token1();\n        outputToLp1Route = _outputToLp1Route;\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IRewardPool(rewardPool).stake(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toNative = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toNative, 0, outputToNativeRoute, address(this), block.timestamp);\n\n        uint256 nativeBal = IERC20(native).balanceOf(address(this));\n\n        uint256 callFeeAmount = nativeBal.mul(callFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = nativeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = nativeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(native).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Common/StrategyCommonRewardPoolLPPolygon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"./StrategyCommonRewardPoolLP.sol\";\n\ncontract StrategyCommonRewardPoolLPPolygon is StrategyCommonRewardPoolLP {\n    constructor(\n        address _want,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute,\n        address[] memory _outputToLp0Route,\n        address[] memory _outputToLp1Route,\n        uint _callFee\n    ) StrategyCommonRewardPoolLP(\n        _want,\n        _rewardPool,\n        _vault,\n        _unirouter,\n        _keeper,\n        _strategist,\n        _beefyFeeRecipient,\n        _outputToNativeRoute,\n        _outputToLp0Route,\n        _outputToLp1Route\n    ) {\n        _setCallFee(_callFee);\n    }\n\n    function _setCallFee(uint _fee) internal {\n        this.setCallFee(_fee);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Cometh/StrategyRewardPoolPolygonLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/common/IRewardPool.sol\";\r\nimport \"../Common/StratManager.sol\";\r\nimport \"../Common/FeeManager.sol\";\r\n\r\ncontract StrategyRewardPoolPolygonLP is StratManager, FeeManager {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\r\n    address constant public matic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\r\n    address constant public output = address(0x9C78EE466D6Cb57A4d01Fd887D2b5dFb2D46288f);\r\n    address public want;\r\n    address public lpToken0;\r\n    address public lpToken1;\r\n\r\n    // Third party contracts\r\n    address public rewardPool;\r\n\r\n    // Routes\r\n    address[] public outputToMaticRoute = [output, matic];\r\n    address[] public outputToLp0Route;\r\n    address[] public outputToLp1Route;\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    constructor(\r\n        address _want,\r\n        address _rewardPool,\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _strategist,\r\n        address _beefyFeeRecipient\r\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\r\n        want = _want;\r\n        lpToken0 = IUniswapV2Pair(want).token0();\r\n        lpToken1 = IUniswapV2Pair(want).token1();\r\n        rewardPool = _rewardPool;\r\n\r\n        if (lpToken0 == matic) {\r\n            outputToLp0Route = [output, matic];\r\n        } else if (lpToken0 == eth) {\r\n            outputToLp0Route = [output, eth];\r\n        } else if (lpToken0 != output) {\r\n            outputToLp0Route = [output, eth, lpToken0];\r\n        }\r\n\r\n        if (lpToken1 == matic) {\r\n            outputToLp1Route = [output, matic];\r\n        } else if (lpToken1 == eth) {\r\n            outputToLp1Route = [output, eth];\r\n        } else if (lpToken1 != output) {\r\n            outputToLp1Route = [output, eth, lpToken1];\r\n        }\r\n\r\n        _giveAllowances();\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal > 0) {\r\n            IRewardPool(rewardPool).stake(wantBal);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal < _amount) {\r\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n        if (tx.origin == owner() || paused()) {\r\n            IERC20(want).safeTransfer(vault, wantBal);\r\n        } else {\r\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE_CAP).div(WITHDRAWAL_MAX);\r\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\r\n        }\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() external whenNotPaused onlyEOA {\r\n        IRewardPool(rewardPool).getReward();\r\n        chargeFees();\r\n        addLiquidity();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toMatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toMatic, 0, outputToMaticRoute, address(this), block.timestamp);\r\n\r\n        uint256 maticBal = IERC20(matic).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = maticBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(msg.sender, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = maticBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n\r\n        uint256 strategistFee = maticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(strategist, strategistFee);\r\n    }\r\n\r\n    // Adds liquidity to AMM and gets more LP tokens.\r\n    function addLiquidity() internal {\r\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\r\n\r\n        if (lpToken0 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\r\n        }\r\n\r\n        if (lpToken1 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\r\n        }\r\n\r\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\r\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\r\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\r\n    }\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool());\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // it calculates how much 'want' the strategy has working in the farm.\r\n    function balanceOfPool() public view returns (uint256) {\r\n        return IRewardPool(rewardPool).balanceOf(address(this));\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        pause();\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\r\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(rewardPool, 0);\r\n        IERC20(output).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/BIFI/strategies/Cometh/StrategyMultiRewardsPolygonLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/common/IRewardPool.sol\";\r\nimport \"../Common/StratManager.sol\";\r\nimport \"../Common/FeeManager.sol\";\r\n\r\ncontract StrategyMultiRewardsPolygonLP is StratManager, FeeManager {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\r\n    address constant public matic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\r\n    address constant public output = address(0x9C78EE466D6Cb57A4d01Fd887D2b5dFb2D46288f);\r\n    address public want;\r\n    address public lpToken0;\r\n    address public lpToken1;\r\n    address public secondOutput;\r\n\r\n    // Third party contracts\r\n    address public rewardPool;\r\n\r\n    // Routes\r\n    address[] public outputToMaticRoute = [output, matic];\r\n    address[] public outputToLp0Route;\r\n    address[] public outputToLp1Route;\r\n    address[] public secondOutputToOutputRoute;\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    constructor(\r\n        address _want,\r\n        address _rewardPool,\r\n        address _secondOutput,\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _strategist,\r\n        address _beefyFeeRecipient\r\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\r\n        want = _want;\r\n        lpToken0 = IUniswapV2Pair(want).token0();\r\n        lpToken1 = IUniswapV2Pair(want).token1();\r\n        rewardPool = _rewardPool;\r\n        secondOutput = _secondOutput;\r\n\r\n        secondOutputToOutputRoute = [secondOutput, output];\r\n\r\n        if (lpToken0 == matic) {\r\n            outputToLp0Route = [output, matic];\r\n        } else if (lpToken0 == eth) {\r\n            outputToLp0Route = [output, eth];\r\n        } else if (lpToken0 != output) {\r\n            outputToLp0Route = [output, eth, lpToken0];\r\n        }\r\n\r\n        if (lpToken1 == matic) {\r\n            outputToLp1Route = [output, matic];\r\n        } else if (lpToken1 == eth) {\r\n            outputToLp1Route = [output, eth];\r\n        } else if (lpToken1 != output) {\r\n            outputToLp1Route = [output, eth, lpToken1];\r\n        }\r\n\r\n        _giveAllowances();\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal > 0) {\r\n            IRewardPool(rewardPool).stake(wantBal);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal < _amount) {\r\n            IRewardPool(rewardPool).withdraw(_amount.sub(wantBal));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n        if (tx.origin == owner() || paused()) {\r\n            IERC20(want).safeTransfer(vault, wantBal);\r\n        } else {\r\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE_CAP).div(WITHDRAWAL_MAX);\r\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\r\n        }\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() external whenNotPaused onlyEOA {\r\n        IRewardPool(rewardPool).getReward();\r\n        chargeFees();\r\n        addLiquidity();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toOutput = IERC20(secondOutput).balanceOf(address(this));\r\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toOutput, 0, secondOutputToOutputRoute, address(this), block.timestamp);\r\n\r\n        uint256 toMatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toMatic, 0, outputToMaticRoute, address(this), block.timestamp);\r\n\r\n        uint256 maticBal = IERC20(matic).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = maticBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(msg.sender, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = maticBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n\r\n        uint256 strategistFee = maticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(matic).safeTransfer(strategist, strategistFee);\r\n    }\r\n\r\n    // Adds liquidity to AMM and gets more LP tokens.\r\n    function addLiquidity() internal {\r\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\r\n\r\n        if (lpToken0 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\r\n        }\r\n\r\n        if (lpToken1 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\r\n        }\r\n\r\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\r\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\r\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\r\n    }\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool());\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // it calculates how much 'want' the strategy has working in the farm.\r\n    function balanceOfPool() public view returns (uint256) {\r\n        return IRewardPool(rewardPool).balanceOf(address(this));\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        pause();\r\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\r\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\r\n        IERC20(secondOutput).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(rewardPool, 0);\r\n        IERC20(output).safeApprove(unirouter, 0);\r\n        IERC20(secondOutput).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/BIFI/strategies/BIFI/StrategyBifiMaxi.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IWBNB.sol\";\nimport \"../../interfaces/thugs/IThugswapRouter.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\n\n/**\n * @dev BIFI MAXIMALIST STRATEGY. DEPOSIT BIFI. USE THE BNB REWARDS TO GET MORE BIFI!\n */\ncontract StrategyBifiMaxi is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - The token that rewards are paid in.\n     * {bifi} - BeefyFinance token. The token this strategy looks to maximize.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - Streetswap router to use as AMM.\n     */\n    address constant public unirouter = address(0x3bc677674df90A9e5D741f28f6CA303357D0E4Ec);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the {bifi} is staked.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 1% total for fees.\n     *\n     * {REWARDS_FEE} - 0.5% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to pay for harvest execution.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 5 === 0.05% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 5;\n    uint constant public CALL_FEE     = 5;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 5;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Thugswap.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault) {\n        vault = _vault;\n\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(bifi).safeApprove(rewards, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It stakes the received {bifi} into the {rewards} pool.\n     */\n    function deposit() public whenNotPaused {\n        uint256 bifiBal = IERC20(bifi).balanceOf(address(this));\n\n        if (bifiBal > 0) {\n            IRewardPool(rewards).stake(bifiBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {bifi} from the {rewards} pool.\n     * The available {bifi} minus a withdrawal fee is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 bifiBal = IERC20(bifi).balanceOf(address(this));\n\n        if (bifiBal < _amount) {\n            IRewardPool(rewards).withdraw(_amount.sub(bifiBal));\n            bifiBal = IERC20(bifi).balanceOf(address(this));\n        }\n\n        if (bifiBal > _amount) {\n            bifiBal = _amount;\n        }\n\n        uint256 withdrawalFee = bifiBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(bifi).safeTransfer(vault, bifiBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the RewardPool.\n     * 2. It charges a small system fee.\n     * 3. It swaps the {wbnb} token for more {bifi}\n     * 4. It deposits the {bifi} back into the pool.\n     */\n    function harvest() external whenNotPaused onlyOwner {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(rewards).getReward();\n        chargeFees();\n        swapRewards();\n        deposit();\n    }\n\n    /**\n     * @dev Takes out 1% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Rewards fee\n     */\n    function chargeFees() internal {\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Swaps whatever {wbnb} it has for more {bifi}.\n     */\n    function swapRewards() internal {\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n        IThugswapRouter(unirouter).swapExactTokensForTokens(wbnbBal, 0, wbnbToBifiRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {bifi} held by the strat.\n     * It takes into account both the funds at hand, as the funds allocated in the RewardsPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfBifi().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {bifi} the contract holds.\n     */\n    function balanceOfBifi() public view returns (uint256) {\n        return IERC20(bifi).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {bifi} the strategy has allocated in the RewardsPool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external onlyOwner {\n        panic();\n\n        uint256 bifiBal = IERC20(bifi).balanceOf(address(this));\n        IERC20(bifi).transfer(vault, bifiBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the OriginalGangster, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IRewardPool(rewards).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(bifi).safeApprove(rewards, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(bifi).safeApprove(rewards, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/BHC/StrategyBillionHpsLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Strategy to farm HPS through a Synthetix based rewards pool contract.\n */\ncontract StrategyBillionHpsLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {hps} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public hps  = address(0xeDa21B525Ac789EaB1a08ef2404dd8505FfB973D);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public lpPair = address(0xcaC3b7DE7D5c44E8E1048241C7dE29a61b5C3E7d);\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {julrouter} - JulSwap router\n     * {rewardPool} - Reward Pool contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public julrouter  = address(0xbd67d157502A23309Db761c41965600c2Ec788b2);\n    address constant public rewardPool = address(0xcC16f9Ca629b140d46886A82FeaF586A5532BD99);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {hpsToWbnbRoute} - Route we take to get from {hps} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {hpsToLp0Route} - Route we take to get from {hps} into {lpToken0}.\n     * {hpsToLp1Route} - Route we take to get from {hps} into {lpToken1}.\n     */\n    address[] public hpsToWbnbRoute = [hps, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public hpsToLp0Route;\n    address[] public hpsToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            hpsToLp0Route = [hps, wbnb];\n        } else if (lpToken0 != hps) {\n            hpsToLp0Route = [hps, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            hpsToLp1Route = [hps, wbnb];\n        } else if (lpToken1 != hps) {\n            hpsToLp1Route = [hps, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(hps).safeApprove(julrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(julrouter, 0);\n        IERC20(lpToken0).safeApprove(julrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(julrouter, 0);\n        IERC20(lpToken1).safeApprove(julrouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the Reward Pool to farm {hps}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IRewardPool(rewardPool).stake(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the Reward Pool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Reward Pool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {hps} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(hps).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(julrouter).swapExactTokensForTokens(toWbnb, 0, hpsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {hps} for {lpToken0}, {lpToken1} & {wbnb} using JulSwap.\n     */\n    function addLiquidity() internal {\n        uint256 hpsHalf = IERC20(hps).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != hps) {\n            IUniswapRouter(julrouter).swapExactTokensForTokens(hpsHalf, 0, hpsToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != hps) {\n            IUniswapRouter(julrouter).swapExactTokensForTokens(hpsHalf, 0, hpsToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(julrouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the Reward Pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Reward Pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(rewardPool, 0);\n        IERC20(hps).safeApprove(julrouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(julrouter, 0);\n        IERC20(lpToken1).safeApprove(julrouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(hps).safeApprove(julrouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(julrouter, 0);\n        IERC20(lpToken0).safeApprove(julrouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(julrouter, 0);\n        IERC20(lpToken1).safeApprove(julrouter, type(uint).max);\n\n        deposit();\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/BHC/StrategyBillionHps.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Strategy to farm HPS through a Synthetix based rewards pool contract.\n */\ncontract StrategyBillionHps is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing and to pay out fees.\n     * {hps} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public hps  = address(0xeDa21B525Ac789EaB1a08ef2404dd8505FfB973D);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {julrouter} - JulSwap router\n     * {rewardPool} - Reward pool contract. Stake {hps}, get {hps}.\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public julrouter  = address(0xbd67d157502A23309Db761c41965600c2Ec788b2);\n    address constant public rewardPool = address(0xDC284d444A5Ec2B594267F29FFB8eB7Fde76B8fD);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 667;\n    uint constant public CALL_FEE     = 111;\n    uint constant public TREASURY_FEE = 111;\n    uint constant public STRATEGIST_FEE = 111;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using JulSwap and PancakeSwap.\n     * {hpsToWbnbRoute} - Route we take to go from {hps} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public hpsToWbnbRoute = [hps, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(hps).safeApprove(rewardPool, type(uint256).max);\n        IERC20(hps).safeApprove(julrouter, type(uint256).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint256).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {hps} in the reward pool to earn {hps}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 hpsBal = IERC20(hps).balanceOf(address(this));\n\n        if (hpsBal > 0) {\n            IRewardPool(rewardPool).stake(hpsBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws {hps} from the reward pool and sends it to the vault.\n     * @param _amount How much {hps} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 hpsBal = IERC20(hps).balanceOf(address(this));\n\n        if (hpsBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(hpsBal));\n            hpsBal = IERC20(hps).balanceOf(address(this));\n        }\n\n        if (hpsBal > _amount) {\n            hpsBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(hps).safeTransfer(vault, hpsBal);\n        } else {\n            uint256 withdrawalFee = hpsBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(hps).safeTransfer(vault, hpsBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev In charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the IRewardPool.\n     * 3. It charges and distributes system fees.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 3.0% -> BIFI Holders\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist Fee\n     * 0.5% -> Call Fee\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(hps).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(julrouter).swapExactTokensForTokens(toWbnb, 0, hpsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {hps} held by the strat.\n     * It takes into account both the funds at hand, and the funds allocated in the reward pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfBhc().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {hps} the contract holds.\n     */\n    function balanceOfBhc() public view returns (uint256) {\n        return IERC20(hps).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {hps} the strategy has allocated in the reward pool.\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 hpsBal = IERC20(hps).balanceOf(address(this));\n        IERC20(hps).transfer(vault, hpsBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the reward pool, leaving rewards behind\n     */\n    function panic() external onlyOwner {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(hps).safeApprove(rewardPool, 0);\n        IERC20(hps).safeApprove(julrouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(hps).safeApprove(rewardPool, type(uint256).max);\n        IERC20(hps).safeApprove(julrouter, type(uint256).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint256).max);\n\n        deposit();\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/BHC/StrategyBillion.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\n\n/**\n * @dev Strategy to farm BHC through a Synthetix based rewards pool contract.\n */\ncontract StrategyBillion is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing and to pay out fees.\n     * {bhc} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bhc = address(0x6fd7c98458a943f469E1Cf4eA85B173f5Cd342F4);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - StreetSwap unirouter\n     * {rewardPool} - Reward pool contract. Stake {bhc}, get {bhc}.\n     */\n    address constant public unirouter = address(0x3bc677674df90A9e5D741f28f6CA303357D0E4Ec);\n    address constant public rewardPool = address(0xF867ea84d04C79Bbd812E76F3eCeDF3d053fFf91);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 667;\n    uint constant public CALL_FEE     = 111;\n    uint constant public TREASURY_FEE = 111;\n    uint constant public STRATEGIST_FEE = 111;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Thugswap.\n     * {bhcToWbnbRoute} - Route we take to go from {bhc} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public bhcToWbnbRoute = [bhc, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(bhc).safeApprove(rewardPool, type(uint256).max);\n        IERC20(bhc).safeApprove(unirouter, type(uint256).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint256).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {bhc} in the reward pool to earn {bhc}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 bhcBal = IERC20(bhc).balanceOf(address(this));\n\n        if (bhcBal > 0) {\n            IRewardPool(rewardPool).stake(bhcBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws {bhc} from the reward pool and sends it to the vault.\n     * @param _amount How much {bhc} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 bhcBal = IERC20(bhc).balanceOf(address(this));\n\n        if (bhcBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(bhcBal));\n            bhcBal = IERC20(bhc).balanceOf(address(this));\n        }\n\n        if (bhcBal > _amount) {\n            bhcBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(bhc).safeTransfer(vault, bhcBal);\n        } else {\n            uint256 withdrawalFee = bhcBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(bhc).safeTransfer(vault, bhcBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev In charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the IRewardPool.\n     * 3. It charges and distributes system fees.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        deposit();\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 3.0% -> BIFI Holders\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist Fee\n     * 0.5% -> Call Fee\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(bhc).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, bhcToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {bhc} held by the strat.\n     * It takes into account both the funds at hand, and the funds allocated in the reward pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfBhc().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {bhc} the contract holds.\n     */\n    function balanceOfBhc() public view returns (uint256) {\n        return IERC20(bhc).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {bhc} the strategy has allocated in the reward pool.\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 bhcBal = IERC20(bhc).balanceOf(address(this));\n        IERC20(bhc).transfer(vault, bhcBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the reward pool, leaving rewards behind\n     */\n    function panic() external onlyOwner {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(bhc).safeApprove(rewardPool, 0);\n        IERC20(bhc).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(bhc).safeApprove(rewardPool, type(uint256).max);\n        IERC20(bhc).safeApprove(unirouter, type(uint256).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint256).max);\n\n        deposit();\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/1Inch/Strategy1inchBnbLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/1inch/IMooniswap.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IWBNB.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming 1Inch LP Pools.\n */\ncontract Strategy1InchBnbLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {inch} - Token generated by staking our funds. In this case it's the 1INCH token.\n     * {bnb}  - 0 address representing BNB(ETH) native token in 1Inch LP pairs.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public inch = address(0x111111111117dC0aa78b770fA6A738034120C302);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public bnb  = address(0x0000000000000000000000000000000000000000);\n    address constant public lpPair = address(0xdaF66c0B7e8E2FC76B15B07AD25eE58E04a66796);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {rewardPool} - 1Inch FarmingRewards pool\n     */\n    address constant public unirouter   = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public rewardPool  = address(0x5D0EC1F843c1233D304B96DbDE0CAB9Ec04D71EF);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(inch).safeApprove(lpPair, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the reward pool to earn rewards in {inch}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IRewardPool(rewardPool).stake(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the reward pool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IRewardPool(rewardPool).withdraw(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the reward pool\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(rewardPool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(inch).balanceOf(address(this)).mul(45).div(1000);\n        IMooniswap(lpPair).swap(inch, bnb, toWbnb, 1, address(this));\n\n        IWBNB(wbnb).deposit{value: address(this).balance}();\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {1inch} for {bnb} and deposits into 1Inch LP pair.\n     */\n    function addLiquidity() internal {\n        uint256 inchHalf = IERC20(inch).balanceOf(address(this)).div(2);\n\n        IMooniswap(lpPair).swap(inch, bnb, inchHalf, 1, address(0));\n\n        uint256 bnbBal = address(this).balance;\n        uint256 lp1Bal = IERC20(inch).balanceOf(address(this));\n        uint256[2] memory maxAmounts = [bnbBal, lp1Bal];\n        uint256[2] memory minAmounts = [uint(1), uint(1)];\n        IMooniswap(lpPair).deposit{value: bnbBal}(maxAmounts, minAmounts);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in reward pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the reward pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardPool(rewardPool).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the reward pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IRewardPool(rewardPool).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(rewardPool, 0);\n        IERC20(inch).safeApprove(lpPair, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(inch).safeApprove(lpPair, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    receive () external payable {}\n}"
    },
    "contracts/BIFI/interfaces/1inch/IMooniswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMooniswap {\n    function fee() external view returns (uint256);\n\n    function tokens(uint256 i) external view returns (address);\n\n    function deposit(uint256[2] memory maxAmounts, uint256[2] memory minAmounts) external payable returns(uint256 fairSupply, uint256[2] memory receivedAmounts);\n\n    function withdraw(uint256 amount, uint256[] calldata minReturns) external;\n\n    function getBalanceForAddition(address token) external view returns (uint256);\n\n    function getBalanceForRemoval(address token) external view returns (uint256);\n\n    function getReturn(\n        address fromToken,\n        address destToken,\n        uint256 amount\n    )\n    external\n    view\n    returns (uint256 returnAmount);\n\n    function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        address referral\n    )\n    external\n    payable\n    returns (uint256 returnAmount);\n}\n"
    },
    "contracts/BIFI/strategies/1Inch/Strategy1inch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/1inch/IGovMothership.sol\";\nimport \"../../interfaces/1inch/IMooniswap.sol\";\nimport \"../../interfaces/common/IRewardPool.sol\";\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IWBNB.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from staking 1Inch in Gov pool.\n */\ncontract Strategy1Inch is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {inch} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bnb}  - 0 address representing BNB(ETH) native token in 1Inch LP pairs.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - 1Inch-BNB LP pair to swap {inch} into {bnb} for paying fees.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public inch = address(0x111111111117dC0aa78b770fA6A738034120C302);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public bnb  = address(0x0000000000000000000000000000000000000000);\n    address constant public lpPair = address(0xdaF66c0B7e8E2FC76B15B07AD25eE58E04a66796);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {govMothership} - GovernanceMothership contract to stake and unstake 1Inch\n     * {govRewards} - GovernanceRewards contract to claim rewards\n     */\n    address constant public unirouter     = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public govMothership = address(0x73F0a6927A3c04E679074e70DFb9105F453e799D);\n    address constant public govRewards    = address(0x59a0A6d73e6a5224871f45E6d845ce1574063ADe);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(inch).safeApprove(govMothership, type(uint).max);\n        IERC20(inch).safeApprove(lpPair, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {inch} in the Gov pool to earn rewards in {inch}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 inchBal = IERC20(inch).balanceOf(address(this));\n\n        if (inchBal > 0) {\n            IGovMothership(govMothership).stake(inchBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {inch} from the Gov pool.\n     * The available {inch} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 inchBal = IERC20(inch).balanceOf(address(this));\n\n        if (inchBal < _amount) {\n            IGovMothership(govMothership).unstake(_amount.sub(inchBal));\n            inchBal = IERC20(inch).balanceOf(address(this));\n        }\n\n        if (inchBal > _amount) {\n            inchBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(inch).safeTransfer(vault, inchBal);\n        } else {\n            uint256 withdrawalFee = inchBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(inch).safeTransfer(vault, inchBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Gov pool\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IRewardPool(govRewards).getReward();\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(inch).balanceOf(address(this)).mul(45).div(1000);\n        IMooniswap(lpPair).swap(inch, bnb, toWbnb, 1, address(this));\n\n        IWBNB(wbnb).deposit{value: address(this).balance}();\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {inch} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in Gov pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfInch().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {inch} the contract holds.\n     */\n    function balanceOfInch() public view returns (uint256) {\n        return IERC20(inch).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {inch} the strategy has allocated in the Gov pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IGovMothership(govMothership).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IGovMothership(govMothership).unstake(balanceOfPool());\n\n        uint256 inchBal = IERC20(inch).balanceOf(address(this));\n        IERC20(inch).transfer(vault, inchBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Gov pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IGovMothership(govMothership).unstake(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(inch).safeApprove(govMothership, 0);\n        IERC20(inch).safeApprove(lpPair, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(inch).safeApprove(govMothership, type(uint).max);\n        IERC20(inch).safeApprove(lpPair, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    receive () external payable {}\n}"
    },
    "contracts/BIFI/interfaces/1inch/IGovMothership.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IGovMothership {\n    function balanceOf(address account) external view returns (uint256);\n    function stake(uint256 amount) external;\n    function unstake(uint256 amount) external;\n}\n"
    },
    "contracts/BIFI/strategies/Nyanswop/StrategyNyanswopLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/nyanswop/IStakingRewards.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Nyanswop.\n * Nyanswop is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. Nyanswop is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected IStakingRewards pool.\n * NYA rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the IStakingRewards pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyNyanswopLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {nya} - Required for liquidity routing when doing swaps.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public nya = address(0xbFa0841F7a90c4CE6643f651756EE340991F99D5);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {nyanswopRouter} - Nyanswop unirouter\n     * {pancakeswapRouter} - Nyanswop unirouter\n     * {stakingRewards} - IStakingRewards contract\n     */\n    address constant public nyanswopRouter  = address(0xc946764369623F560a5962D32c1D16D45F1BD6fa);\n    address constant public pancakeswapRouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address public stakingRewards;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - -.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Nyanswop.\n     * {nyaToWbnbRoute} - Route we take to get from {nya} into {wbnb}. (nyanswop)\n     * {wbnbToBifiRoute} - Route we take to get from {usdt} into {bifi}. (pancakeswap)\n     * {nyaToLp0Route} - Route we take to get from {nya} into {lpToken0}. (nyanswop)\n     * {nyaToLp1Route} - Route we take to get from {nya} into {lpToken1}.  (nyanswop)\n     */\n    address[] public nyaToWbnbRoute = [nya, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public nyaToLp0Route;\n    address[] public nyaToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, address _stakingRewards, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        stakingRewards = _stakingRewards;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            nyaToLp0Route = [nya, wbnb];\n        } else if (lpToken0 != nya) {\n            nyaToLp0Route = [nya, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            nyaToLp1Route = [nya, wbnb];\n        } else if (lpToken1 != nya) {\n            nyaToLp1Route = [nya, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(stakingRewards, type(uint).max);\n        IERC20(nya).safeApprove(nyanswopRouter, type(uint).max);\n        IERC20(wbnb).safeApprove(pancakeswapRouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken0).safeApprove(nyanswopRouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken1).safeApprove(nyanswopRouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the stakingRewards to farm {nya}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IStakingRewards(stakingRewards).stake(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the IStakingRewards.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IStakingRewards(stakingRewards).withdraw(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the IStakingRewards.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {nya} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IStakingRewards(stakingRewards).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * Sells {nya} to {wbnb} at Nyanswop, buys {bifi} with {wbnb} at Pancakeswap\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(nya).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(nyanswopRouter).swapExactTokensForTokens(toWbnb, 0, nyaToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(pancakeswapRouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {nya} for {lpToken0}, {lpToken1} & {usdt} using Nyanswop.\n     */\n    function addLiquidity() internal {\n        uint256 nyaHalf = IERC20(nya).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != nya) {\n            IUniswapRouter(nyanswopRouter).swapExactTokensForTokens(nyaHalf, 0, nyaToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != nya) {\n            IUniswapRouter(nyanswopRouter).swapExactTokensForTokens(nyaHalf, 0, nyaToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(nyanswopRouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the ILPTokenPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the IStakingRewards\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IStakingRewards(stakingRewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IStakingRewards(stakingRewards).exit();\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the IStakingRewards, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IStakingRewards(stakingRewards).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(stakingRewards, 0);\n        IERC20(nya).safeApprove(nyanswopRouter, 0);\n        IERC20(wbnb).safeApprove(pancakeswapRouter, 0);\n        IERC20(lpToken0).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken1).safeApprove(nyanswopRouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(stakingRewards, type(uint).max);\n        IERC20(nya).safeApprove(nyanswopRouter, type(uint).max);\n        IERC20(wbnb).safeApprove(pancakeswapRouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken0).safeApprove(nyanswopRouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken1).safeApprove(nyanswopRouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/nyanswop/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IStakingRewards {\n    // Views\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function getRewardForDuration() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // Mutative\n\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n\n    function exit() external;\n}\n"
    },
    "contracts/BIFI/strategies/Nyacash/StrategyNyacashLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/nyacash/ILPTokenSharePool.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Nyanswop.\n * Nyanswop is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. Nyanswop is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected ILPTokenSharePool pool.\n * NYAS rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the ILPTokenSharePool pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyNyacashLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {usdt} - Required for liquidity routing when doing swaps.\n     * {nyas} - Token generated by staking our funds. In this case it's the NYASs token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public usdt = address(0x55d398326f99059fF775485246999027B3197955);\n    address constant public nyas = address(0xD7410C38a86DCf3D5EC0F75e9763111E07D9C95b);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {nyanswopRouter} - Nyanswop unirouter\n     * {pancakeswapRouter} - Nyanswop unirouter\n     * {lpTokenSharePool} - ILPTokenSharePool contract\n     */\n    address constant public nyanswopRouter  = address(0xc946764369623F560a5962D32c1D16D45F1BD6fa);\n    address constant public pancakeswapRouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address public lpTokenSharePool;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - -.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Nyanswop.\n     * {nyasToWbnbRoute} - Route we take to get from {nyas} into {wbnb}. (nyanswop)\n     * {wbnbToBifiRoute} - Route we take to get from {usdt} into {bifi}. (pancakeswap)\n     * {nyasToLp0Route} - Route we take to get from {nyas} into {lpToken0}. (nyanswop)\n     * {nyasToLp1Route} - Route we take to get from {nyas} into {lpToken1}.  (nyanswop)\n     */\n    address[] public nyasToWbnbRoute = [nyas, usdt, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public nyasToLp0Route;\n    address[] public nyasToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, address _lpTokenSharePool, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        lpTokenSharePool = _lpTokenSharePool;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == usdt) {\n            nyasToLp0Route = [nyas, usdt];\n        } else if (lpToken0 != nyas) {\n            nyasToLp0Route = [nyas, usdt, lpToken0];\n        }\n\n        if (lpToken1 == usdt) {\n            nyasToLp1Route = [nyas, usdt];\n        } else if (lpToken1 != nyas) {\n            nyasToLp1Route = [nyas, usdt, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(lpTokenSharePool, type(uint).max);\n        IERC20(nyas).safeApprove(nyanswopRouter, type(uint).max);\n        IERC20(usdt).safeApprove(nyanswopRouter, type(uint).max);\n        IERC20(wbnb).safeApprove(pancakeswapRouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken0).safeApprove(nyanswopRouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken1).safeApprove(nyanswopRouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the lpTokenSharePool to farm {nyas}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            ILPTokenSharePool(lpTokenSharePool).stake(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the ILPTokenSharePool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            ILPTokenSharePool(lpTokenSharePool).withdraw(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the ILPTokenSharePool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {nyas} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        ILPTokenSharePool(lpTokenSharePool).getReward();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * Sells {nyas} to {wbnb} at Nyanswop, buys {bifi} with {wbnb} at Pancakeswap\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(nyas).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(nyanswopRouter).swapExactTokensForTokens(toWbnb, 0, nyasToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(pancakeswapRouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {nyas} for {lpToken0}, {lpToken1} & {usdt} using Nyanswop.\n     */\n    function addLiquidity() internal {\n        uint256 nyasHalf = IERC20(nyas).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != nyas) {\n            IUniswapRouter(nyanswopRouter).swapExactTokensForTokens(nyasHalf, 0, nyasToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != nyas) {\n            IUniswapRouter(nyanswopRouter).swapExactTokensForTokens(nyasHalf, 0, nyasToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(nyanswopRouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the ILPTokenPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the ILPTokenSharePool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return ILPTokenSharePool(lpTokenSharePool).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILPTokenSharePool(lpTokenSharePool).exit();\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the ILPTokenSharePool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ILPTokenSharePool(lpTokenSharePool).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(lpTokenSharePool, 0);\n        IERC20(nyas).safeApprove(nyanswopRouter, 0);\n        IERC20(usdt).safeApprove(nyanswopRouter, 0);\n        IERC20(wbnb).safeApprove(pancakeswapRouter, 0);\n        IERC20(lpToken0).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken1).safeApprove(nyanswopRouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(lpTokenSharePool, type(uint).max);\n        IERC20(nyas).safeApprove(nyanswopRouter, type(uint).max);\n        IERC20(usdt).safeApprove(nyanswopRouter, type(uint).max);\n        IERC20(wbnb).safeApprove(pancakeswapRouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken0).safeApprove(nyanswopRouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(nyanswopRouter, 0);\n        IERC20(lpToken1).safeApprove(nyanswopRouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/nyacash/ILPTokenSharePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ILPTokenSharePool {\n    // Views\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function getRewardForDuration() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // Mutative\n\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n\n    function exit() external;\n}\n"
    },
    "contracts/BIFI/strategies/LendHub/StrategyLendhub.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouter.sol\";\r\nimport \"../../interfaces/lendhub/IComptroller.sol\";\r\nimport \"../../interfaces/venus/IVToken.sol\";\r\nimport \"../Common/StratManager.sol\";\r\nimport \"../Common/FeeManager.sol\";\r\n\r\n\r\n// Lendhub Lending Strategy\r\ncontract StrategyLendhub is StratManager, FeeManager {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public wht = address(0x5545153CCFcA01fbd7Dd11C0b23ba694D9509A6F);\r\n    address constant public usdt = address(0xa71EdC38d189767582C38A3145b5873052c3e47a);\r\n    address constant public output = address(0x8F67854497218043E1f72908FFE38D0Ed7F24721);\r\n    address public want;\r\n    address public iToken;\r\n\r\n    // Third party contracts\r\n    address constant public comptroller = address(0x6537d6307ca40231939985BCF7D83096Dd1B4C09);\r\n\r\n    // Routes\r\n    address[] public outputToWhtRoute = [output, wht];\r\n    address[] public outputToWantRoute;\r\n\r\n    /**\r\n     * @dev Variables that can be changed to config profitability and risk:\r\n     * {borrowRate}          - What % of our collateral do we borrow per leverage level.\r\n     * {borrowRateMax}       - A limit on how much we can push borrow risk.\r\n     * {borrowDepth}         - How many levels of leverage do we take.\r\n     * {minLeverage}         - The minimum amount of collateral required to leverage.\r\n     * {BORROW_DEPTH_MAX}    - A limit on how many steps we can leverage.\r\n     * {INTEREST_RATE_MODE}  - The type of borrow debt. Stable: 1, Variable: 2.\r\n     */\r\n    uint256 public borrowRate;\r\n    uint256 public borrowRateMax;\r\n    uint256 public borrowDepth;\r\n    uint256 public minLeverage;\r\n    uint256 constant public BORROW_DEPTH_MAX = 10;\r\n\r\n    /**\r\n     * @dev Helps to differentiate borrowed funds that shouldn't be used in functions like 'deposit()'\r\n     * as they're required to deleverage correctly.\r\n     */\r\n    uint256 public reserves = 0;\r\n\r\n    uint256 public balanceOfPool;\r\n\r\n    /**\r\n     * @dev Events that the contract emits\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n    event StratRebalance(uint256 _borrowRate, uint256 _borrowDepth);\r\n\r\n    constructor(\r\n        address _iToken,\r\n        uint256 _borrowRate,\r\n        uint256 _borrowRateMax,\r\n        uint256 _borrowDepth,\r\n        uint256 _minLeverage,\r\n        address[] memory _markets,\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _strategist,\r\n        address _beefyFeeRecipient\r\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\r\n        iToken = _iToken;\r\n        want = IVToken(_iToken).underlying();\r\n        borrowRate = _borrowRate;\r\n        borrowRateMax = _borrowRateMax;\r\n        borrowDepth = _borrowDepth;\r\n        minLeverage = _minLeverage;\r\n\r\n        outputToWantRoute = [output, usdt, want];\r\n\r\n        _giveAllowances();\r\n\r\n        IComptroller(comptroller).enterMarkets(_markets);\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = availableWant();\r\n\r\n        if (wantBal > 0) {\r\n            _leverage(wantBal);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Repeatedly supplies and borrows {want} following the configured {borrowRate} and {borrowDepth}\r\n     * @param _amount amount of {want} to leverage\r\n     */\r\n    function _leverage(uint256 _amount) internal {\r\n        if (_amount < minLeverage) { return; }\r\n\r\n        for (uint i = 0; i < borrowDepth; i++) {\r\n            IVToken(iToken).mint(_amount);\r\n            _amount = _amount.mul(borrowRate).div(100);\r\n            IVToken(iToken).borrow(_amount);\r\n        }\r\n\r\n        reserves = reserves.add(_amount);\r\n\r\n        updateBalance();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Incrementally alternates between paying part of the debt and withdrawing part of the supplied\r\n     * collateral. Continues to do this until it repays the entire debt and withdraws all the supplied {want}\r\n     * from the system\r\n     */\r\n    function _deleverage() internal {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        uint256 borrowBal = IVToken(iToken).borrowBalanceCurrent(address(this));\r\n\r\n        while (wantBal < borrowBal) {\r\n            IVToken(iToken).repayBorrow(wantBal);\r\n\r\n            borrowBal = IVToken(iToken).borrowBalanceCurrent(address(this));\r\n            uint256 targetSupply = borrowBal.mul(100).div(borrowRate);\r\n\r\n            uint256 supplyBal = IVToken(iToken).balanceOfUnderlying(address(this));\r\n            IVToken(iToken).redeemUnderlying(supplyBal.sub(targetSupply));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        IVToken(iToken).repayBorrow(type(uint256).max);\r\n\r\n        uint256 iTokenBal = IERC20(iToken).balanceOf(address(this));\r\n        IVToken(iToken).redeem(iTokenBal);\r\n\r\n        reserves = 0;\r\n\r\n        updateBalance();\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Extra safety measure that allows us to manually unwind one level. In case we somehow get into\r\n     * as state where the cost of unwinding freezes the system. We can manually unwind a few levels\r\n     * with this function and then 'rebalance()' with new {borrowRate} and {borrowConfig} values.\r\n     * @param _borrowRate configurable borrow rate in case it's required to unwind successfully\r\n     */\r\n    function deleverageOnce(uint _borrowRate) external onlyManager {\r\n        require(_borrowRate <= borrowRateMax, \"!safe\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IVToken(iToken).repayBorrow(wantBal);\r\n\r\n        uint256 borrowBal = IVToken(iToken).borrowBalanceCurrent(address(this));\r\n        uint256 targetSupply = borrowBal.mul(100).div(_borrowRate);\r\n\r\n        uint256 supplyBal = IVToken(iToken).balanceOfUnderlying(address(this));\r\n        IVToken(iToken).redeemUnderlying(supplyBal.sub(targetSupply));\r\n\r\n        wantBal = IERC20(want).balanceOf(address(this));\r\n        reserves = wantBal;\r\n\r\n        updateBalance();\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * @dev Updates the risk profile and rebalances the vault funds accordingly.\r\n     * @param _borrowRate percent to borrow on each leverage level.\r\n     * @param _borrowDepth how many levels to leverage the funds.\r\n     */\r\n    function rebalance(uint256 _borrowRate, uint256 _borrowDepth) external onlyManager {\r\n        require(_borrowRate <= borrowRateMax, \"!rate\");\r\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \"!depth\");\r\n\r\n        _deleverage();\r\n        borrowRate = _borrowRate;\r\n        borrowDepth = _borrowDepth;\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        _leverage(wantBal);\r\n\r\n        emit StratRebalance(_borrowRate, _borrowDepth);\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() external whenNotPaused onlyEOA {\r\n        address[] memory markets = new address[](1);\r\n        markets[0] = iToken;\r\n        IComptroller(comptroller).claimComp(address(this), markets);\r\n        chargeFees();\r\n        swapRewards();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toWht = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWht, 0, outputToWhtRoute, address(this), block.timestamp);\r\n\r\n        uint256 whtBal = IERC20(wht).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = whtBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(wht).safeTransfer(msg.sender, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = whtBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(wht).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n\r\n        uint256 strategistFee = whtBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(wht).safeTransfer(strategist, strategistFee);\r\n    }\r\n\r\n    // swap rewards to {want}\r\n    function swapRewards() internal {\r\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\r\n        IUniswapRouter(unirouter).swapExactTokensForTokens(outputBal, 0, outputToWantRoute, address(this), block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws funds and sends them back to the vault. It deleverages from venus first,\r\n     * and then deposits again after the withdraw to make sure it mantains the desired ratio.\r\n     * @param _amount How much {want} to withdraw.\r\n     */\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = availableWant();\r\n\r\n        if (wantBal < _amount) {\r\n            _deleverage();\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n        if (tx.origin == owner() || paused()) {\r\n            IERC20(want).safeTransfer(vault, wantBal);\r\n        } else {\r\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\r\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\r\n        }\r\n\r\n        if (!paused()) {\r\n            _leverage(availableWant());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Required for various functions that need to deduct {reserves} from total {want}.\r\n     * @return how much {want} the contract holds without reserves\r\n     */\r\n    function availableWant() public view returns (uint256) {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        return wantBal.sub(reserves);\r\n    }\r\n\r\n    // return supply and borrow balance\r\n    function updateBalance() public {\r\n        uint256 supplyBal = IVToken(iToken).balanceOfUnderlying(address(this));\r\n        uint256 borrowBal = IVToken(iToken).borrowBalanceCurrent(address(this));\r\n        balanceOfPool = supplyBal.sub(borrowBal);\r\n    }\r\n\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool);\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        _deleverage();\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        _deleverage();\r\n        pause();\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(iToken, type(uint256).max);\r\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(iToken, 0);\r\n        IERC20(output).safeApprove(unirouter, 0);\r\n    }\r\n}"
    },
    "contracts/BIFI/interfaces/lendhub/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\ninterface IComptroller {\r\n    function claimComp(address holder, address[] calldata _iTokens) external;\r\n    function enterMarkets(address[] memory _iTokens) external;\r\n}"
    },
    "contracts/BIFI/strategies/Jetfuel/StrategyJetfuelLPV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/jetfuel/IMasterFuel.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in the JetFuel platform.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyJetfuelLPV2 is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {fuel} - Token generated by staking our funds. In this case it's the {fuel} token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public fuel = address(0x2090c8295769791ab7A3CF1CC6e0AA19F35e441A);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {masterFuel} - MasterFuel contract. Stake Tokens, get rewards.\n     * {unirouter} - Strategy unirouter\n     * {poolId} - MasterFuel pool id\n     */\n    address constant public masterFuel = address(0x86f4bC1EBf2C209D12d3587B7085aEA5707d4B56);\n    address public unirouter;\n    uint8   public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using the configured unirouter.\n     * {fuelToWbnbRoute} - Route we take to get from {fuel} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {fuelToLp0Route} - Route we take to get from {fuel} into {lpToken0}.\n     * {fuelToLp1Route} - Route we take to get from {fuel} into {lpToken1}.\n     */\n    address[] public fuelToWbnbRoute = [fuel, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public fuelToLp0Route;\n    address[] public fuelToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _unirouter, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        unirouter = _unirouter;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            fuelToLp0Route = [fuel, wbnb];\n        } else if (lpToken0 != fuel) {\n            fuelToLp0Route = [fuel, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            fuelToLp1Route = [fuel, wbnb];\n        } else if (lpToken1 != fuel) {\n            fuelToLp1Route = [fuel, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterFuel, type(uint).max);\n        IERC20(fuel).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterFuel to farm {fuel}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterFuel(masterFuel).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterFuel.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterFuel(masterFuel).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterFuel.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {fuel} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterFuel(masterFuel).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.5% -> Treasury fee\n     * 4.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(fuel).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, fuelToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {fuel} for {lpToken0}, {lpToken1} & {wbnb} using the configure unirouter.\n     */\n    function addLiquidity() internal {\n        uint256 fuelHalf = IERC20(fuel).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != fuel) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(fuelHalf, 0, fuelToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != fuel) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(fuelHalf, 0, fuelToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterFuel.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterFuel\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterFuel(masterFuel).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterFuel(masterFuel).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterFuel, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterFuel(masterFuel).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterFuel, 0);\n        IERC20(fuel).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterFuel, type(uint).max);\n        IERC20(fuel).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/jetfuel/IMasterFuel.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMasterFuel {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function pendingFuel(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/HyperJump/StrategyMechs.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/hyperjump/IHyperCity.sol\";\nimport \"../../interfaces/hyperjump/IHyperPool.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming a {mechs} pool + base {alloy} farming.\n *\n * The strategy simply deposits whatever {alloy} it receives from the vault into the HyperCity getting {mechs} in exchange.\n * This {mechs} is then allocated into the configured pool (HyperPool). Rewards generated by the HyperPool can be harvested,\n * swapped for more {alloy}, and deposited again for compound farming. Rewards from the HyperCity are also compounded.\n *\n * This strat is currently compatible with all {mechs} pools.\n * The output token and its corresponding HyperPool is configured with a constructor argument\n */\ncontract StrategyMechs is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {alloy} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {mechs} - Intermediate token generated by staking {alloy} in the HyperCity.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {output} - Token generated by staking {alloy}.\n     */\n    address constant public wbnb  = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public alloy = address(0x5eF5994fA33FF4eB6c82d51ee1DC145c546065Bd);\n    address constant public mechs  = address(0x3ae713C662B8852D686e718E0762631A4CB84954);\n    address constant public hypr = address(0x03D6BD3d48F956D783456695698C407A46ecD54d);\n    address constant public bifi  = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public output;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - StreetSwap unirouter\n     * {hyperCity} - HyperCity contract. Stake {alloy}, get {mechs}.\n     * {hyperPool} - HyperPool contract. Stake {mechs}, get {output} token.\n     */\n    address constant public unirouter = address(0x3bc677674df90A9e5D741f28f6CA303357D0E4Ec);\n    address constant public hyperCity = address(0x4F1818Ff649498a2441aE1AD29ccF55a8E1C6250);\n    address public hyperPool;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address constant public hyperdao = address(0x62f4deb9895a95276b03E38ABea8b0B315e8C3c1);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 2% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {HYPER_FEE} - 1.5% goes to the hyper team.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 444;\n    uint constant public CALL_FEE     = 111;\n    uint constant public TREASURY_FEE = 111;\n    uint constant public HYPER_FEE    = 334;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using StreetSwap.\n     * {outputToAlloyRoute} - Route we take to get from {output} into {alloy}.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public outputToAlloyRoute;\n    address[] public outputToWbnbRoute;\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public wbnbToHyprRoute = [wbnb, hypr];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the HyperPool and Vault that it will use.\n     */\n    constructor(address _hyperPool, address _vault) {\n        hyperPool = _hyperPool;\n        vault = _vault;\n        output = IHyperPool(hyperPool).rewardToken();\n\n        outputToAlloyRoute = [output, wbnb, alloy];\n        outputToWbnbRoute = [output, wbnb];\n\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {alloy} in the HyperCity to receive {mechs}\n     * It then deposits the received {mechs} in the HyperPool to farm {output}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 alloyBal = IERC20(alloy).balanceOf(address(this));\n\n        if (alloyBal > 0) {\n            IERC20(alloy).safeApprove(hyperCity, 0);\n            IERC20(alloy).safeApprove(hyperCity, alloyBal);\n            IHyperCity(hyperCity).enterStaking(alloyBal);\n\n            uint256 mechsBal = IERC20(mechs).balanceOf(address(this));\n            IERC20(mechs).safeApprove(hyperPool, 0);\n            IERC20(mechs).safeApprove(hyperPool, mechsBal);\n            IHyperPool(hyperPool).deposit(mechsBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {mechs} from the HyperPool, the {mechs} is switched back to {alloy}.\n     * The resulting {alloy} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 alloyBal = IERC20(alloy).balanceOf(address(this));\n\n        if (alloyBal < _amount) {\n            uint256 mechsBal = IERC20(mechs).balanceOf(address(this));\n            IHyperPool(hyperPool).withdraw(_amount.sub(alloyBal).sub(mechsBal));\n\n            mechsBal = IERC20(mechs).balanceOf(address(this));\n            if (mechsBal > _amount) {\n                mechsBal = _amount;\n            }\n\n            IHyperCity(hyperCity).leaveStaking(mechsBal);\n            alloyBal = IERC20(alloy).balanceOf(address(this));\n        }\n\n        if (alloyBal > _amount) {\n            alloyBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(alloy).safeTransfer(vault, alloyBal);\n        } else {\n            uint256 _fee = alloyBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(alloy).safeTransfer(vault, alloyBal.sub(_fee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the HyperCity & HyperPool\n     * 2. It swaps the {output} token for {alloy}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IHyperCity(hyperCity).leaveStaking(0);\n        IHyperPool(hyperPool).deposit(0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(alloy).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 hyperFee = wbnbBal.mul(HYPER_FEE).div(MAX_FEE);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(hyperFee, 0, wbnbToHyprRoute, hyperdao, block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Swaps whatever {output} it has for more {alloy}.\n     */\n    function swapRewards() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(outputBal, 0, outputToAlloyRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {alloy} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the HyperPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfAlloy().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {alloy} the contract holds.\n     */\n    function balanceOfAlloy() public view returns (uint256) {\n        return IERC20(alloy).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {alloy} the strategy has allocated in the HyperCity\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IHyperCity(hyperCity).userInfo(0, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that gets called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IHyperPool(hyperPool).emergencyWithdraw();\n\n        uint256 mechsBal = IERC20(mechs).balanceOf(address(this));\n        IHyperCity(hyperCity).leaveStaking(mechsBal);\n\n        uint256 alloyBal = IERC20(alloy).balanceOf(address(this));\n        IERC20(alloy).transfer(vault, alloyBal);\n    }\n\n    /**\n     * @dev Withdraws all funds from the HyperPool & HyperCity, leaving rewards behind.\n     * It also reduces allowance of the unirouter\n     */\n    function panic() public onlyOwner {\n        pause();\n\n        IHyperPool(hyperPool).emergencyWithdraw();\n\n        uint256 mechsBal = IERC20(mechs).balanceOf(address(this));\n        IHyperCity(hyperCity).leaveStaking(mechsBal);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/hyperjump/IHyperCity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IHyperCity {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function enterStaking(uint256 _amount) external;\n    function leaveStaking(uint256 _amount) external;\n    function pendingAlloy(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}\n"
    },
    "contracts/BIFI/interfaces/hyperjump/IHyperPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IHyperPool {\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _amount) external;\n    function pendingReward(address _user) external view returns (uint256);\n    function userInfo(address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw() external;\n    function rewardToken() external view returns (address);\n}\n"
    },
    "contracts/BIFI/strategies/HyperJump/StrategyHyperLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/hyperjump/IThugswapRouter.sol\";\nimport \"../../interfaces/hyperjump/IThugswapPair.sol\";\nimport \"../../interfaces/hyperjump/IHyperCity.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in StreetSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyHyperLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {alloy} - Token generated by staking our funds. In this case it's the ALLOY token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IThugswapPair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public alloy = address(0x5eF5994fA33FF4eB6c82d51ee1DC145c546065Bd);\n    address constant public hypr = address(0x03D6BD3d48F956D783456695698C407A46ecD54d);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - Selected unirouter configured through constructor\n     * {hypercity} - HyperCity contract\n     * {poolId} - HyperCity pool id\n     */\n    address public unirouter;\n    address constant public hypercity = address(0x4F1818Ff649498a2441aE1AD29ccF55a8E1C6250);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address constant public hyperdao = address(0x62f4deb9895a95276b03E38ABea8b0B315e8C3c1);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 2% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {HYPER_FEE} - 1.5% goes to the hyper team.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 444;\n    uint constant public CALL_FEE     = 111;\n    uint constant public TREASURY_FEE = 111;\n    uint constant public HYPER_FEE    = 334;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Thugswap.\n     * {alloyToWbnbRoute} - Route we take to get from {alloy} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {alloyToLp0Route} - Route we take to get from {alloy} into {lpToken0}.\n     * {alloyToLp1Route} - Route we take to get from {alloy} into {lpToken1}.\n     */\n    address[] public alloyToWbnbRoute = [alloy, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public wbnbToHyprRoute = [wbnb, hypr];\n    address[] public alloyToLp0Route;\n    address[] public alloyToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _unirouter) {\n        lpPair = _lpPair;\n        lpToken0 = IThugswapPair(lpPair).token0();\n        lpToken1 = IThugswapPair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        unirouter = _unirouter;\n\n        if (lpToken0 == wbnb) {\n            alloyToLp0Route = [alloy, wbnb];\n        } else if (lpToken0 != alloy) {\n            alloyToLp0Route = [alloy, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            alloyToLp1Route = [alloy, wbnb];\n        } else if (lpToken1 != alloy) {\n            alloyToLp1Route = [alloy, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(hypercity, type(uint).max);\n        IERC20(alloy).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the HyperCity to farm {alloy}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IHyperCity(hypercity).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the HyperCity.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IHyperCity(hypercity).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the HyperCity.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {alloy} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IHyperCity(hypercity).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 1.0% -> Call Fee\n     * 1.0% -> Treasury fee\n     * 4.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(alloy).balanceOf(address(this)).mul(45).div(1000);\n        IThugswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, alloyToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IThugswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 hyperFee = wbnbBal.mul(HYPER_FEE).div(MAX_FEE);\n        IThugswapRouter(unirouter).swapExactTokensForTokens(hyperFee, 0, wbnbToHyprRoute, hyperdao, block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Swaps {alloy} for {lpToken0}, {lpToken1} & {wbnb} using ThugSwap.\n     */\n    function addLiquidity() internal {\n        uint256 alloyHalf = IERC20(alloy).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != alloy) {\n            IThugswapRouter(unirouter).swapExactTokensForTokens(alloyHalf, 0, alloyToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != alloy) {\n            IThugswapRouter(unirouter).swapExactTokensForTokens(alloyHalf, 0, alloyToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IThugswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize AutoFarm balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying Auto strategy doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the HyperCity.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the HyperCity\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IHyperCity(hypercity).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IHyperCity(hypercity).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the HyperCity, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IHyperCity(hypercity).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(hypercity, 0);\n        IERC20(alloy).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(hypercity, type(uint).max);\n        IERC20(alloy).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/hyperjump/IThugswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IThugswapRouter {\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityBNB(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountBNB, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityBNB(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountBNB);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactBNBForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForBNB(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n}"
    },
    "contracts/BIFI/interfaces/hyperjump/IThugswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IThugswapPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/BIFI/strategies/Gondola/StrategyGondolaZPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../../interfaces/gondola/IGondolaLP.sol\";\nimport \"../../interfaces/gondola/IGondolaSwap.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyGondolaZPool is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wavax  = address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    address constant public output = address(0xD606199557c8Ab6F4Cc70bD03FaCc96ca576f142);\n    address public want;\n    address public swapToken;\n    address public depositToken;\n\n    // Third party contracts\n    address constant public masterchef = address(0x34C8712Cc527a8E6834787Bd9e3AD4F2537B0f50);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWavaxRoute = [output, wavax];\n    address[] public outputToDepositRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n\n        swapToken = IGondolaLP(want).swap();\n        depositToken = IGondolaSwap(swapToken).getToken(0);\n\n        if (depositToken == wavax) {\n            outputToDepositRoute = [output, wavax];\n        } else if (depositToken != output) {\n            outputToDepositRoute = [output, wavax, depositToken];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWavax = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWavax, 0, outputToWavaxRoute, address(this), block.timestamp);\n\n        uint256 wavaxBal = IERC20(wavax).balanceOf(address(this));\n\n        uint256 callFeeAmount = wavaxBal.mul(callFee).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wavaxBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wavaxBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(outputBal, 0, outputToDepositRoute, address(this), block.timestamp);\n\n        uint256 depositBal = IERC20(depositToken).balanceOf(address(this));\n        uint256[] memory amounts = new uint256[](2);\n        amounts[0] = depositBal;\n        IGondolaSwap(swapToken).addLiquidity(amounts, 0, block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n        IERC20(depositToken).safeApprove(swapToken, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(depositToken).safeApprove(swapToken, 0);\n    }\n}"
    },
    "contracts/BIFI/interfaces/common/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMasterChef {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/interfaces/gondola/IGondolaLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IGondolaLP {\n    function swap() external view returns (address);\n}"
    },
    "contracts/BIFI/interfaces/gondola/IGondolaSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IGondolaSwap {\n    function getToken(uint8 index) external view returns (address);\n    function addLiquidity(uint256[] calldata amounts, uint256 minToMint, uint256 deadline) external returns (uint256);\n\n}"
    },
    "contracts/BIFI/strategies/Spooky/StrategyMasterChefLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/common/IMasterChef.sol\";\r\nimport \"../Common/StratManager.sol\";\r\nimport \"../Common/FeeManager.sol\";\r\n\r\n\r\ncontract StrategyMasterChefLP is StratManager, FeeManager {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public wrapped = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\r\n    address constant public output = address(0x841FAD6EAe12c286d1Fd18d1d525DFfA75C7EFFE);\r\n    address public want;\r\n    address public lpToken0;\r\n    address public lpToken1;\r\n\r\n    // Third party contracts\r\n    address constant public masterchef = address(0x2b2929E785374c651a81A63878Ab22742656DcDd);\r\n    uint256 public poolId;\r\n\r\n    // Routes\r\n    address[] public outputToWrappedRoute = [output, wrapped];\r\n    address[] public outputToLp0Route;\r\n    address[] public outputToLp1Route;\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    constructor(\r\n        address _want,\r\n        uint256 _poolId,\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _strategist,\r\n        address _beefyFeeRecipient\r\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\r\n        want = _want;\r\n        lpToken0 = IUniswapV2Pair(want).token0();\r\n        lpToken1 = IUniswapV2Pair(want).token1();\r\n        poolId = _poolId;\r\n\r\n        if (lpToken0 == wrapped) {\r\n            outputToLp0Route = [output, wrapped];\r\n        } else if (lpToken0 != output) {\r\n            outputToLp0Route = [output, wrapped, lpToken0];\r\n        }\r\n\r\n        if (lpToken1 == wrapped) {\r\n            outputToLp1Route = [output, wrapped];\r\n        } else if (lpToken1 != output) {\r\n            outputToLp1Route = [output, wrapped, lpToken1];\r\n        }\r\n\r\n        _giveAllowances();\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal > 0) {\r\n            IMasterChef(masterchef).deposit(poolId, wantBal);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal < _amount) {\r\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n        if (tx.origin == owner() || paused()) {\r\n            IERC20(want).safeTransfer(vault, wantBal);\r\n        } else {\r\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\r\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\r\n        }\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() external whenNotPaused onlyEOA {\r\n        IMasterChef(masterchef).deposit(poolId, 0);\r\n        chargeFees();\r\n        addLiquidity();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toWrapped = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWrapped, 0, outputToWrappedRoute, address(this), block.timestamp);\r\n\r\n        uint256 wrappedBal = IERC20(wrapped).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = wrappedBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(msg.sender, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = wrappedBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n\r\n        uint256 strategistFee = wrappedBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(strategist, strategistFee);\r\n    }\r\n\r\n    // Adds liquidity to AMM and gets more LP tokens.\r\n    function addLiquidity() internal {\r\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\r\n\r\n        if (lpToken0 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\r\n        }\r\n\r\n        if (lpToken1 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\r\n        }\r\n\r\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\r\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\r\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\r\n    }\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool());\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // it calculates how much 'want' the strategy has working in the farm.\r\n    function balanceOfPool() public view returns (uint256) {\r\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\r\n        return _amount;\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        pause();\r\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\r\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, 0);\r\n        IERC20(output).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/BIFI/strategies/Ester/StrategyEsterLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyEsterLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wftm = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n    address constant public output = address(0x181F3F22C9a751E2ce673498A03E1FDFC0ebBFB6);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x78e9D247541ff7c365b50D2eE0defdd622016498);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWftmRoute = [output, wftm];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wftm) {\n            outputToLp0Route = [output, wftm];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wftm, lpToken0];\n        }\n\n        if (lpToken1 == wftm) {\n            outputToLp1Route = [output, wftm];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wftm, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWftm = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWftm, 0, outputToWftmRoute, address(this), block.timestamp);\n\n        uint256 wftmBal = IERC20(wftm).balanceOf(address(this));\n\n        uint256 callFeeAmount = wftmBal.mul(callFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wftmBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wftmBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Ester/StrategyEster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyEster is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wftm = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n    address constant public want = address(0x181F3F22C9a751E2ce673498A03E1FDFC0ebBFB6);\n\n    // Third party contracts\n    address constant public masterchef = address(0x78e9D247541ff7c365b50D2eE0defdd622016498);\n    uint256 constant public poolId = 2;\n\n    // Routes\n    address[] public wantToWftmRoute = [want, wftm];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    function beforeDeposit() external override {\n        harvest();\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() public whenNotPaused {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWftm = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWftm, 0, wantToWftmRoute, address(this), block.timestamp);\n\n        uint256 wftmBal = IERC20(wftm).balanceOf(address(this));\n\n        uint256 callFeeAmount = wftmBal.mul(callFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(tx.origin, callFeeAmount);\n\n        uint256 beefyFeeAmount = wftmBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wftmBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(strategist, strategistFee);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyVoidLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyVoidLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x3C44eAf8b4eAEF6e48Bfc18Ee92412BE0b395746);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xD72fF7178fb11141492Da457A1B3c4D5143b696c);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyPolyzapLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyPolyzapLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public usdc = address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    address constant public output = address(0xeb2778f74E5ee038E67AA6c77f0F0451ABd748FD);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xB93C082bCfCCf5BAeA0E0f0c556668E25A41B896);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWmaticRoute = [output, wmatic];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wmatic || lpToken0 == usdc) {\n            outputToLp0Route = [output, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wmatic, lpToken0];\n        }\n\n        if (lpToken1 == wmatic || lpToken1 == usdc) {\n            outputToLp1Route = [output, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wmatic, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // deposits only if nothing is deposited yet\n    function deposit() public whenNotPaused {\n        if (balanceOfPool() == 0) {\n            _deposit();\n        }\n    }\n\n    // puts the funds to work\n    function _deposit() internal whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        if (outputBal > 0) {\n            chargeFees();\n            addLiquidity();\n            _deposit();\n\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWmatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWmatic, 0, outputToWmaticRoute, address(this), block.timestamp);\n\n        uint256 wmaticBal = IERC20(wmatic).balanceOf(address(this));\n\n        uint256 callFeeAmount = wmaticBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        _deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyMemeFarmLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyMemeFarmLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x206340f3361404910F45cA0893980EF3f9b418ea);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xa0A4Ab8c15c5b7C9f0d73a23786B5B51BA2d5399);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyMasterChefPolygonLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyMasterChefPolygonLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wrapped = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public usdc = address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    address constant public output = address(0x05089C9EBFFa4F0AcA269e32056b1b36B37ED71b);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x34bc3D36845d8A7cA6964261FbD28737d0d6510f);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWrappedRoute = [output, usdc, wrapped];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == usdc) {\n            outputToLp0Route = [output, usdc];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, usdc, lpToken0];\n        }\n\n        if (lpToken1 == usdc) {\n            outputToLp1Route = [output, usdc];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, usdc, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWrapped = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWrapped, 0, outputToWrappedRoute, address(this), block.timestamp);\n\n        uint256 wrappedBal = IERC20(wrapped).balanceOf(address(this));\n\n        uint256 callFeeAmount = wrappedBal.mul(callFee).div(MAX_FEE);\n        IERC20(wrapped).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wrappedBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wrapped).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wrappedBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wrapped).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyIronPolygonTitan.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyIronPolygonTitan is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public want = address(0xaAa5B9e6c589642f98a1cDA99B9D024B8407285A); // titan\n    address constant public iron = address(0xD86b5923F3AD7b585eD81B448170ae026c65ae9a);\n    address constant public output = address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174); // usdc\n\n    // Third party contracts\n    address constant public masterchef = address(0xa37DD1f62661EB18c338f18Cf797cff8b5102d8e);\n    uint256 constant public poolId = 0;\n\n    // Routes\n    address[] public outputToWmaticRoute = [output, iron, want, wmatic];\n    address[] public outputToWantRoute = [output, iron, want];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWmatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWmatic, 0, outputToWmaticRoute, address(this), block.timestamp);\n\n        uint256 wmaticBal = IERC20(wmatic).balanceOf(address(this));\n\n        uint256 callFeeAmount = wmaticBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(tx.origin, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    // swap rewards to {want}\n    function swapRewards() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(outputBal, 0, outputToWantRoute, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyIronPolygonQuickLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyIronPolygonQuickLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    address constant public usdc = address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    address constant public output = address(0xaAa5B9e6c589642f98a1cDA99B9D024B8407285A);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x65430393358e55A658BcdE6FF69AB28cF1CbB77a);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWmaticRoute = [output, eth, wmatic];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == usdc) {\n            outputToLp0Route = [output, eth, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, eth, usdc, lpToken0];\n        }\n\n        if (lpToken1 == usdc) {\n            outputToLp1Route = [output, eth, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, eth, usdc, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWmatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWmatic, 0, outputToWmaticRoute, address(this), block.timestamp);\n\n        uint256 wmaticBal = IERC20(wmatic).balanceOf(address(this));\n\n        uint256 callFeeAmount = wmaticBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyIronPolygonLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyIronPolygonLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    address constant public iron = address(0xD86b5923F3AD7b585eD81B448170ae026c65ae9a);\n    address constant public output = address(0xaAa5B9e6c589642f98a1cDA99B9D024B8407285A);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xb444d596273C66Ac269C33c30Fbb245F4ba8A79d);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWmaticRoute = [output, wmatic];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wmatic || lpToken0 == iron) {\n            outputToLp0Route = [output, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wmatic, eth, lpToken0];\n        }\n\n        if (lpToken1 == wmatic || lpToken1 == iron) {\n            outputToLp1Route = [output, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wmatic, eth, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWmatic = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWmatic, 0, outputToWmaticRoute, address(this), block.timestamp);\n\n        uint256 wmaticBal = IERC20(wmatic).balanceOf(address(this));\n\n        uint256 callFeeAmount = wmaticBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyBlizzardLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Blizzard.Money.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyBlizzardLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case, xBLZD.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x9a946c3Cb16c08334b69aE249690C236Ebd5583E);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x367CdDA266ADa588d380C7B970244434e4Dde790);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     * {keeper} - Address used as an extra strat manager.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n    address public keeper;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     * {callFee} - 0.25% goes to whoever executes the harvest. Can be adjusted.\n     * {rewardsFee} - 3.25% goes to BIFI holders through the {rewards} pool. Adjusted by callFee changes.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_CALL_FEE   = 111;\n    uint constant public MAX_FEE        = 1000;\n    uint public callFee                 = 56;\n    uint public rewardsFee              = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest();\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     * Fees are not assessed if the Vault is paused.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Public harvest. Doesn't work when the strat is paused.\n     */\n    function harvest() external whenNotPaused {\n        _harvest();\n    }\n\n    /**\n     * @dev Harvest to keep the strat working while paused. Helpful in some cases.\n     */\n    function sudoHarvest() external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _harvest();\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function _harvest() internal gasThrottle {\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest();\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.25% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.25% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates address of the strat keeper.\n     * @param _keeper new keeper address.\n     */\n    function setKeeper(address _keeper) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        keeper = _keeper;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n        require(_fee < MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address of the token to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        require(_token != output, \"!output\");\n        require(_token != lpPair, \"!lpPair\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Complus/StrategyComLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Complus.\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyComLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wavax} - Required for liquidity routing when doing swaps.\n     * {com} - Token generated by staking our funds. In this case it's the COM token.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wavax = address(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n    address constant public com = address(0x3711c397B6c8F7173391361e27e67d72F252cAad);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - Complus router\n     * {masterchef} - Complus SudoSu contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter = address(0x78c18E6BE20df11f1f41b9635F3A18B8AD82dDD1);\n    address constant public masterchef = address(0xa329D806fbC80a14415588334ae4b205813C6BB2);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {treasury} - Address of the Beefy treasury. Rewards accumulate here and are then sent to BSC.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public treasury = address(0xA3e3Af161943CfB3941B631676134bb048739727);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 3.75% goes to BIFI holders through the {treasury}.\n     * {CALL_FEE} - 0.25% goes to whoever executes the harvest function as gas subsidy.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public CALL_FEE       = 55;\n    uint constant public TREASURY_FEE   = 833;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Complus.\n     * {comToWavaxRoute} - Route we take to get from {com} into {wavax}.\n     * {comToLp0Route} - Route we take to get from {com} into {lpToken0}.\n     * {comToLp1Route} - Route we take to get from {com} into {lpToken1}.\n     */\n    address[] public comToWavaxRoute = [com, wavax];\n    address[] public comToLp0Route;\n    address[] public comToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wavax) {\n            comToLp0Route = [com, wavax];\n        } else if (lpToken0 != com) {\n            comToLp0Route = [com, wavax, lpToken0];\n        }\n\n        if (lpToken1 == wavax) {\n            comToLp1Route = [com, wavax];\n        } else if (lpToken1 != com) {\n            comToLp1Route = [com, wavax, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(com).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {com}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChef(masterchef).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChef(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {com} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChef(masterchef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.25% -> Call Fee\n     * 3.75% -> Treasury fee\n     * 0.5% -> Strategist fee\n     */\n    function chargeFees() internal {\n        uint256 toWavax = IERC20(com).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWavax, 0, comToWavaxRoute, address(this), block.timestamp.add(600));\n\n        uint256 wavaxBal = IERC20(wavax).balanceOf(address(this));\n\n        uint256 treasuryFee = wavaxBal.mul(TREASURY_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(treasury, treasuryFee);\n\n        uint256 callFee = wavaxBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(msg.sender, callFee);\n\n        uint256 strategistFee = wavaxBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wavax).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {com} for {lpToken0}, {lpToken1} & {wavax} using Complus.\n     */\n    function addLiquidity() internal {\n        uint256 comHalf = IERC20(com).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != com) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(comHalf, 0, comToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != com) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(comHalf, 0, comToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(com).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(com).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Common/StrategyCommonChefSingle.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCommonChefSingle is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public native;\n    address public output;\n    address public want;\n\n    // Third party contracts\n    address public chef;\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToNativeRoute;\n    address[] public outputToWantRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _chef,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute,\n        address[] memory _outputToWantRoute\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n        chef = _chef;\n\n        output = _outputToNativeRoute[0];\n        native = _outputToNativeRoute[_outputToNativeRoute.length - 1];\n        outputToNativeRoute = _outputToNativeRoute;\n\n        outputToWantRoute = _outputToWantRoute;\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(chef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(chef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(chef).deposit(poolId, 0);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toNative = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toNative, 0, outputToNativeRoute, address(this), block.timestamp);\n\n        uint256 nativeBal = IERC20(native).balanceOf(address(this));\n\n        uint256 callFeeAmount = nativeBal.mul(callFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = nativeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = nativeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(native).safeTransfer(strategist, strategistFee);\n    }\n\n    // swap rewards to {want}\n    function swapRewards() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputBal, 0, outputToWantRoute, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(chef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(chef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(chef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(chef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(chef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Common/StrategyCommonChefLP.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCommonChefLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public native;\n    address public output;\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address public chef;\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToNativeRoute;\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _chef,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute,\n        address[] memory _outputToLp0Route,\n        address[] memory _outputToLp1Route\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n        chef = _chef;\n\n        output = _outputToNativeRoute[0];\n        native = _outputToNativeRoute[_outputToNativeRoute.length - 1];\n        outputToNativeRoute = _outputToNativeRoute;\n\n        // setup lp routing\n        lpToken0 = IUniswapV2Pair(want).token0();\n        outputToLp0Route = _outputToLp0Route;\n\n        lpToken1 = IUniswapV2Pair(want).token1();\n        outputToLp1Route = _outputToLp1Route;\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(chef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(chef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(chef).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toNative = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toNative, 0, outputToNativeRoute, address(this), block.timestamp);\n\n        uint256 nativeBal = IERC20(native).balanceOf(address(this));\n\n        uint256 callFeeAmount = nativeBal.mul(callFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = nativeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = nativeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(native).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(chef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(chef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(chef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(chef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(chef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Common/StrategyCommonChefBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChef.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\nabstract contract StrategyCommonChefBase is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public native;\n    address public output;\n    address public want;\n\n    // Third party contracts\n    address public chef;\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToNativeRoute;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _chef,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n        chef = _chef;\n\n        output = _outputToNativeRoute[0];\n        native = _outputToNativeRoute[_outputToNativeRoute.length - 1];\n        outputToNativeRoute = _outputToNativeRoute;\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChef(chef).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChef(chef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMasterChef(chef).deposit(poolId, 0);\n        chargeFees();\n        swapRewardForWant();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toNative = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toNative, 0, outputToNativeRoute, address(this), block.timestamp);\n\n        uint256 nativeBal = IERC20(native).balanceOf(address(this));\n\n        uint256 callFeeAmount = nativeBal.mul(callFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = nativeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = nativeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(native).safeTransfer(strategist, strategistFee);\n    }\n\n    // Swap output for more want tokens.\n    function swapRewardForWant() internal virtual;\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChef(chef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChef(chef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChef(chef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() private {\n        IERC20(want).safeApprove(chef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function giveAllowances() internal virtual {\n        _giveAllowances();\n    }\n\n    function _removeAllowances() private {\n        IERC20(want).safeApprove(chef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n    }\n\n    function removeAllowances() internal virtual {\n        _removeAllowances();\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Fry/StrategyFry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/fryworld/IDeepFryer.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming the FRIES token.\n * Fry.world is a yield optimizer that is allowing users to farm their token.\n * The strategy simply deposits whatever funds it receives from the vault into the DeepFryer,\n * which is clone of Sushiswap's MasterChef contract. Rewards generated in FRIES can regularly be harvested,\n * swapped for the original vault asset, and deposited again for compound farming.\n * This strat is currently compatible with: wBNB and BUSD. The token to use is configured with a constructor argument.\n */\n\ncontract StrategyFry {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {output} - Token generated by staking our funds. In this case it's the FRIES token.\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     */\n    address constant public output = address(0x393B312C01048b3ed2720bF1B090084C09e408A1);\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address  public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - AMM used to swap from {output} into {want}\n     * {deepFryer} - MasterChef modified contract. Where we deposit and withdraw the funds.\n     */\n    address  public unirouter = address(0xBf6527834dBB89cdC97A79FCD62E6c08B19F8ec0);\n    address constant public deepFryer = address(0x066d5544A0b05B19f08E45Dbc13758a3590386C4);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     Current implementation separates 5% for fees.\n     * {fee} - 4% goes to BIFI holders through the {rewards} pool.\n     * {callfee} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {withdrawalFee} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     */\n    uint public fee = 800;\n    uint public callfee = 200;\n    uint constant public max = 1000;\n\n    uint public withdrawalFee = 10;\n    uint constant public withdrawalMax = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens in Unswap clones.\n     * {swap2TokenRouting} - Route we take to get from {output} into {want}.\n     * {swap2WbnbRouting} - Route we take to get from {output} into {wbnb}.\n     * {want2WbnbRouting} - Route we take to get from {want} into {wbnb}.\n     */\n    address[] public swap2TokenRouting;\n    address[] public swap2WbnbRouting;\n    address[] public want2WbnbRouting;\n\n    // Convenience value for UIs to display the strat name. It is initialized on contract deploy.\n    string public getName;\n    // Should be set to the index of the {want} pool in the deepFryer. BUSD index is 1 and wBNB is 2.\n    uint public poolIndex;\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     */\n    constructor(address _want, address _vault, uint _poolIndex) {\n        want = _want;\n        vault = _vault;\n        poolIndex = _poolIndex;\n\n        getName = string(\n            abi.encodePacked(\"Beefy:Strategy:\",\n                abi.encodePacked(ERC20(want).name(),\" Fry World\"\n                )\n            ));\n\n        if (wbnb == want) {\n            swap2TokenRouting = [output,want];\n        } else {\n            swap2TokenRouting = [output,wbnb,want];\n        }\n        swap2WbnbRouting = [output,wbnb];\n        want2WbnbRouting = [want,wbnb];\n\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work. It gets called whenever someone deposits\n     * in the strategy's vault contract. It deposits whatever {want} it has available to\n     * farm FRIES in the deep fryer.\n     */\n    function deposit() public {\n        uint _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IERC20(want).safeApprove(deepFryer, 0);\n            IERC20(want).safeApprove(deepFryer, _want);\n            IDeepFryer(deepFryer).deposit(poolIndex, _want);\n        }\n    }\n\n    /**\n     * @dev It withdraws funds from fry and sents them back to the vault.\n     * Gets called when users withdraw from the parent vault.\n     */\n    function withdraw(uint _amount) external {\n        require(msg.sender == vault, \"!vault\");\n        uint _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        uint _fee = 0;\n        if (withdrawalFee > 0){\n            _fee = _amount.mul(withdrawalFee).div(withdrawalMax);\n        }\n\n        IERC20(want).safeTransfer(vault, _amount.sub(_fee));\n    }\n\n    /**\n     * @dev Internal function that manages the actual withdraw from the fry platform.\n     */\n    function _withdrawSome(uint256 _amount) internal returns (uint) {\n        IDeepFryer(deepFryer).withdraw(poolIndex, _amount);\n        return _amount;\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from fry's reward pool\n     * 2. It swaps the FRIES token for {want}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public {\n        require(!Address.isContract(msg.sender),\"!contract\");\n        IDeepFryer(deepFryer).deposit(poolIndex, 0);\n        doswap();\n        dosplit();\n        deposit();\n    }\n\n    /**\n     * @dev Swaps {output} for {want} using the established Uniswap clone.\n     */\n    function doswap() internal {\n        if (want == wbnb) {\n            uint256 _2token = IERC20(output).balanceOf(address(this));\n            IUniswapRouter(unirouter).swapExactTokensForTokens(_2token, 0, swap2TokenRouting, address(this), block.timestamp.add(600));\n        } else {\n            uint256 _2token = IERC20(output).balanceOf(address(this)).mul(95).div(100);\n            uint256 _2wbnb = IERC20(output).balanceOf(address(this)).mul(5).div(100);\n            uint256 _want = IERC20(want).balanceOf(address(this));\n            IUniswapRouter(unirouter).swapExactTokensForTokens(_2token, 0, swap2TokenRouting, address(this), block.timestamp.add(600));\n            IUniswapRouter(unirouter).swapExactTokensForTokens(_2wbnb, 0, swap2WbnbRouting, address(this), block.timestamp.add(600));\n            if (_want > 0) {\n                IUniswapRouter(unirouter).swapExactTokensForTokens(_want, 0, want2WbnbRouting, address(this), block.timestamp.add(600));\n            }\n        }\n    }\n\n    /**\n     * @dev Takes our 4% as system fees from the rewards. Takes out an extra 1% as\n     * gas subsidy and pays it out to the function caller.\n     */\n    function dosplit() internal {\n        uint _bal = IERC20(wbnb).balanceOf(address(this));\n        if (want == wbnb) {\n            _bal = IERC20(wbnb).balanceOf(address(this)).mul(5).div(100);\n        }\n\n        uint _fee = _bal.mul(fee).div(max);\n        uint _callfee = _bal.mul(callfee).div(max);\n        IERC20(wbnb).safeTransfer(rewards, _fee);\n        IERC20(wbnb).safeTransfer(msg.sender, _callfee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in fry.\n     */\n    function balanceOf() public view returns (uint) {\n        return balanceOfWant()\n               .add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in fry's DeepFryer.\n     */\n    function balanceOfPool() public view returns (uint) {\n        (uint _amount, ) = IDeepFryer(deepFryer).userInfo(poolIndex, address(this));\n        return _amount;\n    }\n}"
    },
    "contracts/BIFI/interfaces/fryworld/IDeepFryer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IDeepFryer {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function pendingFries(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint, uint);\n}\n\n"
    },
    "contracts/BIFI/strategies/Ellipsis/StrategyEllipsisRen.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ellipsis/IEps2LP.sol\";\nimport \"../../interfaces/ellipsis/ILpStaker.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming RenBTC LP on Ellipsis.\n */\ncontract StrategyEllipsisRen is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, btcb} - Required for liquidity routing when doing swaps.\n     * {eps} - Token generated by staking our funds. In this case it's the EPS token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. btcEPS\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public btcb = address(0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c);\n    address constant public eps  = address(0xA7f552078dcC247C2684336020c03648500C6d9F);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public want = address(0x2a435Ecb3fcC0E316492Dc1cdd62d0F189be5640);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingPool} - LpTokenStaker contract\n     * {feeDistribution} - MultiFeeDistribution contract\n     * {poolLP} - RenBTC LP contract to deposit renBTC/BTCB and mint {want}\n     * {poolId} - LpTokenStaker pool id\n     */\n    address constant public unirouter       = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingPool     = address(0xcce949De564fE60e7f96C85e55177F8B9E4CF61b);\n    address constant public feeDistribution = address(0x4076CC26EFeE47825917D0feC3A79d0bB9a6bB5c);\n    address constant public poolLp          = address(0x2477fB288c5b4118315714ad3c7Fd7CC69b00bf9);\n    uint8 constant public poolId = 3;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {epsToWbnbRoute} - Route we take to go from {eps} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {epsToBtcbRoute} - Route we take to get from {eps} into {btcb}.\n     */\n    address[] public epsToWbnbRoute  = [eps, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public epsToBtcbRoute  = [eps, wbnb, btcb];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(btcb).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the Pool to farm {eps}\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            ILpStaker(stakingPool).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {want} from the Pool.\n     * The available {want} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            ILpStaker(stakingPool).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Pool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {eps} token for {btcb}.\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender, \"!contract\");\n\n        uint256[] memory pids = new uint256[](1);\n        pids[0] = poolId;\n        ILpStaker(stakingPool).claim(pids);\n        IMultiFeeDistribution(feeDistribution).exit();\n\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(eps).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, epsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {eps} rewards earned for {btcb} and adds to Eps LP.\n     */\n    function swapRewards() internal {\n        uint256 epsBal = IERC20(eps).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(epsBal, 0, epsToBtcbRoute, address(this), block.timestamp.add(600));\n\n        uint256 btcbBal = IERC20(btcb).balanceOf(address(this));\n        uint256[2] memory amounts = [btcbBal, 0];\n        IEps2LP(poolLp).add_liquidity(amounts, 0);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the Pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the Pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ILpStaker(stakingPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(stakingPool, 0);\n        IERC20(eps).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(btcb).safeApprove(poolLp, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(btcb).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/common/IMultiFeeDistribution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMultiFeeDistribution {\n    function totalBalance(address user) view external returns (uint256);\n    function stake(uint256 amount, bool lock) external;\n    function withdraw(uint256 amount) external;\n    function getReward() external;\n    function exit() external;\n}"
    },
    "contracts/BIFI/interfaces/ellipsis/IEps2LP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IEps2LP {\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external;\n}"
    },
    "contracts/BIFI/interfaces/ellipsis/ILpStaker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ILpStaker {\n    function poolInfo(uint256 _pid) external view returns (address, uint256, uint256, uint256, uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function claimableReward(uint256 _pid, address _user) external view returns (uint256);\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function emergencyWithdraw(uint256 _pid) external;\n    function claim(uint256[] calldata _pids) external;\n}"
    },
    "contracts/BIFI/strategies/Froyo/StrategyFroyoLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ellipsis/ILpStaker.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyFroyoLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wftm = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n    address constant public output = address(0xA92d41Ab8eFeE617d80a829CD9F5683c5F793ADA);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public stakingPool     = address(0x93b1531Ca2d6595e6bEE8bd3d306Fcdad5775CDE);\n    address constant public feeDistribution = address(0xBcd49db69b9eda8c02c8963ED39b1f14a54BF405);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWftmRoute = [output, wftm];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wftm) {\n            outputToLp0Route = [output, wftm];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wftm, lpToken0];\n        }\n\n        if (lpToken1 == wftm) {\n            outputToLp1Route = [output, wftm];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wftm, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            ILpStaker(stakingPool).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            ILpStaker(stakingPool).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        uint256[] memory pids = new uint256[](1);\n        pids[0] = poolId;\n        ILpStaker(stakingPool).claim(pids);\n        IMultiFeeDistribution(feeDistribution).exit();\n\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWftm = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWftm, 0, outputToWftmRoute, address(this), block.timestamp);\n\n        uint256 wftmBal = IERC20(wftm).balanceOf(address(this));\n\n        uint256 callFeeAmount = wftmBal.mul(callFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wftmBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wftmBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ILpStaker(stakingPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(stakingPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(stakingPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Froyo/StrategyFroyo3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ellipsis/IEpsLP.sol\";\nimport \"../../interfaces/ellipsis/ILpStaker.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyFroyo3Pool is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wftm = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n    address constant public output = address(0xA92d41Ab8eFeE617d80a829CD9F5683c5F793ADA);\n    address constant public dai = address(0x8D11eC38a3EB5E956B052f67Da8Bdc9bef8Abf3E);\n    address constant public want = address(0x4f85Bbf3B0265DCEd4Ec72ebD0358ccCf190F1B3);\n\n    // Third party contracts\n    address constant public stakingPool     = address(0x93b1531Ca2d6595e6bEE8bd3d306Fcdad5775CDE);\n    address constant public feeDistribution = address(0xBcd49db69b9eda8c02c8963ED39b1f14a54BF405);\n    address constant public poolLp          = address(0x83E5f18Da720119fF363cF63417628eB0e9fd523);\n    uint8 constant public poolId = 1;\n\n    // Routes\n    address[] public outputToWftmRoute = [output, wftm];\n    address[] public outputToDaiRoute = [output, wftm, dai];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            ILpStaker(stakingPool).deposit(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            ILpStaker(stakingPool).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        uint256[] memory pids = new uint256[](1);\n        pids[0] = poolId;\n        ILpStaker(stakingPool).claim(pids);\n        IMultiFeeDistribution(feeDistribution).exit();\n\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWftm = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWftm, 0, outputToWftmRoute, address(this), block.timestamp);\n\n        uint256 wftmBal = IERC20(wftm).balanceOf(address(this));\n\n        uint256 callFeeAmount = wftmBal.mul(callFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wftmBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wftmBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wftm).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputBal, 0, outputToDaiRoute, address(this), block.timestamp);\n\n        uint256 daiBal = IERC20(dai).balanceOf(address(this));\n        uint256[3] memory amounts = [0, daiBal, 0];\n        IEpsLP(poolLp).add_liquidity(amounts, 0);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ILpStaker(stakingPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(stakingPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n        IERC20(dai).safeApprove(poolLp, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(stakingPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(dai).safeApprove(poolLp, 0);\n    }\n}"
    },
    "contracts/BIFI/interfaces/ellipsis/IEpsLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IEpsLP {\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;\n}"
    },
    "contracts/BIFI/strategies/Ellipsis/StrategyEllipsis3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ellipsis/IEpsLP.sol\";\nimport \"../../interfaces/ellipsis/ILpStaker.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming 3Pool on Ellipsis.\n */\ncontract StrategyEllipsis3Pool is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {eps} - Token generated by staking our funds. In this case it's the EPS token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. 3eps BUSD/USDT/USDC\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public eps  = address(0xA7f552078dcC247C2684336020c03648500C6d9F);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public want = address(0xaF4dE8E872131AE328Ce21D909C74705d3Aaf452);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingPool} - LpTokenStaker contract\n     * {feeDistribution} - MultiFeeDistribution contract\n     * {poolLP} - 3Pool LP contract to deposit BUSD/USDC/USDT and mint {want}\n     * {poolId} - LpTokenStaker pool id\n     */\n    address constant public unirouter       = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingPool     = address(0xcce949De564fE60e7f96C85e55177F8B9E4CF61b);\n    address constant public feeDistribution = address(0x4076CC26EFeE47825917D0feC3A79d0bB9a6bB5c);\n    address constant public poolLp          = address(0x160CAed03795365F3A589f10C379FfA7d75d4E76);\n    uint8 constant public poolId = 1;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {epsToWbnbRoute} - Route we take to go from {eps} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {epsToBusdRoute} - Route we take to get from {eps} into {busd}.\n     */\n    address[] public epsToWbnbRoute  = [eps, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public epsToBusdRoute  = [eps, wbnb, busd];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the Pool to farm {eps}\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            ILpStaker(stakingPool).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {want} from the Pool.\n     * The available {want} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            ILpStaker(stakingPool).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Pool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {eps} token for {busd}.\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        uint256[] memory pids = new uint256[](1);\n        pids[0] = poolId;\n        ILpStaker(stakingPool).claim(pids);\n        IMultiFeeDistribution(feeDistribution).exit();\n\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(eps).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, epsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {eps} rewards earned for {busd} and adds to 3Pool LP.\n     */\n    function swapRewards() internal {\n        uint256 epsBal = IERC20(eps).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(epsBal, 0, epsToBusdRoute, address(this), block.timestamp.add(600));\n\n        uint256 busdBal = IERC20(busd).balanceOf(address(this));\n        uint256[3] memory amounts = [busdBal, 0, 0];\n        IEpsLP(poolLp).add_liquidity(amounts, 0);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the Pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the Pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ILpStaker(stakingPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(stakingPool, 0);\n        IERC20(eps).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(busd).safeApprove(poolLp, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Ellipsis/StrategyEllipsisSingleAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyEllipsisSingleAsset is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56); // busd\n    address public want; // eps\n\n    // Third party contracts\n    address public rewardPool;\n\n    // Routes\n    address[] public outputToWantRoute;\n    address[] public outputToWbnbRoute = [output, wbnb];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        rewardPool = _rewardPool;\n\n        outputToWantRoute = [output, wbnb, want];\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMultiFeeDistribution(rewardPool).stake(wantBal, false);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMultiFeeDistribution(rewardPool).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMultiFeeDistribution(rewardPool).getReward();\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toBnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toBnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // swap rewards to {want}\n    function swapRewards() internal {\n        uint256 outputBalance = IERC20(output).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputBalance, 0, outputToWantRoute, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IMultiFeeDistribution(rewardPool).totalBalance(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMultiFeeDistribution(rewardPool).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMultiFeeDistribution(rewardPool).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Ellipsis/StrategyEllipsisFUsdt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ellipsis/IFUsdtLP.sol\";\nimport \"../../interfaces/ellipsis/ILpStaker.sol\";\nimport \"../../interfaces/ellipsis/IRewardToken.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming fUSDT LP on Ellipsis.\n */\ncontract StrategyEllipsisFUsdt is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {eps} - Token generated by staking our funds. In this case it's the EPS token.\n     * {ice} - Token generated by staking our funds. In this case it's the ICE token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. fusdt3EPS\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public eps  = address(0xA7f552078dcC247C2684336020c03648500C6d9F);\n    address constant public ice  = address(0xf16e81dce15B08F326220742020379B855B87DF9);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public want = address(0x373410A99B64B089DFE16F1088526D399252dacE);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingPool} - LpTokenStaker contract\n     * {feeDistribution} - MultiFeeDistribution contract\n     * {poolLP} - fUSDT LP contract to deposit fUSDT/BUSD/USDC/USDT and mint {want}\n     * {poolId} - LpTokenStaker pool id\n     */\n    address constant public unirouter       = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingPool     = address(0xcce949De564fE60e7f96C85e55177F8B9E4CF61b);\n    address constant public feeDistribution = address(0x4076CC26EFeE47825917D0feC3A79d0bB9a6bB5c);\n    address constant public poolLp          = address(0xf17814d515d3128753befd56cCeCEC2a0A41015F);\n    uint8 constant public poolId = 2;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {epsToWbnbRoute} - Route we take to go from {eps} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {epsToBusdRoute} - Route we take to get from {eps} into {busd}.\n     * {iceToEpsRoute} - Route we take to get from {ice} into {eps}.\n     */\n    address[] public epsToWbnbRoute  = [eps, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public epsToBusdRoute  = [eps, wbnb, busd];\n    address[] public iceToEpsRoute   = [ice, wbnb, eps];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(ice).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the Pool to farm {eps}\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            ILpStaker(stakingPool).deposit(poolId, wantBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {want} from the Pool.\n     * The available {want} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            ILpStaker(stakingPool).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Pool.\n     * 1. It claims additional rewards for fUSDT LP.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {eps} token for {busd}.\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender, \"!contract\");\n\n        uint256[] memory pids = new uint256[](1);\n        pids[0] = poolId;\n        ILpStaker(stakingPool).claim(pids);\n        IMultiFeeDistribution(feeDistribution).exit();\n\n        IRewardToken(want).getReward();\n        convertAdditionalRewards();\n\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Converts additional rewards tokens to {eps}\n     * It swaps {ice} for {eps}\n     */\n    function convertAdditionalRewards() internal {\n        uint256 iceBal = IERC20(ice).balanceOf(address(this));\n        if (iceBal > 0) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(iceBal, 0, iceToEpsRoute, address(this), block.timestamp.add(600));\n        }\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(eps).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, epsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {eps} rewards earned for {busd} and adds to Eps LP.\n     */\n    function swapRewards() internal {\n        uint256 epsBal = IERC20(eps).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(epsBal, 0, epsToBusdRoute, address(this), block.timestamp.add(600));\n\n        uint256 busdBal = IERC20(busd).balanceOf(address(this));\n        uint256[4] memory amounts = [0, busdBal, 0, 0];\n        IFUsdtLP(poolLp).add_liquidity(amounts, 0);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the Pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the Pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ILpStaker(stakingPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(stakingPool, 0);\n        IERC20(eps).safeApprove(unirouter, 0);\n        IERC20(ice).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(busd).safeApprove(poolLp, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(ice).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(poolLp, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/ellipsis/IFUsdtLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IFUsdtLP {\n    function add_liquidity(uint256[4] memory amounts, uint256 min_mint_amount) external;\n}"
    },
    "contracts/BIFI/interfaces/ellipsis/IRewardToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IRewardToken {\n    function getReward() external;\n}"
    },
    "contracts/BIFI/strategies/Ellipsis/StrategyEllipsisCakeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../../interfaces/ellipsis/ILpStaker.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools on Ellipsis.\n */\ncontract StrategyEllipsisCakeLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {eps} - Token generated by staking our funds. In this case it's the EPS token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public eps  = address(0xA7f552078dcC247C2684336020c03648500C6d9F);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingPool} - LpTokenStaker contract\n     * {feeDistribution} - MultiFeeDistribution contract\n     * {poolId} - LpTokenStaker pool id\n     */\n    address constant public unirouter       = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingPool     = address(0xcce949De564fE60e7f96C85e55177F8B9E4CF61b);\n    address constant public feeDistribution = address(0x4076CC26EFeE47825917D0feC3A79d0bB9a6bB5c);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {epsToWbnbRoute} - Route we take to go from {eps} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     * {epsToLp0Route} - Route we take to get from {eps} into {lpToken0}.\n     * {epsToLp1Route} - Route we take to get from {eps} into {lpToken1}.\n     */\n    address[] public epsToWbnbRoute  = [eps, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public epsToLp0Route;\n    address[] public epsToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            epsToLp0Route = [eps, wbnb];\n        } else if (lpToken0 != eps) {\n            epsToLp0Route = [eps, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            epsToLp1Route = [eps, wbnb];\n        } else if (lpToken1 != eps) {\n            epsToLp1Route = [eps, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the Pool to farm {eps}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            ILpStaker(stakingPool).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the Pool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            ILpStaker(stakingPool).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the Pool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {eps} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        uint256[] memory pids = new uint256[](1);\n        pids[0] = poolId;\n        ILpStaker(stakingPool).claim(pids);\n        IMultiFeeDistribution(feeDistribution).exit();\n\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(eps).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, epsToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {eps} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 epsHalf = IERC20(eps).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != eps) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(epsHalf, 0, epsToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != eps) {\n            IUniswapRouter(unirouter).swapExactTokensForTokens(epsHalf, 0, epsToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the Pool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the Pool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ILpStaker(stakingPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Pool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ILpStaker(stakingPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(stakingPool, 0);\n        IERC20(eps).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(stakingPool, type(uint).max);\n        IERC20(eps).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/strategies/Adamant/AddySingleAssetStrat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMultiFeeDistribution.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract AddySingleAssetStrat is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    address constant public matic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public quick = address(0x831753DD7087CaC61aB5644b308642cc1c33Dc13);\n    address public want;\n\n    // Third party contracts\n    address public rewardPool;\n\n    // Routes\n    address[] public quickToAddyRoute;\n    address[] public quickToMaticRoute = [quick, matic];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _rewardPool,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        rewardPool = _rewardPool;\n\n        quickToAddyRoute = [quick, eth, want];\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMultiFeeDistribution(rewardPool).stake(wantBal, false);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMultiFeeDistribution(rewardPool).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMultiFeeDistribution(rewardPool).getReward();\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toMatic = IERC20(quick).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toMatic, 0, quickToMaticRoute, address(this), block.timestamp);\n\n        uint256 maticBal = IERC20(matic).balanceOf(address(this));\n\n        uint256 callFeeAmount = maticBal.mul(callFee).div(MAX_FEE);\n        IERC20(matic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = maticBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(matic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = maticBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(matic).safeTransfer(strategist, strategistFee);\n    }\n\n    // swap rewards to {want}\n    function swapRewards() internal {\n        uint256 quickBalance = IERC20(quick).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(quickBalance, 0, quickToAddyRoute, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IMultiFeeDistribution(rewardPool).totalBalance(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMultiFeeDistribution(rewardPool).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMultiFeeDistribution(rewardPool).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, type(uint256).max);\n        IERC20(quick).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewardPool, 0);\n        IERC20(quick).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategySatisLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChefReferrer.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategySatisLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x8fda94079913CB921D065Ed9c004Afb43e1f900e);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x2EaB54f9f57057B0C213579c104e6f1834e38B26);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    // Address of the BeefyFinance treasury\n    address constant public treasury = address(0x37EA21Cb5e080C27a47CAf767f24a8BF7Fcc7d4d);\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChefReferrer(masterchef).deposit(poolId, wantBal, treasury);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChefReferrer(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChefReferrer(masterchef).deposit(poolId, 0, address(0));\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChefReferrer(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/interfaces/common/IMasterChefReferrer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMasterChefReferrer {\n    function deposit(uint256 _pid, uint256 _amount, address referrer) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyThunderLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IMasterChefReferrer.sol\";\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in ThunderSwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyThunderLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the TNDR token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x7Cc46141AB1057b1928de5Ad5Ee78Bb37eFC4868);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - Thunder MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0xa7bfBEFbE923dcF6EEfF355c22520395670b684E);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMasterChefReferrer(masterchef).deposit(poolId, pairBal, treasury);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMasterChefReferrer(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMasterChefReferrer(masterchef).deposit(poolId, 0, address(0));\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChefReferrer(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategyPantherLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChefReferrer.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyPantherLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x1f546aD641B56b86fD9dCEAc473d1C7a357276B7);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x058451C62B96c594aD984370eDA8B6FD7197bbd4);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    // Address of the launchpool treasury\n    address constant public treasury = address(0x804b1b97Ce28Cf55991abf8c29811FA1cEB669B6);\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb || lpToken0 == busd) {\n            outputToLp0Route = [output, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb || lpToken1 == busd) {\n            outputToLp1Route = [output, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChefReferrer(masterchef).deposit(poolId, wantBal, treasury);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChefReferrer(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChefReferrer(masterchef).deposit(poolId, 0, address(0));\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        if (outputBal > 0) {\n            chargeFees();\n            addLiquidity();\n            deposit();\n\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChefReferrer(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyGarudaLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChefReferrer.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyGarudaLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public usdc = address(0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d);\n    address constant public usdt = address(0x55d398326f99059fF775485246999027B3197955);\n    address constant public output = address(0x854086dC841e1bfae50Cb615bF41f55BF432a90b);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xf6afB97aC5eAfAd60d3ad19c2f85E0Bd6b7eAcCf);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    // Address of the BeefyFinance treasury\n    address constant public treasury = address(0x37EA21Cb5e080C27a47CAf767f24a8BF7Fcc7d4d);\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb || lpToken0 == usdc || lpToken0 == usdt) {\n            outputToLp0Route = [output, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb || lpToken1 == usdc || lpToken1 == usdt) {\n            outputToLp1Route = [output, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChefReferrer(masterchef).deposit(poolId, wantBal, treasury);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChefReferrer(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChefReferrer(masterchef).deposit(poolId, 0, address(0));\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        if (outputBal > 0) {\n            chargeFees();\n            addLiquidity();\n            deposit();\n\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChefReferrer(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyGaruda.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChefReferrer.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyGaruda is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x854086dC841e1bfae50Cb615bF41f55BF432a90b);\n\n    // Third party contracts\n    address constant public masterchef = address(0xf6afB97aC5eAfAd60d3ad19c2f85E0Bd6b7eAcCf);\n    uint256 constant public poolId = 6;\n\n    // Routes\n    address[] public wantToWbnbRoute = [want, wbnb];\n\n    // Address of the BeefyFinance treasury\n    address constant public treasury = address(0x37EA21Cb5e080C27a47CAf767f24a8BF7Fcc7d4d);\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChefReferrer(masterchef).deposit(poolId, wantBal, treasury);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChefReferrer(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    function beforeDeposit() external override {\n        harvest();\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() public whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IMasterChefReferrer(masterchef).deposit(poolId, 0, address(0));\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(tx.origin, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChefReferrer(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyDumplingLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/common/IMasterChefReferrer.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyDumplingLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x13F6751ba11337BC67aBBdAd638a56194ee133B8);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0xe2e643B051ABCFBE735b99eE00b2dbFd3a7BD798);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    // Address of the BeefyFinance treasury\n    address constant public treasury = address(0x37EA21Cb5e080C27a47CAf767f24a8BF7Fcc7d4d);\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb || lpToken0 == busd) {\n            outputToLp0Route = [output, lpToken0];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb || lpToken1 == busd) {\n            outputToLp1Route = [output, lpToken1];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMasterChefReferrer(masterchef).deposit(poolId, wantBal, treasury);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMasterChefReferrer(masterchef).withdraw(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IMasterChefReferrer(masterchef).deposit(poolId, 0, address(0));\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        if (outputBal > 0) {\n            chargeFees();\n            addLiquidity();\n            deposit();\n\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(unirouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMasterChefReferrer(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMasterChefReferrer(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyNuts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/nuts/INutsStaking.sol\";\n\n/**\n * @dev Strategy to farm NUTS in Squirrel finance.\n */\ncontract StrategyNuts is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault. NUTS\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0x8893D5fA71389673C5c4b9b3cb4EE1ba71207556);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingPool} - NutsStaking contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingPool = address(0x45C12738C089224F66CD7A1c85301d79C45E2dEd);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.0% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 667;\n    uint constant public CALL_FEE       = 83;\n    uint constant public TREASURY_FEE   = 167;\n    uint constant public STRATEGIST_FEE = 83;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {wantToWbnbRoute} - Route we take to go from {want} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public wantToWbnbRoute = [want, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     * @param _vault Address to initialize {vault}\n     * @param _strategist Address to initialize {strategist}\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {want} in the NutsStaking to earn rewards in {want}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            INutsStaking(stakingPool).depositFor(address(this), wantBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws {want} from the NutsStaking and sends it to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            INutsStaking(stakingPool).cashout(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the NutsStaking\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        INutsStaking(stakingPool).claimYield();\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.0% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 4.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the NutsStaking.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in the NutsStaking\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return INutsStaking(stakingPool).balances(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        INutsStaking(stakingPool).cashout(balanceOfPool());\n\n        uint256 wanBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wanBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the NutsStaking, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        INutsStaking(stakingPool).cashout(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(stakingPool, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(stakingPool, type(uint).max);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/interfaces/nuts/INutsStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface INutsStaking {\n    function balances(address account) external view returns (uint256);\n    function depositFor(address player, uint256 amount) external;\n    function cashout(uint256 amount) external;\n    function claimYield() external;\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyNaut.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/pancake/ISmartChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming NAUT-BNB in Ape RewardPool.\n */\ncontract StrategyNaut is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the NAUT token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x05B339B0A346bF01f851ddE47a5d485c34FE220c);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public lpPair = address(0x288EA5437c7aaD045a393cee2F41E548df24d1C8);\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {aperouter} - ApeSwap unirouter\n     * {rewardape} - RewardApe contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public aperouter  = address(0xC0788A3aD43d79aa53B09c2EaCc313A787d1d607);\n    address constant public rewardape  = address(0x114d54e18eb4A7Dc9bB8280e283E5799D4188E3f);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using ApeSwap and PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(rewardape, type(uint).max);\n        IERC20(output).safeApprove(aperouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(aperouter, 0);\n        IERC20(lpToken0).safeApprove(aperouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(aperouter, 0);\n        IERC20(lpToken1).safeApprove(aperouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the RewardApe to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            ISmartChef(rewardape).deposit(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the RewardApe.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            ISmartChef(rewardape).withdraw(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the RewardApe.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        ISmartChef(rewardape).deposit(0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouter(aperouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using ApeRouter.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouter(aperouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouter(aperouter).swapExactTokensForTokensSupportingFeeOnTransferTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(aperouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the SmartChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the SmartChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ISmartChef(rewardape).userInfo(address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ISmartChef(rewardape).emergencyWithdraw();\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the SmartChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ISmartChef(rewardape).emergencyWithdraw();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(rewardape, 0);\n        IERC20(output).safeApprove(aperouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(aperouter, 0);\n        IERC20(lpToken1).safeApprove(aperouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(rewardape, type(uint).max);\n        IERC20(output).safeApprove(aperouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(aperouter, 0);\n        IERC20(lpToken0).safeApprove(aperouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(aperouter, 0);\n        IERC20(lpToken1).safeApprove(aperouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/pancake/ISmartChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ISmartChef {\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _amount) external;\n    function pendingReward(address _user) external view returns (uint256);\n    function userInfo(address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw() external;\n    function rewardToken() external view returns (address);\n}"
    },
    "contracts/BIFI/strategies/Cake/StrategySyrup.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/pancake/ISmartChef.sol\";\n\n/**\n * @title Strategy Syrup\n * @author sirbeefalot & superbeefyboy\n * @dev Implementation of a strategy to get yields from farming a Syrup pool at Pancakeswap.\n *\n * The strategy simply deposits whatever funds it receives from the vault into the configured pool (SmartChef).\n * Rewards generated by the SmartChef can be harvested, swapped for more CAKE, and deposited again for compound farming.\n * This strat is currently compatible with all Syrup pools.\n */\n\ncontract StrategySyrup is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {cake} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {output} - Token generated by staking CAKE.\n     */\n    address constant public wbnb  = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public cake  = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address constant public bifi  = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public output;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {smartchef} - SmartChef contract. Stake CAKE, get {output} token.\n     */\n    address constant public unirouter = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address public smartchef;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.5% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE = 667;\n    uint constant public CALL_FEE = 83;\n    uint constant public TREASURY_FEE = 250;\n    uint constant public MAX_FEE = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToCakeRoute} - Route we take to get from {output} into {cake}.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public outputToCakeRoute;\n    address[] public outputToWbnbRoute;\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Initializes the strategy\n     * @param _smartchef The SmartChef to use\n     * @param _vault Address of the parent vault\n     */\n    constructor(address _smartchef, address _vault) {\n        smartchef = _smartchef;\n        vault = _vault;\n        output = ISmartChef(smartchef).rewardToken();\n\n        outputToCakeRoute = [output, wbnb, cake];\n        outputToWbnbRoute = [output, wbnb];\n\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(cake).safeApprove(smartchef, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {cake} in the SmartChef to farm {output}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 cakeBal = IERC20(cake).balanceOf(address(this));\n\n        if (cakeBal > 0) {\n            ISmartChef(smartchef).deposit(cakeBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws {cake} from the SmartChef and returns it to the vault.\n     * @param _amount How much {cake} to withdraw\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 cakeBal = IERC20(cake).balanceOf(address(this));\n\n        if (cakeBal < _amount) {\n            ISmartChef(smartchef).withdraw(_amount.sub(cakeBal));\n            cakeBal = IERC20(cake).balanceOf(address(this));\n        }\n\n        if (cakeBal > _amount) {\n            cakeBal = _amount;\n        }\n\n        if (tx.origin == owner()) {\n            IERC20(cake).safeTransfer(vault, cakeBal);\n        } else {\n            uint256 _fee = cakeBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(cake).safeTransfer(vault, cakeBal.sub(_fee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the SmartChef\n     * 2. It swaps the {output} token for {cake}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        ISmartChef(smartchef).deposit(0);\n        chargeFees();\n        swapRewards();\n        deposit();\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.5% -> Treasury fee\n     * 4% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Swaps whatever {output} it has for more cake.\n     */\n    function swapRewards() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputBal, 0, outputToCakeRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {cake} held by the strat.\n     * It takes into account both funds at hand and funds allocated in the SmartChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfCake().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {cake} the contract holds.\n     */\n    function balanceOfCake() public view returns (uint256) {\n        return IERC20(cake).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {cake} the strategy has allocated in the SmartChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ISmartChef(smartchef).userInfo(address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ISmartChef(smartchef).emergencyWithdraw();\n\n        uint256 cakeBal = IERC20(cake).balanceOf(address(this));\n        IERC20(cake).transfer(vault, cakeBal);\n    }\n\n    /**\n     * @dev Withdraws all funds from the SmartChef, leaving rewards behind.\n     */\n    function panic() external onlyOwner {\n        pause();\n        ISmartChef(smartchef).emergencyWithdraw();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(cake).safeApprove(smartchef, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(cake).safeApprove(smartchef, type(uint).max);\n    }\n}"
    },
    "contracts/BIFI/strategies/Cake/StrategyCakeSmart.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/pancake/ISmartChef.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from selectively farming the most profitable CAKE pool.\n * PancakeSwap is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate.\n *\n * The strategy simply deposits whatever funds it receives from the vault into the selected pool (SmartChef).\n * Rewards generated by the SmartChef can be harvested, swapped for more CAKE, and deposited again for compound farming.\n * When harvesting you can select a poolId to deposit the funds in any whitelisted pool after each harvest.\n *\n * Whitelisted pools can be added by the owner with a delay of 2 days before being approved as a harvest target.\n */\n\ncontract StrategyCakeSmart is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Pool Management Data Structures\n     * Pool - Struct for pools that have been approved and are ready to be used.\n     * UpcomingPool - Struct for pools that have not been approved. Have to wait for {approvalDelay} after their proposedTime.\n     */\n    struct Pool {\n        address smartchef;\n        address output;\n        bool enabled;\n    }\n\n    struct UpcomingPool {\n        address smartchef;\n        uint256 proposedTime;\n        bool addedToPools;\n    }\n\n    /**\n     * @dev Pool Management Variables\n     * pools - Holds all the pools that have been approved for harvest. Pools can be enabled/disabled by owner.\n     * upcomingPools - Holds the pools that have been proposed to eventually be approved. Once approved, they get flagged and not deleted.\n     * currentPool - The pool where funds are currently working.\n     * approvalDelay - Seconds that have to pass before an upcoming pool can be approved.\n     */\n    Pool[] public pools;\n    UpcomingPool[] public upcomingPools;\n    uint8 public currentPool;\n    uint256 public approvalDelay;\n\n    /**\n     * @dev Pool Management Events\n     * AddUpcomingPool - fired when a new pool is initially proposed.\n     * ApprovePool - fired when the pool is made available for harvesting.\n     */\n    event AddUpcomingPool(address smartchef);\n    event ApprovePool(address smartchef);\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {cake} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {output} - Token generated by staking CAKE. Changes depending on the selected pool.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public output;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {smartchef} - Currently selected SmartChef contract. Stake CAKE, get {output} token.\n     */\n    address constant public unirouter = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address public smartchef;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 6% for fees.\n     *\n     * {REWARDS_FEE} - 4% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 1.5% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE = 667;\n    uint constant public CALL_FEE = 83;\n    uint constant public TREASURY_FEE = 250;\n    uint constant public MAX_FEE = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToCakeRoute} - Route we take to get from {output} into {cake}.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public outputToCakeRoute;\n    address[] public outputToWbnbRoute;\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with a pool whitelist and vault that it will use.\n     */\n    constructor(address _vault, uint256 _approvalDelay) {\n        vault = _vault;\n        approvalDelay = _approvalDelay;\n\n        _approvePool(0x90F995b9d46b32c4a1908A8c6D0122e392B3Be97);\n        _approvePool(0xdc8c45b7F3747Ca9CaAEB3fa5e0b5FCE9430646b);\n        _approvePool(0x9c4EBADa591FFeC4124A7785CAbCfb7068fED2fb);\n\n        updatePoolInfo(0);\n\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits cake in the selected smartchef to farm {output}.\n     */\n    function deposit() public whenNotPaused {\n        uint256 cakeBal = IERC20(cake).balanceOf(address(this));\n\n        if (cakeBal > 0) {\n            IERC20(cake).safeApprove(smartchef, 0);\n            IERC20(cake).safeApprove(smartchef, cakeBal);\n            ISmartChef(smartchef).deposit(cakeBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {cake} from the SmartChef and returns it to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 cakeBal = IERC20(cake).balanceOf(address(this));\n\n        if (cakeBal < _amount) {\n            ISmartChef(smartchef).withdraw(_amount.sub(cakeBal));\n            cakeBal = IERC20(cake).balanceOf(address(this));\n        }\n\n        if (cakeBal > _amount) {\n            cakeBal = _amount;\n        }\n\n        uint256 _fee = cakeBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(cake).safeTransfer(vault, cakeBal.sub(_fee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the SmartChef\n     * 2. It swaps the {output} token for {cake}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest(uint8 poolId) public whenNotPaused {\n        require(poolId < pools.length, \"poolId out of bounds\");\n        require(pools[poolId].enabled, \"!enabled.\");\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        // Optimizes gas usage by recycling the withdraw to get rewards.\n        if (poolId != currentPool) {\n            exitCurrentPool();\n        } else {\n            ISmartChef(smartchef).deposit(0);\n        }\n\n        chargeFees();\n        swapRewards();\n\n        if (poolId != currentPool) {\n            updatePoolInfo(poolId);\n        }\n\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 6% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 1.5% -> Treasury fee\n     * 4% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(6).div(100);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Swaps whatever {output} it has for more cake.\n     */\n    function swapRewards() internal {\n        uint256 outputBal = IERC20(output).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputBal, 0, outputToCakeRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev It allows an account to submit a new pool to be harvested. It will take {approvalDelay}\n     * before it can actually be whitelisted and added as a harvest options.\n     */\n    function addUpcomingPool(address _smartchef) public onlyOwner {\n        upcomingPools.push(UpcomingPool({\n            smartchef: _smartchef,\n            proposedTime: block.timestamp,\n            addedToPools: false\n        }));\n\n        emit AddUpcomingPool(_smartchef);\n    }\n\n    /**\n     * @dev It approves an upcomingPool and makes it available for harvesting.\n     */\n    function approvePool(uint8 poolId) external onlyOwner {\n        require(poolId < upcomingPools.length, \"Pool out of bounds\");\n\n        UpcomingPool storage upcomingPool = upcomingPools[poolId];\n        require(upcomingPool.proposedTime.add(approvalDelay) < block.timestamp, \"Delay hasn't fully ocurred\");\n        require(!upcomingPool.addedToPools, \"Pool already added\");\n\n        upcomingPool.addedToPools = true;\n        _approvePool(upcomingPool.smartchef);\n    }\n\n    /**\n     * @dev Function to add a pool without validations. Used from the constructor and by approvePool().\n     */\n    function _approvePool(address _smartchef) internal {\n        address _output = ISmartChef(_smartchef).rewardToken();\n\n        IERC20(_output).safeApprove(unirouter, 0);\n        IERC20(_output).safeApprove(unirouter, type(uint).max);\n\n        pools.push(Pool({\n            smartchef: _smartchef,\n            output: _output,\n            enabled: true\n        }));\n\n        emit ApprovePool(_smartchef);\n    }\n\n    /**\n     * @dev Serves as a quick off buton in case of necessity once a pool has already been added.\n     */\n    function disablePool(uint8 poolId) external onlyOwner {\n        Pool storage pool = pools[poolId];\n        pool.enabled = false;\n    }\n\n    /**\n     * @dev Serves as a quick on buton in case of necessity once a pool has already been added.\n     */\n    function enablePool(uint8 poolId) external onlyOwner {\n        Pool storage pool = pools[poolId];\n        pool.enabled = true;\n    }\n\n    /**\n     * @dev It withdraws the funds from the current pool. It triggers the rewards during harvest too.\n    */\n    function exitCurrentPool() internal {\n        address _smartchef = pools[currentPool].smartchef;\n        ISmartChef(_smartchef).withdraw(balanceOfPool());\n    }\n\n    function updatePoolInfo(uint8 poolId) internal {\n        require(poolId < pools.length, \"poolId out of bounds\");\n\n        currentPool = poolId;\n        output = pools[poolId].output;\n        smartchef = pools[poolId].smartchef;\n\n        outputToCakeRoute = [output, wbnb, cake];\n        outputToWbnbRoute = [output, wbnb];\n    }\n\n    /**\n     * @dev Can only be called at the end of a strat lifecycle to prepare for migration. It should be called once\n     * a strat candidate is ready to be approved in the strat's vault. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat. It withdraws the funds without the rewards to have the less risk possible.\n     * If desired, you can harvest first and then call this function.\n     */\n    function retireStrat() external onlyOwner {\n        stopWork();\n\n        uint256 cakeBal = IERC20(cake).balanceOf(address(this));\n        IERC20(cake).transfer(vault, cakeBal);\n    }\n\n    /**\n     * @dev Withdraws all funds from the current SmartChef, leaving rewards behind.\n     */\n    function stopWork() public onlyOwner {\n        _pause();\n        ISmartChef(smartchef).emergencyWithdraw();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Helper function for UIs to know how many pools there are.\n     */\n    function poolsLength() external view returns (uint256) {\n        return pools.length;\n    }\n\n    /**\n     * @dev Helper function for UIs to know how many upcoming pools there are.\n     */\n    function upcomingPoolsLength() external view returns (uint256) {\n        return upcomingPools.length;\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {cake} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the current SmartChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfCake().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much cake the contract holds.\n     */\n    function balanceOfCake() public view returns (uint256) {\n        return IERC20(cake).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much cake the strategy has allocated in the current SmartChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ISmartChef(smartchef).userInfo(address(this));\n        return _amount;\n    }\n}"
    },
    "contracts/BIFI/mocks/ExposedStrategyCakeSmart.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"../strategies/Cake/StrategyCakeSmart.sol\";\n\ncontract ExposedStrategyCakeSmart is StrategyCakeSmart {\n    constructor(address _vault, uint256 _approvalDelay) StrategyCakeSmart(_vault, _approvalDelay) {}\n\n    function _updatePoolInfo(uint8 poolId) external  {\n        updatePoolInfo(poolId);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyFish.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouter.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/polycat/IMasterChefCat.sol\";\r\nimport \"../Common/FeeManager.sol\";\r\nimport \"../Common/StratManager.sol\";\r\n\r\ncontract StrategyFish is StratManager, FeeManager {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public wrapped = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\r\n    address constant public want = address(0x3a3Df212b7AA91Aa0402B9035b098891d276572B);\r\n\r\n    // Third party contracts\r\n    address constant public masterchef = address(0x8CFD1B9B7478E7B0422916B72d1DB6A9D513D734);\r\n    address constant public referrer = address(0x0000000000000000000000000000000000000000);\r\n    uint256 constant public poolId = 1;\r\n\r\n    // Routes\r\n    address[] public wantToWrappedRoute = [want, wrapped];\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    constructor(\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _strategist,\r\n        address _beefyFeeRecipient\r\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\r\n        _giveAllowances();\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal > 0) {\r\n            IMasterChefCat(masterchef).deposit(poolId, wantBal, referrer);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal < _amount) {\r\n            IMasterChefCat(masterchef).withdraw(poolId, _amount.sub(wantBal));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n        if (tx.origin == owner() || paused()) {\r\n            IERC20(want).safeTransfer(vault, wantBal);\r\n        } else {\r\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\r\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\r\n        }\r\n    }\r\n\r\n    function beforeDeposit() external override {\r\n        harvest();\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() public whenNotPaused {\r\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\r\n        IMasterChefCat(masterchef).deposit(poolId, 0, referrer);\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        if (wantBal > 0) {\r\n            chargeFees();\r\n            deposit();\r\n            emit StratHarvest(msg.sender);\r\n        }\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toWrapped = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWrapped, 0, wantToWrappedRoute, address(this), block.timestamp);\r\n\r\n        uint256 wrappedBal = IERC20(wrapped).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = wrappedBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(tx.origin, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = wrappedBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n\r\n        uint256 strategistFee = wrappedBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(wrapped).safeTransfer(strategist, strategistFee);\r\n    }\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool());\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // it calculates how much 'want' the strategy has working in the farm.\r\n    function balanceOfPool() public view returns (uint256) {\r\n        (uint256 _amount, ) = IMasterChefCat(masterchef).userInfo(poolId, address(this));\r\n        return _amount;\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IMasterChefCat(masterchef).emergencyWithdraw(poolId);\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        pause();\r\n        IMasterChefCat(masterchef).emergencyWithdraw(poolId);\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\r\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, 0);\r\n        IERC20(want).safeApprove(unirouter, 0);\r\n    }\r\n}"
    },
    "contracts/BIFI/interfaces/polycat/IMasterChefCat.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\ninterface IMasterChefCat {\r\n    function deposit(uint256 _pid, uint256 _amount, address referrer) external;\r\n    function withdraw(uint256 _pid, uint256 _amount) external;\r\n    function enterStaking(uint256 _amount) external;\r\n    function leaveStaking(uint256 _amount) external;\r\n    function pendingCake(uint256 _pid, address _user) external view returns (uint256);\r\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\r\n    function emergencyWithdraw(uint256 _pid) external;\r\n}"
    },
    "contracts/BIFI/strategies/Venus/StrategyVenus.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouter.sol\";\nimport \"../../interfaces/venus/IUnitroller.sol\";\nimport \"../../interfaces/venus/IVToken.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @title Strategy Venus\n * @author sirbeefalot & superbeefyboy\n * @dev It maximizes yields doing leveraged lending with a single configurable BEP20 asset\n * on the Venus lending platform.\n */\ncontract StrategyVenus is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {venus}   - Token earned through farming.\n     * {wbnb}    - Required for liquidity routing when doing swaps.\n     * {bifi}    - BeefyFinance token, used to send funds to the treasury.\n     * {vtoken}  - Venus Token. We interact with it to mint/redem/borrow/repay the loan.\n     * {want}    - Token that the strategy maximizes.\n     */\n    address constant public venus = address(0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63);\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public vtoken;\n    address public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter}  - Pancakeswap unirouter. Has the most liquidity for {venus}.\n     * {unitroller} - Controller contract for the {venus} rewards.\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public unitroller = address(0xfD36E2c2a6789Db23113685031d7F16329158384);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards}  - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault}    - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on chargeFees().\n     * Current implementation separates 5.0% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 5 === 0.05% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint256 constant public REWARDS_FEE    = 600;\n    uint256 constant public CALL_FEE       = 200;\n    uint256 constant public TREASURY_FEE   = 100;\n    uint256 constant public STRATEGIST_FEE = 100;\n    uint256 constant public MAX_FEE        = 1000;\n\n    uint256 constant public WITHDRAWAL_FEE = 5;\n    uint256 constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using the {unirouter}.\n     * {venusToWbnbRoute} - Route we take to go from {venus} into {wbnb}.\n     * {wbnbToBifiRoute}  - Route we take to go from {wbnb} into {bifi}.\n     * {venusToWantRoute} - Route we take to go from {venus} into {want}.\n     */\n    address[] public venusToWbnbRoute = [venus, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public venusToWantRoute;\n\n    /**\n     * @dev Variables that can be changed to config profitability and risk:\n     * {borrowRate}          - What % of our collateral do we borrow per leverage level.\n     * {borrowDepth}         - How many levels of leverage do we take.\n     * {minLeverage}         - The minimum amount of collateral required to leverage.\n     * {BORROW_RATE_MAX}     - A limit on how much we can push borrow risk.\n     * {BORROW_DEPTH_MAX}    - A limit on how many steps we can leverage.\n     */\n    uint256 public borrowRate;\n    uint256 public borrowDepth;\n    uint256 public minLeverage;\n    uint256 constant public BORROW_RATE_MAX = 58;\n    uint256 constant public BORROW_DEPTH_MAX = 10;\n\n    /**\n     * @dev We keep and update a cache of the strat's {want} deposited in venus. Contract\n     * functions that use this value always update it first. We use it to keep the UI helper\n     * functions as view only.\n     */\n    uint256 public depositedBalance;\n\n    /**\n     * @dev Helps to differentiate borrowed funds that shouldn't be used in functions like 'deposit()'\n     * as they're required to deleverage correctly.\n     */\n    uint256 public reserves = 0;\n\n    /**\n     * @dev Events that the contract emits\n     */\n    event StratHarvest(address indexed harvester);\n    event StratRebalance(uint256 _borrowRate, uint256 _borrowDepth);\n\n    /**\n     * @notice Initializes the strategy\n     * @param _vault Address of the vault that will manage the strat.\n     * @param _vtoken Address of the vtoken that we will interact with.\n     * @param _borrowRate Initial borrow rate used.\n     * @param _borrowDepth Initial borow depth used.\n     * @param _minLeverage Minimum amount that the '_leverage' function will actually leverage.\n     * @param _markets Array with a single element being the target vtoken address.\n     */\n    constructor(\n        address _vault,\n        address _vtoken,\n        uint256 _borrowRate,\n        uint256 _borrowDepth,\n        uint256 _minLeverage,\n        address[] memory _markets\n    ) {\n        vault = _vault;\n        vtoken = _vtoken;\n        want = IVToken(_vtoken).underlying();\n        minLeverage = _minLeverage;\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n        strategist = msg.sender;\n\n        venusToWantRoute = [venus, wbnb, want];\n\n        IERC20(want).safeApprove(vtoken, type(uint).max);\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IUnitroller(unitroller).enterMarkets(_markets);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault. It does {borrowDepth}\n     * levels of compound lending. It also updates the helper {depositedBalance} variable.\n     */\n    function deposit() public whenNotPaused {\n        uint256 wantBal = availableWant();\n\n        if (wantBal > 0) {\n            _leverage(wantBal);\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev Repeatedly supplies and borrows {want} following the configured {borrowRate} and {borrowDepth}\n     * @param _amount amount of {want} to leverage\n     */\n    function _leverage(uint256 _amount) internal {\n        if (_amount < minLeverage) { return; }\n\n        for (uint i = 0; i < borrowDepth; i++) {\n            IVToken(vtoken).mint(_amount);\n            _amount = _amount.mul(borrowRate).div(100);\n            IVToken(vtoken).borrow(_amount);\n        }\n\n        reserves = reserves.add(_amount);\n    }\n\n    /**\n     * @dev Incrementally alternates between paying part of the debt and withdrawing part of the supplied\n     * collateral. Continues to do this until it repays the entire debt and withdraws all the supplied {want}\n     * from the system\n     */\n    function _deleverage() internal {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n\n        while (wantBal < borrowBal) {\n            IVToken(vtoken).repayBorrow(wantBal);\n\n            borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n            uint256 targetUnderlying = borrowBal.mul(100).div(borrowRate);\n            uint256 balanceOfUnderlying = IVToken(vtoken).balanceOfUnderlying(address(this));\n\n            IVToken(vtoken).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        IVToken(vtoken).repayBorrow(type(uint256).max);\n\n        uint256 vtokenBal = IERC20(vtoken).balanceOf(address(this));\n        IVToken(vtoken).redeem(vtokenBal);\n\n        reserves = 0;\n    }\n\n    /**\n     * @dev Extra safety measure that allows us to manually unwind one level. In case we somehow get into\n     * as state where the cost of unwinding freezes the system. We can manually unwind a few levels\n     * with this function and then 'rebalance()' with new {borrowRate} and {borrowConfig} values.\n     * @param _borrowRate configurable borrow rate in case it's required to unwind successfully\n     */\n    function deleverageOnce(uint _borrowRate) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!safe\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IVToken(vtoken).repayBorrow(wantBal);\n\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n        uint256 targetUnderlying = borrowBal.mul(100).div(_borrowRate);\n        uint256 balanceOfUnderlying = IVToken(vtoken).balanceOfUnderlying(address(this));\n\n        IVToken(vtoken).redeemUnderlying(balanceOfUnderlying.sub(targetUnderlying));\n\n        updateBalance();\n\n        wantBal = IERC20(want).balanceOf(address(this));\n        reserves = wantBal;\n    }\n\n    /**xw\n     * @dev Updates the risk profile and rebalances the vault funds accordingly.\n     * @param _borrowRate percent to borrow on each leverage level.\n     * @param _borrowDepth how many levels to leveraxge the funds.\n     */\n    function rebalance(uint256 _borrowRate, uint256 _borrowDepth) external onlyOwner {\n        require(_borrowRate <= BORROW_RATE_MAX, \"!rate\");\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \"!depth\");\n\n        _deleverage();\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        _leverage(wantBal);\n\n        emit StratRebalance(_borrowRate, _borrowDepth);\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims {venus} rewards from the Unitroller.\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It swaps the remaining rewards into more {want}.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n\n        IUnitroller(unitroller).claimVenus(address(this));\n        _chargeFees();\n        _swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 5.0% as system fees from the rewards.\n     * 1% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3% -> BIFI Holders\n     */\n    function _chargeFees() internal {\n        uint256 toWbnb = IERC20(venus).balanceOf(address(this)).mul(50).div(1000);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, venusToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {venus} rewards earned for more {want}.\n     */\n    function _swapRewards() internal {\n        uint256 venusBal = IERC20(venus).balanceOf(address(this));\n        IUniswapRouter(unirouter).swapExactTokensForTokens(venusBal, 0, venusToWantRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. It deleverages from venus first,\n     * and then deposits again after the withdraw to make sure it mantains the desired ratio.\n     * @param _amount How much {want} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = availableWant();\n\n        if (wantBal < _amount) {\n            _deleverage();\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        uint256 withdrawalFee = wantBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFee));\n\n        if (!paused()) {\n            _leverage(availableWant());\n        }\n\n        updateBalance();\n    }\n\n    /**\n     * @dev It helps mantain a cached version of the {want} deposited in venus.\n     * We use it to be able to keep the vault's 'balance()' function and\n     * 'getPricePerFullShare()' with view visibility.\n     */\n    function updateBalance() public {\n        uint256 supplyBal = IVToken(vtoken).balanceOfUnderlying(address(this));\n        uint256 borrowBal = IVToken(vtoken).borrowBalanceCurrent(address(this));\n        depositedBalance = supplyBal.sub(borrowBal);\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        panic();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the Venus Platform.\n     */\n    function panic() public onlyOwner {\n        _deleverage();\n        updateBalance();\n        pause();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(want).safeApprove(vtoken, 0);\n        IERC20(venus).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(want).safeApprove(vtoken, type(uint).max);\n        IERC20(venus).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {want} held by the strat.\n     * It takes into account both the funds at hand, and the funds allocated in the {vtoken} contract.\n     * It uses a cache of the balances stored in {depositedBalance} to enable a few UI helper functions\n     * to exist. Sensitive functions should call 'updateBalance()' first to make sure the data is up to date.\n     * @return total {want} held by the strat.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfStrat().add(depositedBalance);\n    }\n\n    /**\n     * @notice Balance in strat contract\n     * @return how much {want} the contract holds.\n     */\n    function balanceOfStrat() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Required for various functions that need to deduct {reserves} from total {want}.\n     * @return how much {want} the hontract holds without reserves     \n     */\n     function availableWant() public view returns (uint256) {\n         uint256 wantBal = IERC20(want).balanceOf(address(this));\n         return wantBal.sub(reserves);\n     }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}"
    },
    "contracts/BIFI/mocks/ExposedStrategyVenus.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"../strategies/Venus/StrategyVenus.sol\";\n\ncontract ExposedStrategyVenus is StrategyVenus {\n    constructor(\n        address _vault,\n        address _vtoken,\n        uint256 _borrowRate,\n        uint256 _borrowDepth,\n        uint256 _minLeverage,\n        address[] memory _markets\n    ) StrategyVenus(\n        _vault,\n        _vtoken,\n        _borrowRate,\n        _borrowDepth,\n        _minLeverage,\n        _markets\n    ) {}\n\n    function leverage(uint256 _amount) public  {\n        _leverage(_amount);\n    }\n\n    function deleverage() public  {\n        _deleverage();\n    }\n}"
    },
    "contracts/BIFI/strategies/Sushi/StrategyPolygonSushiLP.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/sushi/IMiniChefV2.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyPolygonSushiLP is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address public native;\n    address public output;\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address public chef;\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToNativeRoute;\n    address[] public nativeToOutputRoute;\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _chef,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient,\n        address[] memory _outputToNativeRoute,\n        address[] memory _outputToLp0Route,\n        address[] memory _outputToLp1Route\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n        chef = _chef;\n\n        require(_outputToNativeRoute.length >= 2);\n        output = _outputToNativeRoute[0];\n        native = _outputToNativeRoute[_outputToNativeRoute.length - 1];\n        outputToNativeRoute = _outputToNativeRoute;\n\n        // setup lp routing\n        lpToken0 = IUniswapV2Pair(want).token0();\n        require(_outputToLp0Route[0] == output);\n        require(_outputToLp0Route[_outputToLp0Route.length - 1] == lpToken0);\n        outputToLp0Route = _outputToLp0Route;\n\n        lpToken1 = IUniswapV2Pair(want).token1();\n        require(_outputToLp1Route[0] == output);\n        require(_outputToLp1Route[_outputToLp1Route.length - 1] == lpToken1);\n        outputToLp1Route = _outputToLp1Route;\n\n        nativeToOutputRoute = new address[](_outputToNativeRoute.length);\n        for (uint i = 0; i < _outputToNativeRoute.length; i++) {\n            uint idx = _outputToNativeRoute.length - 1 - i;\n            nativeToOutputRoute[i] = outputToNativeRoute[idx];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IMiniChefV2(chef).deposit(poolId, wantBal, address(this));\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IMiniChefV2(chef).withdraw(poolId, _amount.sub(wantBal), address(this));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IMiniChefV2(chef).harvest(poolId, address(this));\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        // v2 harvester rewards are in both output and native, convert native to output\n        uint256 toOutput = IERC20(native).balanceOf(address(this));\n        if (toOutput > 0) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(toOutput, 0, nativeToOutputRoute, address(this), block.timestamp);\n        }\n\n        uint256 toNative = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toNative, 0, outputToNativeRoute, address(this), block.timestamp);\n\n        uint256 nativeBal = IERC20(native).balanceOf(address(this));\n\n        uint256 callFeeAmount = nativeBal.mul(callFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = nativeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(native).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = nativeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(native).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMiniChefV2(chef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMiniChefV2(chef).emergencyWithdraw(poolId, address(this));\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IMiniChefV2(chef).emergencyWithdraw(poolId, address(this));\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(chef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n        // needed for v2 harvester\n        IERC20(native).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(chef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(native).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/sushi/IMiniChefV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IMiniChefV2 {\n    struct UserInfo {\n        uint256 amount;\n        uint256 rewardDebt;\n    }\n\n    struct PoolInfo {\n        uint128 accSushiPerShare;\n        uint64 lastRewardTime;\n        uint64 allocPoint;\n    }\n\n    function poolLength() external view returns (uint256);\n    function updatePool(uint256 pid) external returns (IMiniChefV2.PoolInfo memory);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function deposit(uint256 pid, uint256 amount, address to) external;\n    function withdraw(uint256 pid, uint256 amount, address to) external;\n    function harvest(uint256 pid, address to) external;\n    function withdrawAndHarvest(uint256 pid, uint256 amount, address to) external;\n    function emergencyWithdraw(uint256 pid, address to) external;\n}"
    },
    "contracts/BIFI/strategies/Narwhal/StrategyGoldLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/narwhal/INarwhalswapRouter.sol\";\nimport \"../../interfaces/narwhal/INarwhalswapPair.sol\";\nimport \"../../interfaces/narwhal/IGoldFarm.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in NarwhalSwap.\n *\n * This strat is currently compatible with all Gold LP pools.\n */\ncontract StrategyGoldLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {gold} - Token generated by staking our funds. In this case it's the {gold} token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. INarwhalswapPair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public gold = address(0x8f4087Cb09E0F378f4278a314C94A636665dE24b);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - Selected unirouter configured through constructor\n     * {goldFarm} - GoldFarm contract\n     * {poolId} - GoldFarm pool id\n     */\n    address public unirouter;\n    address constant public goldFarm = address(0x77C10A04B7d3adEBE4F235D69b5c1f20Cbfd2E57);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 665;\n    uint constant public CALL_FEE     = 223;\n    uint constant public TREASURY_FEE = 112;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using Thugswap.\n     * {goldToWbnbRoute} - Route we take to get from {gold} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {goldToLp0Route} - Route we take to get from {gold} into {lpToken0}.\n     * {goldToLp1Route} - Route we take to get from {gold} into {lpToken1}.\n     */\n    address[] public goldToWbnbRoute = [gold, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public goldToLp0Route;\n    address[] public goldToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _unirouter) {\n        lpPair = _lpPair;\n        lpToken0 = INarwhalswapPair(lpPair).token0();\n        lpToken1 = INarwhalswapPair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        unirouter = _unirouter;\n\n        if (lpToken0 == wbnb) {\n            goldToLp0Route = [gold, wbnb];\n        } else if (lpToken0 != gold) {\n            goldToLp0Route = [gold, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            goldToLp1Route = [gold, wbnb];\n        } else if (lpToken1 != gold) {\n            goldToLp1Route = [gold, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(goldFarm, type(uint).max);\n        IERC20(gold).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the GoldFarm to farm {gold}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IGoldFarm(goldFarm).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the GoldFarm.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IGoldFarm(goldFarm).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the GoldFarm.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {gold} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IGoldFarm(goldFarm).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 1% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 3% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(gold).balanceOf(address(this)).mul(45).div(1000);\n        INarwhalswapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, goldToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        INarwhalswapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Swaps {gold} for {lpToken0}, {lpToken1} & {wbnb} using ThugSwap.\n     */\n    function addLiquidity() internal {\n        uint256 goldHalf = IERC20(gold).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != gold) {\n            INarwhalswapRouter(unirouter).swapExactTokensForTokens(goldHalf, 0, goldToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != gold) {\n            INarwhalswapRouter(unirouter).swapExactTokensForTokens(goldHalf, 0, goldToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        INarwhalswapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the GoldFarm.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the GoldFarm\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IGoldFarm(goldFarm).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external onlyOwner {\n        panic();\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the GoldFarm, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IGoldFarm(goldFarm).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(goldFarm, 0);\n        IERC20(gold).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(goldFarm, type(uint).max);\n        IERC20(gold).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/narwhal/INarwhalswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface INarwhalswapRouter {\n    function factory() external pure returns (address);\n    function WBNB() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityBNB(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountBNB, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityBNB(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountBNB);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityBNBWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountBNBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountBNB);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactBNBForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactBNB(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForBNB(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapBNBForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/BIFI/interfaces/narwhal/INarwhalswapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface INarwhalswapPair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/BIFI/interfaces/narwhal/IGoldFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IGoldFarm {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function pendinNart(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Monster/StrategyMssLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/monster/IMssRewardPool.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in PancakeSwap.\n * PancakeSwap is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. PancakeSwap is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected MSSRewardPool pool.\n * MSS rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the MSSRewardPool pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyMssLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {busd, wbnb} - Required for liquidity routing when doing swaps.\n     * {mss} - Token generated by staking our funds. In this case it's the MSS token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public mss = address(0xAcABD3f9b8F76fFd2724604185Fa5AFA5dF25aC6);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {mssRewardPool} - MSSRewardPool contract\n     * {poolId} - MSSRewardPool pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public mssRewardPool = address(0x3646DE962ff41462cc244b2379E7289B9b751BE1);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - -.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {mssToWbnbRoute} - Route we take to get from {mss} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {mssToLp0Route} - Route we take to get from {mss} into {lpToken0}.\n     * {mssToLp1Route} - Route we take to get from {mss} into {lpToken1}.\n     */\n    address[] public mssToWbnbRoute = [mss, busd, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public mssToLp0Route;\n    address[] public mssToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == busd) {\n            mssToLp0Route = [mss, busd];\n        } else if (lpToken0 != mss) {\n            mssToLp0Route = [mss, busd, lpToken0];\n        }\n\n        if (lpToken1 == busd) {\n            mssToLp1Route = [mss, busd];\n        } else if (lpToken1 != mss) {\n            mssToLp1Route = [mss, busd, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(mssRewardPool, type(uint).max);\n        IERC20(mss).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MSSRewardPool to farm {mss}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IMssRewardPool(mssRewardPool).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MSSRewardPool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IMssRewardPool(mssRewardPool).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MSSRewardPool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {mss} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IMssRewardPool(mssRewardPool).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(mss).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, mssToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {mss} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 mssHalf = IERC20(mss).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != mss) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(mssHalf, 0, mssToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != mss) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(mssHalf, 0, mssToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MSSRewardPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MSSRewardPool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IMssRewardPool(mssRewardPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IMssRewardPool(mssRewardPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MSSRewardPool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IMssRewardPool(mssRewardPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(mssRewardPool, 0);\n        IERC20(mss).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(busd).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(mssRewardPool, type(uint).max);\n        IERC20(mss).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/monster/IMssRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IMssRewardPool {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function pendingShare(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Helmet/StrategyHelmetBnbLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/helmet/IStakingRewards.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in PancakeSwap.\n * PancakeSwap is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. PancakeSwap is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected StakingRewards pool.\n * HELMET and CAKE rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the StakingRewards pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyBdoLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {helmet} - Token generated by staking our funds. In this case it's the HELMETs token.\n     * {cake} - Token generated by staking our funds. In this case it's the CAKEs token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {helmet-bnb} - LP token used for staking.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public helmet = address(0x948d2a81086A075b3130BAc19e4c6DEe1D2E3fE8);\n    address constant public cake = address(0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public lpPair = address(0x6411310C07d8c48730172146Fd6F31FA84034a8b);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingRewards} - IStakingRewards contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingRewards = address(0xb22425206D40605E9bE5a5460786DBaB5aBA9485);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {helmetToWbnbRoute} - Route we take to get from {helmet} into {wbnb}.\n     * {cakeToHelmetRoute} - Route we take to get from {cake} into {helmet}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public helmetToWbnbRoute = [helmet, wbnb];\n    address[] public cakeToHelmetRoute = [cake, wbnb, helmet];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(lpPair).safeApprove(stakingRewards, type(uint).max);\n        IERC20(helmet).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(cake).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the stakingRewards to farm {helmet}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IStakingRewards(stakingRewards).stake(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the StakingRewards.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IStakingRewards(stakingRewards).withdraw(_amount.sub(pairBal));\n            IStakingRewards(stakingRewards).getReward();\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the StakingRewards.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {helmet} & {cake} token for {helmet} & {wbnb}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IStakingRewards(stakingRewards).getReward();\n        chargeFees(helmet);\n        chargeFees(cake);\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees(address token) internal {\n        uint256 toWbnb = IERC20(token).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, helmetToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {helmet} & {cake} for {helmet} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 cakeBal = IERC20(cake).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(cakeBal, 0, cakeToHelmetRoute, address(this), block.timestamp.add(600));\n\n        uint256 helmetHalf = IERC20(helmet).balanceOf(address(this)).div(2);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(helmetHalf, 0, helmetToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 helmetBal = IERC20(helmet).balanceOf(address(this));\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(helmet, wbnb, helmetBal, wbnbBal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the StakingRewards.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the IStakingRewards\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IStakingRewards(stakingRewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IStakingRewards(stakingRewards).withdraw(balanceOfPool());\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the StakingRewards, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IStakingRewards(stakingRewards).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(stakingRewards, 0);\n        IERC20(helmet).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(cake).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(stakingRewards, type(uint).max);\n        IERC20(helmet).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n        IERC20(cake).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/helmet/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IStakingRewards {\n    // Views\n    function lastTimeRewardApplicable() external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function earned(address account) external view returns (uint256);\n\n    function getRewardForDuration() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    // Mutative\n\n    function stake(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getReward() external;\n\n    function exit() external;\n}\n"
    },
    "contracts/BIFI/strategies/Helmet/StrategyHelmet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/helmet/IStakingRewards.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming HELMET in Helmet Insure.\n * PancakeSwap is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. PancakeSwap is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected StakingRewards pool.\n * HELMET rewards from providing liquidity are farmed every few minutes and sold.\n * The corresponding pair of assets are bought and more liquidity is added to the StakingRewards pool.\n */\ncontract StrategyHelmet is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {helmet} - Token generated by staking our funds. In this case it's the HELMETs token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public helmet = address(0x948d2a81086A075b3130BAc19e4c6DEe1D2E3fE8);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingRewards} - IStakingRewards contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingRewards = address(0x279a073C491C873DF040B05cc846A3c47252b52c);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {helmetToWbnbRoute} - Route we take to get from {helmet} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     */\n    address[] public helmetToWbnbRoute = [helmet, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        vault = _vault;\n        strategist = _strategist;\n\n        IERC20(helmet).safeApprove(stakingRewards, type(uint).max);\n        IERC20(helmet).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {helmet} in the stakingRewards to farm {helmet}\n     */\n    function deposit() public whenNotPaused {\n        uint256 helmetBal = IERC20(helmet).balanceOf(address(this));\n\n        if (helmetBal > 0) {\n            IStakingRewards(stakingRewards).stake(helmetBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {helmet} from the StakingRewards.\n     * The available {helmet} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 helmetBal = IERC20(helmet).balanceOf(address(this));\n\n        if (helmetBal < _amount) {\n            IStakingRewards(stakingRewards).withdraw(_amount.sub(helmetBal));\n            IStakingRewards(stakingRewards).getReward();\n            helmetBal = IERC20(helmet).balanceOf(address(this));\n        }\n\n        if (helmetBal > _amount) {\n            helmetBal = _amount;\n        }\n\n        uint256 withdrawalFee = helmetBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(helmet).safeTransfer(vault, helmetBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the StakingRewards.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It deposits the new tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IStakingRewards(stakingRewards).getReward();\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(helmet).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, helmetToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {helmet} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the StakingRewards.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfHelmet().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {helmet} the contract holds.\n     */\n    function balanceOfHelmet() public view returns (uint256) {\n        return IERC20(helmet).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {helmet} the strategy has allocated in the IStakingRewards\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return IStakingRewards(stakingRewards).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IStakingRewards(stakingRewards).withdraw(balanceOfPool());\n\n        uint256 helmetBal = IERC20(helmet).balanceOf(address(this));\n        IERC20(helmet).transfer(vault, helmetBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the StakingRewards, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IStakingRewards(stakingRewards).withdraw(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(helmet).safeApprove(stakingRewards, 0);\n        IERC20(helmet).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(helmet).safeApprove(stakingRewards, type(uint).max);\n        IERC20(helmet).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/ForTube/StrategyFortube.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/fortube/IFor.sol\";\nimport \"../../interfaces/fortube/IFToken.sol\";\nimport \"../../interfaces/fortube/IBankController.sol\";\nimport \"../../interfaces/fortube/IForReward.sol\";\n\n/**\n @dev Implementation of a strategy to get yields from farming the FOR token.\n Fortube is a lending platform that incentivizes lenders by distributing their governance token.\n The strategy simply deposits whatever funds it receives from the vault into Fortube. Rewards\n generated in FOR can regularly be harvested, swapped for the original vault asset, and deposited\n again for compound faming.\n This strat is currently compatible with: USDT, FOR, BUSD, ETH, BNB, BTCB, LTC, BCH, XRP, DOT, EOS, LINK, ONT,\n XTZ and DAI. The token to use is configured with a constructor argument.\n */\n\ncontract StrategyFortube {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {output} - Token generated by staking our funds. In this case it's the FOR governance token.\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {want} - Token that the strategy maximizes. The same token that users deposit in the vault.\n    */\n    address constant public output = address(0x658A109C5900BC6d2357c87549B651670E5b0539);\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address  public want;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - AMM used to swap from {output} into {want}\n     * {fortube} - Fortube Bank contract. Main contract the strat interacts with.\n     * {fortube_reward} - Fortube rewards pool. Used to claim rewards.\n     */\n    address  public unirouter = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public fortube = address(0x0cEA0832e9cdBb5D476040D58Ea07ecfbeBB7672);\n    address  public fortube_reward = address(0x55838F18e79cFd3EA22Eea08Bd3Ec18d67f314ed);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address public rewards = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     Current implementation separates 5% for fees.\n     * {fee} - 4% goes to BIFI holders through the {rewards} pool.\n     * {callfee} - 1% goes to whoever executes the harvest function as gas subsidy.\n     * {withdrawalFee} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n    */\n    uint public fee = 500;\n    uint public callfee = 500;\n    uint constant public max = 1000;\n\n    uint public withdrawalFee = 10;\n    uint constant public withdrawalMax = 10000;\n\n    // Convenience value for UIs to display the strat name. It is initialized on contract deploy.\n    string public getName;\n\n    // Route we take to get from {output} into {want}. Required to execute swaps with Unswap clones.\n    address[] public swap2TokenRouting;\n\n    // Route we take to get from {output} into {wbnb}. Required to execute swaps with Unswap clones.\n    address[] public swap2WbnbRouting;\n\n    // Route we take to get from {want} into {wbnb}. Required to execute swaps with Unswap clones.\n    address[] public want2WbnbRouting;\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     */\n    constructor(address _want, address _vault) {\n        want = _want;\n        vault = _vault;\n\n        getName = string(\n            abi.encodePacked(\"Beefy:Strategy:\",\n                abi.encodePacked(ERC20(want).name(),\"The Force Token\"\n                )\n            ));\n        swap2WbnbRouting = [output,wbnb];\n        want2WbnbRouting = [want,wbnb];\n        swap2TokenRouting = [output,wbnb,want];\n\n        IERC20(want).safeApprove(unirouter, 0);\n        IERC20(want).safeApprove(unirouter, type(uint).max);\n\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work. It gets called whenever someone deposits\n     * in the strategy's vault contract. It provides whatever {want} it has available to be\n     * lent out on Fortube.\n     */\n    function deposit() public {\n        uint _want = IERC20(want).balanceOf(address(this));\n        address _controller = IFor(fortube).controller();\n        if (_want > 0) {\n            IERC20(want).safeApprove(_controller, 0);\n            IERC20(want).safeApprove(_controller, _want);\n            IFor(fortube).deposit(want, _want);\n        }\n    }\n\n    /**\n     * @dev It withdraws funds from Fortube and sents them back to the vault.\n     * Gets called when users withdraw from the parent vault.\n     */\n    function withdraw(uint _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint _balance = IERC20(want).balanceOf(address(this));\n        if (_balance < _amount) {\n            _amount = _withdrawSome(_amount.sub(_balance));\n            _amount = _amount.add(_balance);\n        }\n\n        uint _fee = 0;\n        if (withdrawalFee > 0){\n            _fee = _amount.mul(withdrawalFee).div(withdrawalMax);\n        }\n\n        IERC20(want).safeTransfer(vault, _amount.sub(_fee));\n    }\n\n    /**\n     * @dev Internal function that manages the actual withdraw from the Fortube Bank.\n     */\n    function _withdrawSome(uint256 _amount) internal returns (uint) {\n        IFor(fortube).withdrawUnderlying(want,_amount);\n        return _amount;\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from Fortube reward pool\n     * 2. It swaps the FOR token for {want}\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() public {\n        require(!Address.isContract(msg.sender),\"!contract\");\n        IForReward(fortube_reward).claimReward();\n        doswap();\n        dosplit();\n        deposit();\n    }\n\n    /**\n     * @dev Swaps {output} for {want} using the established Uniswap clone.\n     */\n    function doswap() internal {\n        uint256 _2token = IERC20(output).balanceOf(address(this)).mul(98).div(100);\n        uint256 _2wbnb = IERC20(output).balanceOf(address(this)).mul(2).div(100);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(_2token, 0, swap2TokenRouting, address(this), block.timestamp.add(600));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(_2wbnb, 0, swap2WbnbRouting, address(this), block.timestamp.add(600));\n\n        uint256 _want = IERC20(want).balanceOf(address(this));\n        if (_want > 0) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(_want, 0, want2WbnbRouting, address(this), block.timestamp.add(600));\n        }\n    }\n\n    /**\n     * @dev Takes our 4% as system fees from the rewards. Takes out an extra 1% as\n     * gas subsidy and pays it out to the function caller.\n     */\n    function dosplit() internal {\n        uint _bal = IERC20(wbnb).balanceOf(address(this));\n        uint _fee = _bal.mul(fee).div(max);\n        uint _callfee = _bal.mul(callfee).div(max);\n        IERC20(wbnb).safeTransfer(rewards, _fee);\n        IERC20(wbnb).safeTransfer(msg.sender, _callfee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {want} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in Fortube.\n     */\n    function balanceOf() public view returns (uint) {\n        return balanceOfWant()\n               .add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {want} the strategy has allocated in Fortube.\n     */\n    function balanceOfPool() public view returns (uint) {\n        address _controller = IFor(fortube).controller();\n        IFToken fToken = IFToken(IBankController(_controller).getFTokeAddress(want));\n        return fToken.calcBalanceOfUnderlying(address(this));\n    }\n}"
    },
    "contracts/BIFI/interfaces/fortube/IFor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IFor {\n    function deposit(address token, uint256 amount) external payable;\n    function withdraw(address underlying, uint256 withdrawTokens) external;\n    function withdrawUnderlying(address underlying, uint256 amount) external;\n    function controller() view external returns(address);\n}"
    },
    "contracts/BIFI/interfaces/fortube/IFToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IFToken {\n    function balanceOf(address account) external view returns (uint256);\n\n    function calcBalanceOfUnderlying(address owner)\n        external\n        view\n        returns (uint256);\n}"
    },
    "contracts/BIFI/interfaces/fortube/IBankController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBankController {\n    function getFTokeAddress(address underlying)\n        external\n        view\n        returns (address);\n}"
    },
    "contracts/BIFI/interfaces/fortube/IForReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IForReward {\n    function claimReward() external;\n    function checkBalance(address account) external view returns (uint256);\n}"
    },
    "contracts/BIFI/strategies/Dopple/StrategyDoppleStableLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/dopple/IDoppleLP.sol\";\nimport \"../../interfaces/dopple/IDoppleSwap.sol\";\nimport \"../../interfaces/dopple/IDoppleMasterChef.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyDoppleStableLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public dop = address(0x844FA82f1E54824655470970F7004Dd90546bB28);\n    address public want;\n    address public swapToken;\n\n    // Third party contracts\n    address constant public masterchef = address(0xDa0a175960007b0919DBF11a38e6EC52896bddbE);\n    uint256 public poolId;\n    uint8 public swapSize;\n    uint8 public busdIndex;\n\n    // Routes\n    address[] public dopToWbnbRoute = [dop, wbnb];\n    address[] public dopToBusdRoute = [dop, busd];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        uint8 _swapSize,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        poolId = _poolId;\n        swapSize = _swapSize;\n\n        swapToken = IDoppleLP(want).swap();\n        busdIndex = IDoppleSwap(swapToken).getTokenIndex(busd);\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IDoppleMasterChef(masterchef).deposit(address(this), poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IDoppleMasterChef(masterchef).withdraw(address(this), poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IDoppleMasterChef(masterchef).harvest(poolId);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(dop).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, dopToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 dopBal = IERC20(dop).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(dopBal, 0, dopToBusdRoute, address(this), block.timestamp);\n\n        uint256 busdBal = IERC20(busd).balanceOf(address(this));\n        uint256[] memory amounts = new uint256[](swapSize);\n        amounts[busdIndex] = busdBal;\n        IDoppleSwap(swapToken).addLiquidity(amounts, 0, block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount,,,) =  IDoppleMasterChef(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IDoppleMasterChef(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IDoppleMasterChef(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint).max);\n        IERC20(dop).safeApprove(unirouter, type(uint).max);\n        IERC20(busd).safeApprove(swapToken, type(uint).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(dop).safeApprove(unirouter, 0);\n        IERC20(busd).safeApprove(swapToken, 0);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/dopple/IDoppleLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IDoppleLP {\n    function swap() external view returns (address);\n}"
    },
    "contracts/BIFI/interfaces/dopple/IDoppleSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IDoppleSwap {\n    function getTokenIndex(address tokenAddress) external view returns (uint8);\n    function addLiquidity(uint256[] calldata amounts, uint256 minToMint, uint256 deadline) external returns (uint256);\n}"
    },
    "contracts/BIFI/interfaces/dopple/IDoppleMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IDoppleMasterChef {\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256, uint256, address);\n    function deposit(address _for, uint256 _pid, uint256 _amount) external;\n    function withdraw(address _for, uint256 _pid, uint256 _amount) external;\n    function harvest(uint256 _pid) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/degens/StrategySoupsLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/bdollar/IShareRewardPool.sol\";\n\n/**\n * This strategy simply deposits whatever funds it receives from the vault into the selected RewardPool pool.\n * Rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the RewardPool pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategySoupsLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the SOUPS token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb   = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x69F27E70E820197A6e495219D9aC34C8C6dA7EeE);\n    address constant public bifi   = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {rewardPool} - RewardPool contract\n     * {poolId} - RewardPool pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public rewardPool = address(0x034aF5a55e4316D975A29672733B9791c397b6AF);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - -.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {mssToWbnbRoute} - Route we take to get from {mss} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {mssToLp0Route} - Route we take to get from {mss} into {lpToken0}.\n     * {mssToLp1Route} - Route we take to get from {mss} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the RewardPool to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IShareRewardPool(rewardPool).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the RewardPool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IShareRewardPool(rewardPool).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the RewardPool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IShareRewardPool(rewardPool).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the RewardPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the RewardPool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IShareRewardPool(rewardPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IShareRewardPool(rewardPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MSSRewardPool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IShareRewardPool(rewardPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/bdollar/IShareRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IShareRewardPool {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function pendingShare(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyBingoLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/bdollar/IShareRewardPool.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * This strategy simply deposits whatever funds it receives from the vault into the selected RewardPool pool.\n * Rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the RewardPool pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyBingoLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the sBGO token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb   = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd   = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x53F39324Fbb209693332B87aA94D5519A1a49aB0);\n    address constant public bifi   = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {rewardPool} - RewardPool contract\n     * {poolId} - RewardPool pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public rewardPool = address(0x97bdB4071396B7f60b65E0EB62CE212a699F4B08);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - -.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, busd, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, busd, lpToken0];\n        }\n\n        if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, busd, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the RewardPool to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IShareRewardPool(rewardPool).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the RewardPool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IShareRewardPool(rewardPool).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the RewardPool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IShareRewardPool(rewardPool).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the RewardPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the RewardPool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IShareRewardPool(rewardPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IShareRewardPool(rewardPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the RewardPool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IShareRewardPool(rewardPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(rewardPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(rewardPool, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/BDollar/StrategySbdoLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/bdollar/IShareRewardPool.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in PancakeSwap.\n * PancakeSwap is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. PancakeSwap is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected ShareRewardPool pool.\n * SBDO rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the ShareRewardPool pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategySbdoLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {busd, wbnb} - Required for liquidity routing when doing swaps.\n     * {sbdo} - Token generated by staking our funds. In this case it's the SBDOs token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public sbdo = address(0x0d9319565be7f53CeFE84Ad201Be3f40feAE2740);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {shareRewardPool} - ShareRewardPool contract\n     * {poolId} - ShareRewardPool pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public shareRewardPool = address(0x948dB1713D4392EC04C86189070557C5A8566766);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - -.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {sbdoToWbnbRoute} - Route we take to get from {sbdo} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {sbdoToLp0Route} - Route we take to get from {sbdo} into {lpToken0}.\n     * {sbdoToLp1Route} - Route we take to get from {sbdo} into {lpToken1}.\n     */\n    address[] public sbdoToWbnbRoute = [sbdo, busd, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public sbdoToLp0Route;\n    address[] public sbdoToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == busd) {\n            sbdoToLp0Route = [sbdo, busd];\n        } else if (lpToken0 != sbdo) {\n            sbdoToLp0Route = [sbdo, busd, lpToken0];\n        }\n\n        if (lpToken1 == busd) {\n            sbdoToLp1Route = [sbdo, busd];\n        } else if (lpToken1 != sbdo) {\n            sbdoToLp1Route = [sbdo, busd, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(shareRewardPool, type(uint).max);\n        IERC20(sbdo).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the shareRewardPool to farm {sbdo}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IShareRewardPool(shareRewardPool).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the ShareRewardPool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IShareRewardPool(shareRewardPool).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the ShareRewardPool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {sbdo} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IShareRewardPool(shareRewardPool).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(sbdo).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, sbdoToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {sbdo} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 sbdoHalf = IERC20(sbdo).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != sbdo) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(sbdoHalf, 0, sbdoToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != sbdo) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(sbdoHalf, 0, sbdoToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the ShareRewardPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the IShareRewardPool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IShareRewardPool(shareRewardPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IShareRewardPool(shareRewardPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the ShareRewardPool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IShareRewardPool(shareRewardPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(shareRewardPool, 0);\n        IERC20(sbdo).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(busd).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(shareRewardPool, type(uint).max);\n        IERC20(sbdo).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/strategies/degens/StrategySlimeLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/slime/ISlimeFactory.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in SlimeFinance.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategySlimeLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb, busd} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the Slime token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public busd = address(0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56);\n    address constant public output = address(0x4fCfA6cC8914ab455B5b33Df916d90BFe70b6AB1);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {masterchef} - Slime MasterChef contract\n     * {poolId} - MasterChef pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public masterchef = address(0x4B0073A79f2b46Ff5a62fA1458AAc86Ed918C80C);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 == busd) {\n            outputToLp0Route = [output, busd];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 == busd) {\n            outputToLp1Route = [output, busd];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the MasterChef to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            ISlimeFactory(masterchef).deposit(poolId, pairBal, treasury);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the MasterChef.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            ISlimeFactory(masterchef).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the MasterChef.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        ISlimeFactory(masterchef).deposit(poolId, 0, address(0));\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to synchronize balance of {lpPair}.\n     * Can be called by the vault before minting shares.\n     * No-op as underlying contract doesn't need to be synced\n     */\n    function updateBalance() public {}\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the MasterChef.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the MasterChef\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = ISlimeFactory(masterchef).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ISlimeFactory(masterchef).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the MasterChef, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        ISlimeFactory(masterchef).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(masterchef, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/slime/ISlimeFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ISlimeFactory {\n    function deposit(uint256 _pid, uint256 _amount, address referrer) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function enterStaking(uint256 _amount) external;\n    function leaveStaking(uint256 _amount) external;\n    function pendingCake(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyNutsLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/nuts/INutsLPStaking.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in Squirrel Finance.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyNutsLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {output} - Token generated by staking our funds. In this case it's the NUTS token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0x8893D5fA71389673C5c4b9b3cb4EE1ba71207556);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public lpPair = address(0x034C9E6B08c09a6144e0D0E52161338fB105e656);\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {stakingPool} - NutsStaking contract\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public stakingPool = address(0x03d9d14367127d477e6F340C59E57ab088220187);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {outputToWbnbRoute} - Route we take to get from {output} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {outputToLp0Route} - Route we take to get from {output} into {lpToken0}.\n     * {outputToLp1Route} - Route we take to get from {output} into {lpToken1}.\n     */\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _vault, address _strategist) {\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(stakingPool, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the NutsStaking to farm {output}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            INutsLPStaking(stakingPool).deposit(pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the NutsStaking.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            INutsLPStaking(stakingPool).cashout(_amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the NutsStaking.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {output} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        INutsLPStaking(stakingPool).claimYield();\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {output} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the NutsStaking.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the NutsStaking\n     */\n    function balanceOfPool() public view returns (uint256) {\n        return INutsLPStaking(stakingPool).balances(address(this));\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        INutsLPStaking(stakingPool).cashout(balanceOfPool());\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the NutsStaking\n     */\n    function panic() public onlyOwner {\n        pause();\n        INutsLPStaking(stakingPool).cashout(balanceOfPool());\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(stakingPool, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(stakingPool, type(uint).max);\n        IERC20(output).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/nuts/INutsLPStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface INutsLPStaking {\n    function balances(address account) external view returns (uint256);\n    function deposit(uint256 amount) external;\n    function cashout(uint256 amount) external;\n    function claimYield() external;\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyGrandSingle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/grand/IGrandFarm.sol\";\nimport \"../../interfaces/grand/IWrappedGrand.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyGrandSingle is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public want = address(0xeE814F5B2bF700D2e843Dc56835D28d095161dd9);\n    address constant public wrappedGrand = address(0x28060854AC19391dF6C69Df430cAba4506181d56);\n\n    // Third party contracts\n    address constant public masterchef = address(0x3d8fd880976a3EA0f53cad02463867013D331107);\n    uint256 constant public poolId = 22;\n\n    // Routes\n    address[] public wantToWbnbRoute = [want, wbnb];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IWrappedGrand(wrappedGrand).deposit(wantBal);\n            IGrandFarm(masterchef).depositWant(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IGrandFarm(masterchef).withdrawWant(poolId, _amount.sub(wantBal));\n            IWrappedGrand(wrappedGrand).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    function beforeDeposit() external override {\n        harvest();\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() public whenNotPaused gasThrottle {\n        require(tx.origin == msg.sender || msg.sender == vault, \"!contract\");\n        IGrandFarm(masterchef).depositWant(poolId, 0);\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        if (wantBal > 0) {\n            chargeFees();\n            deposit();\n            emit StratHarvest(msg.sender);\n        }\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(want).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, wantToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(tx.origin, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IGrandFarm(masterchef).stakedWantTokens(poolId, address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IGrandFarm(masterchef).emergencyWithdraw(poolId);\n        uint256 wrappedBal = IERC20(wrappedGrand).balanceOf(address(this));\n        IWrappedGrand(wrappedGrand).withdraw(wrappedBal);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IGrandFarm(masterchef).emergencyWithdraw(poolId);\n        uint256 wrappedBal = IERC20(wrappedGrand).balanceOf(address(this));\n        IWrappedGrand(wrappedGrand).withdraw(wrappedBal);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(wrappedGrand, type(uint256).max);\n        IERC20(wrappedGrand).safeApprove(masterchef, type(uint256).max);\n        IERC20(want).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(wrappedGrand, 0);\n        IERC20(wrappedGrand).safeApprove(masterchef, 0);\n        IERC20(want).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/interfaces/grand/IGrandFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IGrandFarm {\n    function stakedWantTokens(uint256 _pid, address _user) external view returns (uint256);\n    function depositWant(uint256 _pid, uint256 _amount) external;\n    function withdrawWant(uint256 _pid, uint256 wantBalance) external;\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/interfaces/grand/IWrappedGrand.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IWrappedGrand {\n    function deposit(uint256 _amount) external;\n    function withdraw(uint256 _amount) external;\n}"
    },
    "contracts/BIFI/strategies/degens/StrategyGrandLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/grand/IGrandFarm.sol\";\nimport \"../../utils/GasThrottler.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyGrandLP is StratManager, FeeManager, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public output = address(0xeE814F5B2bF700D2e843Dc56835D28d095161dd9);\n    address public want;\n    address public lpToken0;\n    address public lpToken1;\n\n    // Third party contracts\n    address constant public masterchef = address(0x3d8fd880976a3EA0f53cad02463867013D331107);\n    uint256 public poolId;\n\n    // Routes\n    address[] public outputToWbnbRoute = [output, wbnb];\n    address[] public outputToLp0Route;\n    address[] public outputToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        uint256 _poolId,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        lpToken0 = IUniswapV2Pair(want).token0();\n        lpToken1 = IUniswapV2Pair(want).token1();\n        poolId = _poolId;\n\n        if (lpToken0 == wbnb) {\n            outputToLp0Route = [output, wbnb];\n        } else if (lpToken0 != output) {\n            outputToLp0Route = [output, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            outputToLp1Route = [output, wbnb];\n        } else if (lpToken1 != output) {\n            outputToLp1Route = [output, wbnb, lpToken1];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IGrandFarm(masterchef).depositWant(poolId, wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IGrandFarm(masterchef).withdrawWant(poolId, _amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\n        IGrandFarm(masterchef).depositWant(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\n        }\n\n        if (lpToken1 != output) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IGrandFarm(masterchef).stakedWantTokens(poolId, address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IGrandFarm(masterchef).emergencyWithdraw(poolId);\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IGrandFarm(masterchef).emergencyWithdraw(poolId);\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(masterchef, 0);\n        IERC20(output).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/degens/LaunchpoolReferral.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IRouter {\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n\ncontract LaunchpoolReferral is Ownable {\n    using SafeERC20 for IERC20;\n\n    address payable constant public multisig = payable(address(0x37EA21Cb5e080C27a47CAf767f24a8BF7Fcc7d4d));\n\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address public router = address(0x10ED43C718714eb63d5aA57B78B54704E256024E);\n\n    address public pantherRouter = address(0x24f7C33ae5f77e2A9ECeed7EA858B4ca2fa1B7eC);\n    address public panther = address(0x1f546aD641B56b86fD9dCEAc473d1C7a357276B7);\n\n    mapping(address => bool) public admins;\n\n    modifier onlyAdmin() {\n        require(msg.sender == owner() || admins[msg.sender], \"!admin\");\n        _;\n    }\n\n    function addAdmin(address admin) external onlyOwner {\n        admins[admin] = true;\n    }\n\n    function removeAdmin(address admin) external onlyOwner {\n        admins[admin] = false;\n    }\n\n    function setRouter(address _router) external onlyOwner {\n        router = _router;\n    }\n\n    function swap(address[] memory _route, address _router) public onlyAdmin {\n        address token = _route[0];\n        uint256 tokenBal = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeIncreaseAllowance(_router, tokenBal);\n        IRouter(_router).swapExactTokensForETHSupportingFeeOnTransferTokens(tokenBal, 0, _route, multisig, block.timestamp);\n    }\n\n    function swapToBNB(address _token, address _router) public onlyAdmin {\n        address[] memory wbnbRoute = new address[](2);\n        wbnbRoute[0] = _token;\n        wbnbRoute[1] = wbnb;\n        swap(wbnbRoute, _router);\n    }\n\n    function swapToBNB(address _token) external onlyAdmin {\n        swapToBNB(_token, router);\n    }\n\n    function withdrawToken(address _token, uint256 _amount) external onlyAdmin {\n        IERC20(_token).safeTransfer(multisig, _amount);\n    }\n\n    function withdrawNative(uint256 _amount) external onlyAdmin {\n        multisig.transfer(_amount);\n    }\n\n    function pantherToBNB() external onlyAdmin {\n        swapToBNB(panther, pantherRouter);\n    }\n\n    receive() external payable {}\n}"
    },
    "contracts/BIFI/strategies/Curve/StrategyCurveAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/curve/IRewardsGauge.sol\";\nimport \"../../interfaces/curve/IStableSwapAave.sol\";\nimport \"../Common/StratManager.sol\";\nimport \"../Common/FeeManager.sol\";\n\ncontract StrategyCurveAave is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public usdc = address(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174);\n    address constant public want = address(0xE7a24EF0C5e95Ffb0f6684b813A78F2a3AD7D171);\n    address constant public swapToken = address(0x445FE580eF8d70FF569aB36e80c647af338db351);\n\n    // Third party contracts\n    address constant public rewards = address(0xe381C25de995d62b453aF8B931aAc84fcCaa7A62);\n\n    // Routes\n    address[] public wmaticToUsdcRoute = [wmatic, usdc];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            IRewardsGauge(rewards).deposit(wantBal);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            IRewardsGauge(rewards).withdraw(_amount.sub(wantBal));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        IRewardsGauge(rewards).claim_rewards(address(this));\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 wmaticFeeBal = IERC20(wmatic).balanceOf(address(this)).mul(45).div(1000);\n\n        uint256 callFeeAmount = wmaticFeeBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticFeeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticFeeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    // Adds liquidity to AMM and gets more LP tokens.\n    function addLiquidity() internal {\n        uint256 wmaticBal = IERC20(wmatic).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(wmaticBal, 0, wmaticToUsdcRoute, address(this), block.timestamp);\n\n        uint256 usdcBal = IERC20(usdc).balanceOf(address(this));\n        uint256[3] memory amounts = [0, usdcBal, 0];\n        IStableSwapAave(swapToken).add_liquidity(amounts, 0, true);\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        return IRewardsGauge(rewards).balanceOf(address(this));\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IRewardsGauge(rewards).withdraw(balanceOfPool());\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        pause();\n        IRewardsGauge(rewards).withdraw(balanceOfPool());\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(rewards, type(uint).max);\n        IERC20(wmatic).safeApprove(unirouter, type(uint).max);\n        IERC20(usdc).safeApprove(swapToken, type(uint).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(rewards, 0);\n        IERC20(wmatic).safeApprove(unirouter, 0);\n        IERC20(usdc).safeApprove(swapToken, 0);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/curve/IRewardsGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IRewardsGauge {\n    function balanceOf(address account) external view returns (uint256);\n    function claim_rewards(address _addr) external;\n    function deposit(uint256 _value) external;\n    function withdraw(uint256 _value) external;\n}"
    },
    "contracts/BIFI/interfaces/curve/IStableSwapAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IStableSwapAave {\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount, bool _use_underlying) external;\n}"
    },
    "contracts/BIFI/strategies/Common/YieldBalancer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/beefy/IVault.sol\";\n\n/**\n * @title Yield Balancer\n * @author sirbeefalot\n * @dev This strategy serves as a load balancer for multiple vaults that optimize the same asset.\n *\n * It doesn't implement its own farming strategy and doesn't implement a 'harvest()' function. It insteads\n * distributes the funds deposited into its parent vault into a group of subvaults called 'workers'.\n * Each worker implements its own farming strategy and harvest frequency.\n *\n * The balancer can manage up to {workersMax} workers, due to gas concerns. It can allocate from 0% to 100% of the available\n * funds into each of these workers.\n *\n * The implementation looks to make it as cheap as possible for users to use the vault. The worker at index '0' works as\n * the 'main' worker. It's where user deposits go and where user withdrawals come out first.\n * The balancer then has a few toggles like {rebalancePair} or the global {rebalance} to make sure it achieves and maintains\n * the desired fund distribution between all the workers. The strategy owner can use {switchWorkerOrder} to optimize worker\n * order within the {workers} array.\n *\n * This architecture works on the pragmatic assumption that there's usually a farm on a given platform or within a given asset\n * that can withstand the most TVL. There are secondary farms that can be used to relieve pressure from the main one\n * and to increase overall APY. The calcs to determine optimal allocation ratios happen offchain. This contract provides the tools\n * for trustless fund management and rebalance.\n *\n * It doesn't need exclusive usage of a worker. This is meant so that balancers can be deployed to take advantage of previously\n * deployed vaults, or vaults that some users might want to use directly.\n *\n * Requirements:\n * - Subvaults that serve as workers can't charge withdrawal fees to the balancer.\n */\ncontract YieldBalancer is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev The token that the vault looks to maximize. Configured through the constructor and can't be\n     * changed afterwards.\n     */\n    address public want;\n\n    /**\n     * @dev The parent vault, entry and exit point for users.\n     */\n    address public immutable vault;\n\n    /**\n     * @dev Struct to store proposed candidates before they are accepted as workers.\n     */\n    struct WorkerCandidate {\n        address addr;\n        uint256 proposedTime;\n    }\n\n    /**\n     * @dev Variables for worker and candidate management.\n     * {workers} - Array to keep track of active workers.\n     * {workersMap} - Used to check if a worker exists. Prevents accepting a duplicate worker.\n     * {candidates} - Array to keep track of potential workers that haven't been accepted/rejected.\n     * {approvalDelay} - Seconds that have to pass after a candidate is proposed before it can be accepted.\n     */\n    address[] public workers;\n    mapping (address => bool) public workersMap;\n    WorkerCandidate[] public candidates;\n    uint256 immutable public approvalDelay;\n\n    /**\n     * {workersMax} - Max number of workers that the balancer can manage. Prevents out of gas errors.\n     * {RATIO_MAX} - Aux const used to make sure all available funds are allocated on rebalance.\n     */\n    uint8 immutable public workersMax;\n    uint256 constant public RATIO_MAX = 10000;\n\n    /**\n     * @dev All the events that the contract emits.\n     */\n    event CandidateProposed(address candidate);\n    event CandidateAccepted(address candidate);\n    event CandidateRejected(address candidate);\n    event WorkerDeleted(address worker);\n\n    /**\n     * @dev Initializes the strategy with its parent {vault} and the token that will maximize {want}. It also sets up the\n     * {approvalDelay} that candidates proposed as workers will have to wait before the owner can accept them as workers.\n     *\n     * @param _want Address of the token to maximize.\n     * @param _workers Array of vault addresses that will serve as workers.\n     * @param _approvalDelay Delay in seconds before a candidate can be added as worker.\n     * @param _workersMax Max number of workers that this balancer is allowed to manage.\n     * @param _vault Address of the vault that will manage the strat.\n     */\n    constructor(\n        address _want,\n        address[] memory _workers,\n        uint256 _approvalDelay,\n        uint8 _workersMax,\n        address _vault\n    ) {\n        want = _want;\n        vault = _vault;\n        approvalDelay = _approvalDelay;\n        workersMax = _workersMax;\n\n        _addWorkers(_workers);\n    }\n\n    //--- USER FUNCTIONS ---//\n\n    /**\n     * @notice Puts the funds to work.\n     * @dev Will send all the funds to the main worker, at index 0.\n     */\n    function deposit() public whenNotPaused {\n        _workerDepositAll(0);\n    }\n\n    /**\n     * @dev It withdraws {want} from the workers and sends it to the vault.\n     * @param amount How much {want} to withdraw.\n     */\n    function withdraw(uint256 amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < amount) {\n            for (uint8 i = 0; i < workers.length; i++) {\n                uint256 workerBal = _workerBalance(i);\n                if (workerBal < amount.sub(wantBal)) {\n                    _workerWithdrawAll(i);\n                    wantBal = IERC20(want).balanceOf(address(this));\n                } else {\n                    _workerWithdraw(i, amount.sub(wantBal));\n                    break;\n                }\n            }\n        }\n\n        wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).safeTransfer(vault, wantBal);\n    }\n\n    //--- FUNDS REBALANCE ---//\n\n    /**\n     * @dev Sends all funds from a vault to another one.\n     * @param fromIndex Index of worker to take funds from.\n     * @param toIndex Index of worker where funds will go.\n     */\n    function rebalancePair(uint8 fromIndex, uint8 toIndex) external onlyOwner {\n        require(fromIndex < workers.length, \"!from\");\n        require(toIndex < workers.length, \"!to\");\n\n        _workerWithdrawAll(fromIndex);\n        _workerDepositAll(toIndex);\n    }\n\n    /**\n     * @dev Sends a subset funds from a vault to another one.\n     * @param fromIndex Index of worker to take funds from.\n     * @param toIndex Index of worker where funds will go.\n     * @param amount How much funds to send\n     */\n    function rebalancePairPartial(uint8 fromIndex, uint8 toIndex, uint256 amount) external onlyOwner {\n        require(fromIndex < workers.length, \"!from\");\n        require(toIndex < workers.length, \"!to\");\n\n        _workerWithdraw(fromIndex, amount);\n        _workerDepositAll(toIndex);\n    }\n\n    /**\n     * @dev Rebalance all workers.\n     * @param ratios Array containing the desired balance per worker.\n     */\n    function rebalance(uint256[] memory ratios) external onlyOwner {\n        require(ratios.length == workers.length, \"!balance\");\n        require(_checkRatios(ratios), '!ratios');\n\n        _workersWithdrawAll();\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        for (uint8 i = 0; i < ratios.length; i++) {\n            _workerDeposit(i, wantBal.mul(ratios[i]).div(RATIO_MAX));\n        }\n    }\n\n    /**\n     * @dev Validates that 100% of the funds are allocated\n     * @param ratios Array containing the desired balance ratio per worker.\n    */\n    function _checkRatios(uint256[] memory ratios) pure internal returns (bool) {\n        uint256 ratio = 0;\n        for (uint8 i = 0; i < ratios.length; i++) {\n            ratio += ratios[i];\n        }\n        return ratio == RATIO_MAX;\n    }\n\n    //--- CANDIDATE MANAGEMENT ---//\n\n    /**\n     * @dev Starts the process to add a new worker.\n     * @param candidate Address of worker vault\n     */\n    function proposeCandidate(address candidate) external onlyOwner {\n        require(candidate != address(0), \"!zero\");\n\n        candidates.push(WorkerCandidate({\n            addr: candidate,\n            proposedTime: block.timestamp\n        }));\n\n        emit CandidateProposed(candidate);\n    }\n\n    /**\n     * @dev Adds a candidate to the worker pool. Can only be done after {approvalDelay} has passed.\n     * @param candidateIndex Index of candidate in the {candidates} array.\n     */\n    function acceptCandidate(uint8 candidateIndex) external onlyOwner {\n        require(candidateIndex < candidates.length, \"out of bounds\");\n        require(workers.length < workersMax, \"!capacity\");\n\n        WorkerCandidate memory candidate = candidates[candidateIndex];\n        require(candidate.proposedTime.add(approvalDelay) < block.timestamp, \"!delay\");\n        require(workersMap[candidate.addr] == false, \"!unique\");\n\n        _removeCandidate(candidateIndex);\n        _addWorker(candidate.addr);\n\n        emit CandidateAccepted(candidate.addr);\n    }\n\n    /**\n     * @dev Cancels an attempt to add a worker. Useful in case of an erronoeus proposal,\n     * or a bug found later in an upcoming candidate.\n     * @param candidateIndex Index of candidate in the {candidates} array.\n     */\n    function rejectCandidate(uint8 candidateIndex) external onlyOwner {\n        require(candidateIndex < candidates.length, \"out of bounds\");\n\n        emit CandidateRejected(candidates[candidateIndex].addr);\n\n        _removeCandidate(candidateIndex);\n    }\n\n    /**\n     * @dev Internal function to remove a candidate from the {candidates} array.\n     * @param candidateIndex Index of candidate in the {candidates} array.\n    */\n    function _removeCandidate(uint8 candidateIndex) internal {\n        candidates[candidateIndex] = candidates[candidates.length-1];\n        candidates.pop();\n    }\n\n    //--- WORKER MANAGEMENT ---//\n\n    /**\n     * @dev Function to switch the order of any two workers.\n     * @param workerA Current index of worker A to switch.\n     * @param workerB Current index of worker B to switch.\n     */\n    function switchWorkerOrder(uint8 workerA, uint8 workerB) external onlyOwner {\n        require(workerA != workerB, \"!same\");\n        require(workerA < workers.length, \"A out of bounds\");\n        require(workerB < workers.length, \"B out of bounds\");\n\n        address temp = workers[workerA];\n        workers[workerA] = workers[workerB];\n        workers[workerB] = temp;\n    }\n\n    /**\n     * @dev Withdraws all {want} from a worker and removes it from the options.\n     * The main worker at index 0 can't be deleted.\n     * @param workerIndex Index of worker to delete.\n     */\n    function deleteWorker(uint8 workerIndex) external onlyOwner {\n        require(workerIndex != 0, \"!main\");\n        require(workerIndex < workers.length, \"out of bounds\");\n\n        address worker = workers[workerIndex];\n        IERC20(want).safeApprove(worker, 0);\n\n        _workerWithdrawAll(workerIndex);\n        _removeWorker(workerIndex);\n\n        deposit();\n\n        emit WorkerDeleted(worker);\n    }\n\n    /**\n     * @dev Removes a worker from the workers list and map.\n     * @param workerIndex Index of worker in the array.\n    */\n    function _removeWorker(uint8 workerIndex) internal {\n        address worker = workers[workerIndex];\n        IERC20(want).safeApprove(worker, 0);\n\n        workersMap[worker] = false;\n\n        workers[workerIndex] = workers[workers.length-1];\n        workers.pop();\n    }\n\n    /**\n     * @dev Adds a group of workers to the workers list and map.\n     * @param _workers List of vault addresses.\n    */\n    function _addWorkers(address[] memory _workers) internal {\n        for (uint8 i = 0; i < _workers.length; i++) {\n            _addWorker(_workers[i]);\n        }\n    }\n\n    /**\n     * @dev Adds worker to the workers list and map.\n     * @param worker Address of the vault to use as worker.\n    */\n    function _addWorker(address worker) internal {\n        workersMap[worker] = true;\n        workers.push(worker);\n        IERC20(want).safeApprove(worker, type(uint256).max);\n    }\n\n    //--- FUNDS MANAGEMENT HELPERS ---//\n\n    /**\n     * @dev Give or remove {want} allowance from all workers.\n     * @param amount Allowance to set. Either '0' or 'type(uint).max'\n     */\n    function _workersApprove(uint256 amount) internal {\n        for (uint8 i = 0; i < workers.length; i++) {\n            IERC20(want).safeApprove(workers[i], amount);\n        }\n    }\n\n    /**\n     * @dev Deposits all {want} in the contract into the given worker.\n     * @param workerIndex Index of the worker where the funds will go.\n     */\n    function _workerDepositAll(uint8 workerIndex) internal {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IVault(workers[workerIndex]).deposit(wantBal);\n    }\n\n    /**\n     * @dev Internal function to deposit some {want} into a particular worker.\n     * @param workerIndex Index of the worker to withdraw from.\n     * @param amount How much {want} to deposit.\n    */\n    function _workerDeposit(uint8 workerIndex, uint256 amount) internal {\n        IVault(workers[workerIndex]).deposit(amount);\n    }\n\n    /**\n     * @dev Withdraws all {want} from all workers.\n     */\n    function _workersWithdrawAll() internal {\n        for (uint8 i = 0; i < workers.length; i++) {\n            _workerWithdrawAll(i);\n        }\n    }\n\n    /**\n     * @dev Internal function to withdraw all {want} from a particular worker.\n     * @param workerIndex Index of the worker to withdraw from.\n    */\n    function _workerWithdrawAll(uint8 workerIndex) internal {\n        require(workerIndex < workers.length, \"out of bounds\");\n\n        address worker = workers[workerIndex];\n        uint256 shares = IERC20(worker).balanceOf(address(this));\n\n        if (shares > 0) {\n            IERC20(worker).safeApprove(worker, 0);\n            IERC20(worker).safeApprove(worker, shares);\n            IVault(worker).withdraw(shares);\n        }\n    }\n\n    /**\n     * @dev Internal function to withdraw some {want} from a particular worker.\n     * @param workerIndex Index of the worker to withdraw from.\n     * @param amount How much {want} to withdraw.\n    */\n    function _workerWithdraw(uint8 workerIndex, uint256 amount) internal {\n        require(workerIndex < workers.length, \"out of bounds\");\n\n        address worker = workers[workerIndex];\n        uint256 pricePerFullShare = IVault(worker).getPricePerFullShare();\n        uint256 shares = amount.mul(1e18).div(pricePerFullShare);\n\n        if (shares > 0) {\n            IERC20(worker).safeApprove(worker, 0);\n            IERC20(worker).safeApprove(worker, shares);\n            IVault(worker).withdraw(shares);\n        }\n    }\n\n    //--- STRATEGY LIFECYCLE METHODS ---//\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n       _workersWithdrawAll();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from workers.\n     */\n    function panic() external onlyOwner {\n        _workersWithdrawAll();\n        pause();\n    }\n\n    /**\n     * @dev Pauses the strat. Current funds continue to farm but new deposits\n     * are not allowed.\n     */\n    function pause() public onlyOwner {\n        _pause();\n        _workersApprove(0);\n    }\n\n    /**\n     * @dev Unpauses the strat and restarts farming.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n        _workersApprove(type(uint256).max);\n        deposit();\n    }\n\n    //--- VIEW FUNCTIONS ---//\n\n    /**\n     * @dev Calculates the total underlaying {want} held by the strat.\n     * Takes into account both funds at hand, and funds allocated in workers.\n     */\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant().add(balanceOfWorkers());\n    }\n\n    /**\n     * @dev Calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Calculates the total {want} locked in all workers.\n     */\n    function balanceOfWorkers() public view returns (uint256) {\n        uint256 totalBal = 0;\n\n        for (uint8 i = 0; i < workers.length; i++) {\n            totalBal = totalBal.add(_workerBalance(i));\n        }\n\n        return totalBal;\n    }\n\n    /**\n     * @dev How much {want} the balancer holds in a particular worker.\n     * @param workerIndex Index of the worker to calculate balance.\n     */\n    function _workerBalance(uint8 workerIndex) internal view returns (uint256) {\n        uint256 shares = IERC20(workers[workerIndex]).balanceOf(address(this));\n        uint256 pricePerShare = IVault(workers[workerIndex]).getPricePerFullShare();\n        return shares.mul(pricePerShare).div(1e18);\n    }\n\n    /**\n     * @dev Helps UIs and tests know how many {candidates} there are.\n     */\n    function candidatesLength() external view returns (uint256) {\n        return candidates.length;\n    }\n\n    /**\n     * @dev Helps UIs and tests know how many {workers} there are.\n     */\n    function workersLength() external view returns (uint256) {\n        return workers.length;\n    }\n}"
    },
    "contracts/BIFI/interfaces/beefy/IVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IStrategy.sol\";\n\ninterface IVault is IERC20 {\n    function deposit(uint256) external;\n    function depositAll() external;\n    function withdraw(uint256) external;\n    function withdrawAll() external;\n    function getPricePerFullShare() external view returns (uint256);\n    function upgradeStrat() external;\n    function balance() external view returns (uint256);\n    function want() external view returns (IERC20);\n    function strategy() external view returns (IStrategy);\n}\n"
    },
    "contracts/BIFI/strategies/Common/BeefyLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/beefy/IVault.sol\";\n\n/**\n * @title Yield Balancer\n * @author sirbeefalot\n * @dev This strategy serves as a load balancer for multiple vaults that optimize the same asset.\n *\n * It doesn't implement its own farming strategy and doesn't implement a 'harvest()' function. It insteads\n * distributes the funds deposited into its parent vault into a group of subvaults called 'workers'.\n * Each worker implements its own farming strategy and harvest frequency.\n *\n * The balancer can manage up to {workersMax} workers, due to gas concerns. It can allocate from 0% to 100% of the available\n * funds into each of these workers.\n *\n * The implementation looks to make it as cheap as possible for users to use the vault. The worker at index '0' works as\n * the 'main' worker. It's where user deposits go and where user withdrawals come out first.\n * The balancer then has a few toggles like {rebalancePair} or the global {rebalance} to make sure it achieves and maintains\n * the desired fund distribution between all the workers. The strategy owner can use {switchWorkerOrder} to optimize worker\n * order within the {workers} array.\n *\n * This architecture works on the pragmatic assumption that there's usually a farm on a given platform or within a given asset\n * that can withstand the most TVL. There are secondary farms that can be used to relieve pressure from the main one\n * and to increase overall APY. The calcs to determine optimal allocation ratios happen offchain. This contract provides the tools\n * for trustless fund management and rebalance.\n *\n * It doesn't need exclusive usage of a worker. This is meant so that balancers can be deployed to take advantage of previously\n * deployed vaults, or vaults that some users might want to use directly.\n *\n * Requirements:\n * - Subvaults that serve as workers can't charge withdrawal fees to the balancer.\n */\ncontract BeefyLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev The token that the vault looks to maximize. Configured through the constructor and can't be\n     * changed afterwards.\n     */\n    address public want;\n\n    /**\n     * @dev The parent vault, entry and exit point for users.\n     */\n    address public immutable vault;\n\n    /**\n     * @dev Struct to store proposed candidates before they are accepted as workers.\n     */\n    struct WorkerCandidate {\n        address addr;\n        uint256 proposedTime;\n    }\n\n    /**\n     * @dev Variables for worker and candidate management.\n     * {workers} - Array to keep track of active workers.\n     * {workersMap} - Used to check if a worker exists. Prevents accepting a duplicate worker.\n     * {candidates} - Array to keep track of potential workers that haven't been accepted/rejected.\n     * {approvalDelay} - Seconds that have to pass after a candidate is proposed before it can be accepted.\n     */\n    address[] public workers;\n    mapping (address => bool) public workersMap;\n    WorkerCandidate[] public candidates;\n    uint256 immutable public approvalDelay;\n\n    /**\n     * {workersMax} - Max number of workers that the balancer can manage. Prevents out of gas errors.\n     * {RATIO_MAX} - Aux const used to make sure all available funds are allocated on rebalance.\n     */\n    uint8 immutable public workersMax;\n    uint256 constant public RATIO_MAX = 10000;\n\n    /**\n     * @dev All the events that the contract emits.\n     */\n    event CandidateProposed(address candidate);\n    event CandidateAccepted(address candidate);\n    event CandidateRejected(address candidate);\n    event WorkerDeleted(address worker);\n\n    /**\n     * @dev Initializes the strategy with its parent {vault} and the token that will maximize {want}. It also sets up the\n     * {approvalDelay} that candidates proposed as workers will have to wait before the owner can accept them as workers.\n     *\n     * @param _want Address of the token to maximize.\n     * @param _workers Array of vault addresses that will serve as workers.\n     * @param _approvalDelay Delay in seconds before a candidate can be added as worker.\n     * @param _workersMax Max number of workers that this balancer is allowed to manage.\n     * @param _vault Address of the vault that will manage the strat.\n     */\n    constructor(\n        address _want,\n        address[] memory _workers,\n        uint256 _approvalDelay,\n        uint8 _workersMax,\n        address _vault\n    ) {\n        want = _want;\n        vault = _vault;\n        approvalDelay = _approvalDelay;\n        workersMax = _workersMax;\n\n        _addWorkers(_workers);\n    }\n\n    //--- USER FUNCTIONS ---//\n\n    /**\n     * @notice Puts the funds to work.\n     * @dev Will send all the funds to the main worker, at index 0.\n     */\n    function deposit() public whenNotPaused {\n        _workerDepositAll(0);\n    }\n\n    /**\n     * @dev It withdraws {want} from the workers and sends it to the vault.\n     * @param amount How much {want} to withdraw.\n     */\n    function withdraw(uint256 amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < amount) {\n            for (uint8 i = 0; i < workers.length; i++) {\n                uint256 workerBal = _workerBalance(i);\n                if (workerBal < amount.sub(wantBal)) {\n                    _workerWithdrawAll(i);\n                    wantBal = IERC20(want).balanceOf(address(this));\n                } else {\n                    _workerWithdraw(i, amount.sub(wantBal));\n                    break;\n                }\n            }\n        }\n\n        wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).safeTransfer(vault, wantBal);\n    }\n\n    //--- FUNDS REBALANCE ---//\n\n    /**\n     * @dev Sends all funds from a vault to another one.\n     * @param fromIndex Index of worker to take funds from.\n     * @param toIndex Index of worker where funds will go.\n     */\n    function rebalancePair(uint8 fromIndex, uint8 toIndex) external onlyOwner {\n        require(fromIndex < workers.length, \"!from\");\n        require(toIndex < workers.length, \"!to\");\n\n        _workerWithdrawAll(fromIndex);\n        _workerDepositAll(toIndex);\n    }\n\n    /**\n     * @dev Sends a subset funds from a vault to another one.\n     * @param fromIndex Index of worker to take funds from.\n     * @param toIndex Index of worker where funds will go.\n     * @param amount How much funds to send\n     */\n    function rebalancePairPartial(uint8 fromIndex, uint8 toIndex, uint256 amount) external onlyOwner {\n        require(fromIndex < workers.length, \"!from\");\n        require(toIndex < workers.length, \"!to\");\n\n        _workerWithdraw(fromIndex, amount);\n        _workerDepositAll(toIndex);\n    }\n\n    /**\n     * @dev Rebalance all workers.\n     * @param ratios Array containing the desired balance per worker.\n     */\n    function rebalance(uint256[] memory ratios) external onlyOwner {\n        require(ratios.length == workers.length, \"!balance\");\n        require(_checkRatios(ratios), '!ratios');\n\n        _workersWithdrawAll();\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        for (uint8 i = 0; i < ratios.length; i++) {\n            _workerDeposit(i, wantBal.mul(ratios[i]).div(RATIO_MAX));\n        }\n    }\n\n    /**\n     * @dev Validates that 100% of the funds are allocated\n     * @param ratios Array containing the desired balance ratio per worker.\n    */\n    function _checkRatios(uint256[] memory ratios) pure internal returns (bool) {\n        uint256 ratio = 0;\n        for (uint8 i = 0; i < ratios.length; i++) {\n            ratio += ratios[i];\n        }\n        return ratio == RATIO_MAX;\n    }\n\n    //--- CANDIDATE MANAGEMENT ---//\n\n    /**\n     * @dev Starts the process to add a new worker.\n     * @param candidate Address of worker vault\n     */\n    function proposeCandidate(address candidate) external onlyOwner {\n        require(candidate != address(0), \"!zero\");\n\n        candidates.push(WorkerCandidate({\n            addr: candidate,\n            proposedTime: block.timestamp\n        }));\n\n        emit CandidateProposed(candidate);\n    }\n\n    /**\n     * @dev Adds a candidate to the worker pool. Can only be done after {approvalDelay} has passed.\n     * @param candidateIndex Index of candidate in the {candidates} array.\n     */\n    function acceptCandidate(uint8 candidateIndex) external onlyOwner {\n        require(candidateIndex < candidates.length, \"out of bounds\");\n        require(workers.length < workersMax, \"!capacity\");\n\n        WorkerCandidate memory candidate = candidates[candidateIndex];\n        require(candidate.proposedTime.add(approvalDelay) < block.timestamp, \"!delay\");\n        require(workersMap[candidate.addr] == false, \"!unique\");\n\n        _removeCandidate(candidateIndex);\n        _addWorker(candidate.addr);\n\n        emit CandidateAccepted(candidate.addr);\n    }\n\n    /**\n     * @dev Cancels an attempt to add a worker. Useful in case of an erronoeus proposal,\n     * or a bug found later in an upcoming candidate.\n     * @param candidateIndex Index of candidate in the {candidates} array.\n     */\n    function rejectCandidate(uint8 candidateIndex) external onlyOwner {\n        require(candidateIndex < candidates.length, \"out of bounds\");\n\n        emit CandidateRejected(candidates[candidateIndex].addr);\n\n        _removeCandidate(candidateIndex);\n    }\n\n    /**\n     * @dev Internal function to remove a candidate from the {candidates} array.\n     * @param candidateIndex Index of candidate in the {candidates} array.\n    */\n    function _removeCandidate(uint8 candidateIndex) internal {\n        candidates[candidateIndex] = candidates[candidates.length-1];\n        candidates.pop();\n    }\n\n    //--- WORKER MANAGEMENT ---//\n\n    /**\n     * @dev Function to switch the order of any two workers.\n     * @param workerA Current index of worker A to switch.\n     * @param workerB Current index of worker B to switch.\n     */\n    function switchWorkerOrder(uint8 workerA, uint8 workerB) external onlyOwner {\n        require(workerA != workerB, \"!same\");\n        require(workerA < workers.length, \"A out of bounds\");\n        require(workerB < workers.length, \"B out of bounds\");\n\n        address temp = workers[workerA];\n        workers[workerA] = workers[workerB];\n        workers[workerB] = temp;\n    }\n\n    /**\n     * @dev Withdraws all {want} from a worker and removes it from the options.\n     * The main worker at index 0 can't be deleted.\n     * @param workerIndex Index of worker to delete.\n     */\n    function deleteWorker(uint8 workerIndex) external onlyOwner {\n        require(workerIndex != 0, \"!main\");\n        require(workerIndex < workers.length, \"out of bounds\");\n\n        address worker = workers[workerIndex];\n        IERC20(want).safeApprove(worker, 0);\n\n        _workerWithdrawAll(workerIndex);\n        _removeWorker(workerIndex);\n\n        deposit();\n\n        emit WorkerDeleted(worker);\n    }\n\n    /**\n     * @dev Removes a worker from the workers list and map.\n     * @param workerIndex Index of worker in the array.\n    */\n    function _removeWorker(uint8 workerIndex) internal {\n        address worker = workers[workerIndex];\n        IERC20(want).safeApprove(worker, 0);\n\n        workersMap[worker] = false;\n\n        workers[workerIndex] = workers[workers.length-1];\n        workers.pop();\n    }\n\n    /**\n     * @dev Adds a group of workers to the workers list and map.\n     * @param _workers List of vault addresses.\n    */\n    function _addWorkers(address[] memory _workers) internal {\n        for (uint8 i = 0; i < _workers.length; i++) {\n            _addWorker(_workers[i]);\n        }\n    }\n\n    /**\n     * @dev Adds worker to the workers list and map.\n     * @param worker Address of the vault to use as worker.\n    */\n    function _addWorker(address worker) internal {\n        workersMap[worker] = true;\n        workers.push(worker);\n        IERC20(want).safeApprove(worker, type(uint256).max);\n    }\n\n    //--- FUNDS MANAGEMENT HELPERS ---//\n\n    /**\n     * @dev Give or remove {want} allowance from all workers.\n     * @param amount Allowance to set. Either '0' or 'type(uint).max'\n     */\n    function _workersApprove(uint256 amount) internal {\n        for (uint8 i = 0; i < workers.length; i++) {\n            IERC20(want).safeApprove(workers[i], amount);\n        }\n    }\n\n    /**\n     * @dev Deposits all {want} in the contract into the given worker.\n     * @param workerIndex Index of the worker where the funds will go.\n     */\n    function _workerDepositAll(uint8 workerIndex) internal {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        _workerDeposit(workerIndex, wantBal);\n    }\n\n    /**\n     * @dev Internal function to deposit some {want} into a particular worker.\n     * @param workerIndex Index of the worker to withdraw from.\n     * @param amount How much {want} to deposit.\n    */\n    function _workerDeposit(uint8 workerIndex, uint256 amount) internal {\n        IVault(workers[workerIndex]).deposit(amount);\n    }\n\n    /**\n     * @dev Withdraws all {want} from all workers.\n     */\n    function _workersWithdrawAll() internal {\n        for (uint8 i = 0; i < workers.length; i++) {\n            _workerWithdrawAll(i);\n        }\n    }\n\n    /**\n     * @dev Internal function to withdraw all {want} from a particular worker.\n     * @param workerIndex Index of the worker to withdraw from.\n    */\n    function _workerWithdrawAll(uint8 workerIndex) internal {\n        require(workerIndex < workers.length, \"out of bounds\");\n\n        address worker = workers[workerIndex];\n        uint256 shares = IERC20(worker).balanceOf(address(this));\n\n        if (shares > 0) {\n            IERC20(worker).safeApprove(worker, 0);\n            IERC20(worker).safeApprove(worker, shares);\n            IVault(worker).withdraw(shares);\n        }\n    }\n\n    /**\n     * @dev Internal function to withdraw some {want} from a particular worker.\n     * @param workerIndex Index of the worker to withdraw from.\n     * @param amount How much {want} to withdraw.\n    */\n    function _workerWithdraw(uint8 workerIndex, uint256 amount) internal {\n        require(workerIndex < workers.length, \"out of bounds\");\n\n        address worker = workers[workerIndex];\n        uint256 pricePerFullShare = IVault(worker).getPricePerFullShare();\n        uint256 shares = amount.mul(1e18).div(pricePerFullShare);\n\n        if (shares > 0) {\n            IERC20(worker).safeApprove(worker, 0);\n            IERC20(worker).safeApprove(worker, shares);\n            IVault(worker).withdraw(shares);\n        }\n    }\n\n    //--- STRATEGY LIFECYCLE METHODS ---//\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n       _workersWithdrawAll();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from workers.\n     */\n    function panic() external onlyOwner {\n        _workersWithdrawAll();\n        pause();\n    }\n\n    /**\n     * @dev Pauses the strat. Current funds continue to farm but new deposits\n     * are not allowed.\n     */\n    function pause() public onlyOwner {\n        _pause();\n        _workersApprove(0);\n    }\n\n    /**\n     * @dev Unpauses the strat and restarts farming.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n        _workersApprove(type(uint256).max);\n        deposit();\n    }\n\n    //--- VIEW FUNCTIONS ---//\n\n    /**\n     * @dev Calculates the total underlaying {want} held by the strat.\n     * Takes into account both funds at hand, and funds allocated in workers.\n     */\n    function balanceOf() external view returns (uint256) {\n        return balanceOfWant().add(balanceOfWorkers());\n    }\n\n    /**\n     * @dev Calculates how much {want} the contract holds.\n     */\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    /**\n     * @dev Calculates the total {want} locked in all workers.\n     */\n    function balanceOfWorkers() public view returns (uint256) {\n        uint256 totalBal = 0;\n\n        for (uint8 i = 0; i < workers.length; i++) {\n            totalBal = totalBal.add(_workerBalance(i));\n        }\n\n        return totalBal;\n    }\n\n    /**\n     * @dev How much {want} the balancer holds in a particular worker.\n     * @param workerIndex Index of the worker to calculate balance.\n     */\n    function _workerBalance(uint8 workerIndex) internal view returns (uint256) {\n        uint256 shares = IERC20(workers[workerIndex]).balanceOf(address(this));\n        uint256 pricePerShare = IVault(workers[workerIndex]).getPricePerFullShare();\n        return shares.mul(pricePerShare).div(1e18);\n    }\n\n    /**\n     * @dev Helps UIs and tests know how many {candidates} there are.\n     */\n    function candidatesLength() external view returns (uint256) {\n        return candidates.length;\n    }\n\n    /**\n     * @dev Helps UIs and tests know how many {workers} there are.\n     */\n    function workersLength() external view returns (uint256) {\n        return workers.length;\n    }\n}"
    },
    "contracts/BIFI/interfaces/beefy/IStrategyComplete.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStrategyComplete {\n    function vault() external view returns (address);\n    function want() external view returns (IERC20);\n    function beforeDeposit() external;\n    function deposit() external;\n    function withdraw(uint256) external;\n    function balanceOf() external view returns (uint256);\n    function balanceOfWant() external view returns (uint256);\n    function balanceOfPool() external view returns (uint256);\n    function harvest() external;\n    function retireStrat() external;\n    function panic() external;\n    function pause() external;\n    function unpause() external;\n    function paused() external view returns (bool);\n    function owner() external view returns (address);\n    function keeper() external view returns (address);\n    function setKeeper(address) external;\n    function unirouter() external view returns (address);\n    function beefyFeeRecipient() external view returns (address);\n    function setBeefyFeeRecipient(address) external;\n}\n\n"
    },
    "contracts/BIFI/interfaces/beefy/ISeededVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"./IVault.sol\";\n\ninterface ISeededVault is IVault {\n    function seed() external;\n}\n"
    },
    "contracts/BIFI/strategies/Common/StrategyYieldLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\r\n\r\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\r\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\r\nimport \"../../interfaces/common/IFarm.sol\";\r\nimport \"../../utils/GasThrottler.sol\";\r\nimport \"../Common/StratManager.sol\";\r\nimport \"../Common/FeeManager.sol\";\r\n\r\ncontract StrategyYieldLP is StratManager, FeeManager, GasThrottler {\r\n    using SafeERC20 for IERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // Tokens used\r\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\r\n    address constant public output = address(0xc5A49b4CBe004b6FD55B30Ba1dE6AC360FF9765d);\r\n    address public want;\r\n    address public lpToken0;\r\n    address public lpToken1;\r\n\r\n    // Third party contracts\r\n    address constant public masterchef = address(0x33AdBf5f1ec364a4ea3a5CA8f310B597B8aFDee3);\r\n    uint256 public poolId;\r\n\r\n    // Routes\r\n    address[] public outputToWbnbRoute = [output, wbnb];\r\n    address[] public outputToLp0Route;\r\n    address[] public outputToLp1Route;\r\n\r\n    /**\r\n     * @dev Event that is fired each time someone harvests the strat.\r\n     */\r\n    event StratHarvest(address indexed harvester);\r\n\r\n    constructor(\r\n        address _want,\r\n        uint256 _poolId,\r\n        address _vault,\r\n        address _unirouter,\r\n        address _keeper,\r\n        address _strategist,\r\n        address _beefyFeeRecipient\r\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\r\n        want = _want;\r\n        lpToken0 = IUniswapV2Pair(want).token0();\r\n        lpToken1 = IUniswapV2Pair(want).token1();\r\n        poolId = _poolId;\r\n\r\n        if (lpToken0 == wbnb) {\r\n            outputToLp0Route = [output, wbnb];\r\n        } else if (lpToken0 != output) {\r\n            outputToLp0Route = [output, wbnb,lpToken0];\r\n        }\r\n\r\n        if (lpToken1 == wbnb) {\r\n            outputToLp1Route = [output, wbnb];\r\n        } else if (lpToken1 != output) {\r\n            outputToLp1Route = [output, wbnb, lpToken1];\r\n        }\r\n\r\n        _giveAllowances();\r\n    }\r\n\r\n    // puts the funds to work\r\n    function deposit() public whenNotPaused {\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal > 0) {\r\n            IFarm(masterchef).deposit(poolId, wantBal);\r\n        }\r\n    }\r\n\r\n    function withdraw(uint256 _amount) external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n\r\n        if (wantBal < _amount) {\r\n            IFarm(masterchef).withdraw(poolId, _amount.sub(wantBal));\r\n            wantBal = IERC20(want).balanceOf(address(this));\r\n        }\r\n\r\n        if (wantBal > _amount) {\r\n            wantBal = _amount;\r\n        }\r\n\r\n\r\n        IERC20(want).safeTransfer(vault, wantBal);\r\n    }\r\n\r\n    // compounds earnings and charges performance fee\r\n    function harvest() external whenNotPaused onlyEOA gasThrottle {\r\n        IFarm(masterchef).deposit(poolId, 0);\r\n        chargeFees();\r\n        addLiquidity();\r\n        deposit();\r\n\r\n        emit StratHarvest(msg.sender);\r\n    }\r\n\r\n    // performance fees\r\n    function chargeFees() internal {\r\n        uint256 toWbnb = IERC20(output).balanceOf(address(this)).mul(45).div(1000);\r\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, outputToWbnbRoute, address(this), block.timestamp);\r\n\r\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\r\n\r\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\r\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\r\n\r\n        uint256 beefyFeeAmount = wbnbBal.mul(beefyFee).div(MAX_FEE);\r\n        IERC20(wbnb).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\r\n\r\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\r\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\r\n    }\r\n\r\n    // Adds liquidity to AMM and gets more LP tokens.\r\n    function addLiquidity() internal {\r\n        uint256 outputHalf = IERC20(output).balanceOf(address(this)).div(2);\r\n\r\n        if (lpToken0 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp0Route, address(this), block.timestamp);\r\n        }\r\n\r\n        if (lpToken1 != output) {\r\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(outputHalf, 0, outputToLp1Route, address(this), block.timestamp);\r\n        }\r\n\r\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\r\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\r\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp);\r\n    }\r\n\r\n    // calculate the total underlaying 'want' held by the strat.\r\n    function balanceOf() public view returns (uint256) {\r\n        return balanceOfWant().add(balanceOfPool());\r\n    }\r\n\r\n    // it calculates how much 'want' this contract holds.\r\n    function balanceOfWant() public view returns (uint256) {\r\n        return IERC20(want).balanceOf(address(this));\r\n    }\r\n\r\n    // it calculates how much 'want' the strategy has working in the farm.\r\n    function balanceOfPool() public view returns (uint256) {\r\n        return IFarm(masterchef).stakedWantTokens(poolId, address(this));\r\n    }\r\n\r\n    // called as part of strat migration. Sends all the available funds back to the vault.\r\n    function retireStrat() external {\r\n        require(msg.sender == vault, \"!vault\");\r\n\r\n        IFarm(masterchef).emergencyWithdraw(poolId);\r\n\r\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\r\n        IERC20(want).transfer(vault, wantBal);\r\n    }\r\n\r\n    // pauses deposits and withdraws all funds from third party systems.\r\n    function panic() public onlyManager {\r\n        pause();\r\n        IFarm(masterchef).emergencyWithdraw(poolId);\r\n    }\r\n\r\n    function pause() public onlyManager {\r\n        _pause();\r\n\r\n        _removeAllowances();\r\n    }\r\n\r\n    function unpause() external onlyManager {\r\n        _unpause();\r\n\r\n        _giveAllowances();\r\n\r\n        deposit();\r\n    }\r\n\r\n    function _giveAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, type(uint256).max);\r\n        IERC20(output).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, type(uint256).max);\r\n\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, type(uint256).max);\r\n    }\r\n\r\n    function _removeAllowances() internal {\r\n        IERC20(want).safeApprove(masterchef, 0);\r\n        IERC20(output).safeApprove(unirouter, 0);\r\n        IERC20(lpToken0).safeApprove(unirouter, 0);\r\n        IERC20(lpToken1).safeApprove(unirouter, 0);\r\n    }\r\n}"
    },
    "contracts/BIFI/interfaces/common/IFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\npragma abicoder v1;\r\n\r\ninterface IFarm {\r\n    function poolInfo(uint256 _pid) external view returns (address, uint256, uint256, uint256, address);\r\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\r\n    function stakedWantTokens(uint256 _pid, address _user) external view returns (uint256);\r\n    function deposit(uint256 _pid, uint256 _wantAmt) external;\r\n    function withdraw(uint256 _pid, uint256 _wantAmt) external;\r\n    function withdrawAll(uint256 _pid) external;\r\n    function emergencyWithdraw(uint256 _pid) external;\r\n}"
    },
    "contracts/BIFI/strategies/BDollar/StrategyBdoLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/bdollar/IBdoRewardPool.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in PancakeSwap.\n * PancakeSwap is an automated market maker (AMM) that allows two tokens to be exchanged on the Binance Smart Chain.\n * It is fast, cheap, and allows anyone to participate. PancakeSwap is aiming to be the #1 liquidity provider on BSC.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected BdoRewardPool pool.\n * BDO rewards from providing liquidity are farmed every few minutes, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the BdoRewardPool pool.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyBdoLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {bdo} - Token generated by staking our funds. In this case it's the BDOs token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bdo = address(0x190b589cf9Fb8DDEabBFeae36a813FFb2A702454);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {bdoRewardPool} - BdoRewardPool contract\n     * {poolId} - BdoRewardPool pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public bdoRewardPool = address(0x7A4cFC24841c799832fFF4E5038BBA14c0e73ced);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - -.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {bdoToWbnbRoute} - Route we take to get from {bdo} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {bdoToLp0Route} - Route we take to get from {bdo} into {lpToken0}.\n     * {bdoToLp1Route} - Route we take to get from {bdo} into {lpToken1}.\n     */\n    address[] public bdoToWbnbRoute = [bdo, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public bdoToLp0Route;\n    address[] public bdoToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            bdoToLp0Route = [bdo, wbnb];\n        } else if (lpToken0 != bdo) {\n            bdoToLp0Route = [bdo, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            bdoToLp1Route = [bdo, wbnb];\n        } else if (lpToken1 != bdo) {\n            bdoToLp1Route = [bdo, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(bdoRewardPool, type(uint).max);\n        IERC20(bdo).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the bdoRewardPool to farm {bdo}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IBdoRewardPool(bdoRewardPool).deposit(poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the BdoRewardPool.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IBdoRewardPool(bdoRewardPool).withdraw(poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the BdoRewardPool.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {bdo} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IBdoRewardPool(bdoRewardPool).deposit(poolId, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(bdo).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, bdoToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {bdo} for {lpToken0}, {lpToken1} & {wbnb} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 bdoHalf = IERC20(bdo).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != bdo) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(bdoHalf, 0, bdoToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != bdo) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(bdoHalf, 0, bdoToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the BdoRewardPool.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the IBdoRewardPool\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IBdoRewardPool(bdoRewardPool).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IBdoRewardPool(bdoRewardPool).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the BdoRewardPool, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IBdoRewardPool(bdoRewardPool).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(bdoRewardPool, 0);\n        IERC20(bdo).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(bdoRewardPool, type(uint).max);\n        IERC20(bdo).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/bdollar/IBdoRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBdoRewardPool {\n    function deposit(uint256 _pid, uint256 _amount) external;\n    function withdraw(uint256 _pid, uint256 _amount) external;\n    function pendingBDO(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Bakery/StrategyBakeryLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/bakery/IBakerySwapRouter.sol\";\nimport \"../../interfaces/bakery/IBakerySwapPair.sol\";\nimport \"../../interfaces/bakery/IBakeryMaster.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming LP Pools in BakerySwap.\n *\n * This strat is currently compatible with all LP pools.\n */\ncontract StrategyBakeryLP is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {bake} - Token generated by staking our funds. In this case it's the {bake} token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IBakerySwapPair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bake = address(0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - BakerySwap unirouter\n     * {bakeryMaster} - BakeryMaster contract\n     */\n    address constant public unirouter = address(0xCDe540d7eAFE93aC5fE6233Bee57E1270D3E330F);\n    address constant public bakeryMaster = address(0x20eC291bB8459b6145317E7126532CE7EcE5056f);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using BakerySwap.\n     * {bakeToWbnbRoute} - Route we take to get from {bake} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {bakeToLp0Route} - Route we take to get from {bake} into {lpToken0}.\n     * {bakeToLp1Route} - Route we take to get from {bake} into {lpToken1}.\n     */\n    address[] public bakeToWbnbRoute = [bake, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public bakeToLp0Route;\n    address[] public bakeToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IBakerySwapPair(lpPair).token0();\n        lpToken1 = IBakerySwapPair(lpPair).token1();\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            bakeToLp0Route = [bake, wbnb];\n        } else if (lpToken0 != bake) {\n            bakeToLp0Route = [bake, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            bakeToLp1Route = [bake, wbnb];\n        } else if (lpToken1 != bake) {\n            bakeToLp1Route = [bake, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(bakeryMaster, type(uint).max);\n        IERC20(bake).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the BakeryMaster to farm {bake}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IBakeryMaster(bakeryMaster).deposit(lpPair, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sents them back to the vault.\n     * It withdraws {lpPair} from the BakeryMaster.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IBakeryMaster(bakeryMaster).withdraw(lpPair, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the BakeryMaster.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {bake} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IBakeryMaster(bakeryMaster).deposit(lpPair, 0);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(bake).balanceOf(address(this)).mul(45).div(1000);\n        IBakerySwapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, bakeToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IBakerySwapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {bake} for {lpToken0}, {lpToken1} & {wbnb} using BakerySwap.\n     */\n    function addLiquidity() internal {\n        uint256 bakeHalf = IERC20(bake).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != bake) {\n            IBakerySwapRouter(unirouter).swapExactTokensForTokens(bakeHalf, 0, bakeToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != bake) {\n            IBakerySwapRouter(unirouter).swapExactTokensForTokens(bakeHalf, 0, bakeToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IBakerySwapRouter(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the BakeryMaster.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the BakeryMaster\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IBakeryMaster(bakeryMaster).poolUserInfoMap(lpPair, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IBakeryMaster(bakeryMaster).emergencyWithdraw(lpPair);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).transfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the BakeryMaster, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IBakeryMaster(bakeryMaster).emergencyWithdraw(lpPair);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(bakeryMaster, 0);\n        IERC20(bake).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(bakeryMaster, type(uint).max);\n        IERC20(bake).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/bakery/IBakerySwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBakerySwapRouter {\n    function factory() external pure returns (address);\n\n    function WBNB() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityBNB(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountBNBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountBNB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityBNB(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountBNBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountBNB);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityBNBWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountBNBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountBNB);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactBNBForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactBNB(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForBNB(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapBNBForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function removeLiquidityBNBSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountBNBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountBNB);\n\n    function removeLiquidityBNBWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountBNBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountBNB);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactBNBForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForBNBSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n}"
    },
    "contracts/BIFI/interfaces/bakery/IBakerySwapPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBakerySwapPair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/BIFI/interfaces/bakery/IBakeryMaster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IBakeryMaster {\n    function deposit(address _pair, uint256 _amount) external;\n    function withdraw(address _pair, uint256 _amount) external;\n    function pendingBake(address _pair, address _user) external view returns (uint256);\n    function poolUserInfoMap(address _pair, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(address _pair) external;\n}"
    },
    "contracts/BIFI/strategies/Bakery/StrategyBake.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/bakery/IBakerySwapRouter.sol\";\nimport \"../../interfaces/bakery/IBakeryMaster.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming Bake in BakerySwap.\n */\ncontract StrategyBake is Ownable, Pausable {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {bake} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bake = address(0xE02dF9e3e622DeBdD69fb838bB799E3F168902c5);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - BakerySwap unirouter\n     * {bakeryMaster} - BakeryMaster contract. Stake Tokens, get rewards.\n     */\n    address constant public unirouter  = address(0xCDe540d7eAFE93aC5fE6233Bee57E1270D3E330F);\n    address constant public bakeryMaster = address(0x20eC291bB8459b6145317E7126532CE7EcE5056f);\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3.5% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE  = 777;\n    uint constant public CALL_FEE     = 111;\n    uint constant public TREASURY_FEE = 112;\n    uint constant public MAX_FEE      = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using BakerySwap.\n     * {bakeToWbnbRoute} - Route we take to go from {bake} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to go from {wbnb} into {bifi}.\n     */\n    address[] public bakeToWbnbRoute = [bake, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest(address indexed harvester);\n\n    /**\n     * @dev Initializes the strategy with the token that it will look to maximize.\n     */\n    constructor(address _vault) {\n        vault = _vault;\n\n        IERC20(bake).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits bake in the BakeryMaster to earn rewards in bake.\n     */\n    function deposit() public whenNotPaused {\n        uint256 bakeBal = IERC20(bake).balanceOf(address(this));\n\n        if (bakeBal > 0) {\n            IERC20(bake).safeApprove(bakeryMaster, 0);\n            IERC20(bake).safeApprove(bakeryMaster, bakeBal);\n            IBakeryMaster(bakeryMaster).deposit(bake, bakeBal);\n        }\n    }\n\n    /**\n     * @dev It withdraws bake from the BakeryMaster and sends it to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 bakeBal = IERC20(bake).balanceOf(address(this));\n\n        if (bakeBal < _amount) {\n            IBakeryMaster(bakeryMaster).withdraw(bake, _amount.sub(bakeBal));\n            bakeBal = IERC20(bake).balanceOf(address(this));\n        }\n\n        if (bakeBal > _amount) {\n            bakeBal = _amount;\n        }\n\n        uint256 withdrawalFee = bakeBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n        IERC20(bake).safeTransfer(vault, bakeBal.sub(withdrawalFee));\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the BakeryMaster\n     * 3. It charges the system fee and sends it to BIFI stakers.\n     * 4. It re-invests the remaining profits.\n     */\n    function harvest() external whenNotPaused {\n        require(!Address.isContract(msg.sender), \"!contract\");\n        IBakeryMaster(bakeryMaster).deposit(bake, 0);\n        chargeFees();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 3.5% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(bake).balanceOf(address(this)).mul(45).div(1000);\n        IBakerySwapRouter(unirouter).swapExactTokensForTokens(toWbnb, 0, bakeToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IBakerySwapRouter(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {bake} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the BakeryMaster.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfBake().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {bake} the contract holds.\n     */\n    function balanceOfBake() public view returns (uint256) {\n        return IERC20(bake).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {bake} the strategy has allocated in the BakeryMaster\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IBakeryMaster(bakeryMaster).poolUserInfoMap(bake, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external onlyOwner {\n        panic();\n\n        uint256 bakeBal = IERC20(bake).balanceOf(address(this));\n        IERC20(bake).transfer(vault, bakeBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the BakeryMaster, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IBakeryMaster(bakeryMaster).emergencyWithdraw(bake);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(bake).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(bake).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n}"
    },
    "contracts/BIFI/strategies/Alpaca/StrategyStronkAlpaca.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/alpaca/IFairLaunch.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming with sALPACA.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected FairLaunch pool.\n * ALPACA rewards from providing liquidity are farmed every few hours, sold and used to buy more sALPACA.\n *\n */\ncontract StrategyStronkAlpaca is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {alpaca} - Token generated by staking our funds. In this case it's the ALPACA token.\n     * {sAlpaca} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address constant public alpaca = address(0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F);\n    address constant public sAlpaca = address(0x6F695Bd5FFD25149176629f8491A5099426Ce7a7);\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {fairLaunch} - Alpaca FairLaunch contract\n     * {poolId} - FairLaunch pool id for {sAlpaca}\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public fairLaunch = address(0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F);\n    uint8 public poolId = 5;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     * {keeper} - Address used as an extra strat manager.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n    address public keeper;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_CALL_FEE} - Max value that the {callFee} can be configured to.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     *\n     * {callFee} - 0.5% goes to whoever executes the harvest. Can be lowered.\n     * {rewardsFee} - 3% that goes to BIFI holders. Can be increased by decreasing {callFee}.\n     */\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE = 1000;\n    uint constant public MAX_CALL_FEE = 111;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    uint public callFee = 111;\n    uint public rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {alpacaToWbnbRoute} - Route we take to get from {alpaca} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {alpacaToSalpacaRoute} - Route we take to get from {alpaca} into {sAlpaca}.\n     */\n    address[] public alpacaToWbnbRoute = [alpaca, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public alpacaToSalpacaRoute = [alpaca, sAlpaca];\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest();\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     * @param _vault address of the parent vault\n     * @param _strategist address that will receive the {STRATEGIST_FEE}\n     * @param _keeper address that will help manage the strat\n     */\n    constructor(address _vault, address _strategist, address _keeper) {\n        vault = _vault;\n        strategist = _strategist;\n        keeper = _keeper;\n\n        IERC20(sAlpaca).safeApprove(fairLaunch, type(uint).max);\n        IERC20(alpaca).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {sAlpaca} in the FairLaunch to farm {alpaca}\n     */\n    function deposit() public whenNotPaused {\n        uint256 sAlpacaBal = IERC20(sAlpaca).balanceOf(address(this));\n\n        if (sAlpacaBal > 0) {\n            IFairLaunch(fairLaunch).deposit(address(this), poolId, sAlpacaBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {sAlpaca} from the FairLaunch.\n     * The available {sAlpaca} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 sAlpacaBal = IERC20(sAlpaca).balanceOf(address(this));\n\n        if (sAlpacaBal < _amount) {\n            IFairLaunch(fairLaunch).withdraw(address(this), poolId, _amount.sub(sAlpacaBal));\n            sAlpacaBal = IERC20(sAlpaca).balanceOf(address(this));\n        }\n\n        if (sAlpacaBal > _amount) {\n            sAlpacaBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(sAlpaca).safeTransfer(vault, sAlpacaBal);\n        } else {\n            uint256 withdrawalFee = sAlpacaBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(sAlpaca).safeTransfer(vault, sAlpacaBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Public harvest. Doesn't work when the strat is paused.\n     */\n    function harvest() external whenNotPaused {\n        _harvest();\n    }\n\n    /**\n     * @dev Harvest to keep the strat working while paused. Helpful in some cases.\n     */\n    function sudoHarvest() external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _harvest();\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the FairLaunch.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {alpaca} token for more {sAlpaca}\n     * 4. Deposits {sAlpaca} into the FairLaunch again.\n     */\n    function _harvest() internal gasThrottle {\n        IFairLaunch(fairLaunch).harvest(poolId);\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest();\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(alpaca).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, alpacaToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFeeAmount = wbnbBal.mul(callFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFeeAmount = wbnbBal.mul(rewardsFee).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFeeAmount);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps whatever {alpaca} it has for more {sAlpaca}.\n     */\n    function swapRewards() internal {\n        uint256 alpacaBal = IERC20(alpaca).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(alpacaBal, 0, alpacaToSalpacaRoute, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {sAlpaca} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the FairLaunch.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfStrat().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {sAlpaca} the contract holds.\n     */\n    function balanceOfStrat() public view returns (uint256) {\n        return IERC20(sAlpaca).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {sAlpaca} the strategy has allocated in the FairLaunch\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IFairLaunch(fairLaunch).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IFairLaunch(fairLaunch).emergencyWithdraw(poolId);\n\n        uint256 sAlpacaBal = IERC20(sAlpaca).balanceOf(address(this));\n        IERC20(sAlpaca).safeTransfer(vault, sAlpacaBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the FairLaunch, leaving rewards behind\n     */\n    function panic() public {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        IFairLaunch(fairLaunch).emergencyWithdraw(poolId);\n        pause();\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _pause();\n\n        IERC20(sAlpaca).safeApprove(fairLaunch, 0);\n        IERC20(alpaca).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        _unpause();\n\n        IERC20(sAlpaca).safeApprove(fairLaunch, type(uint).max);\n        IERC20(alpaca).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n\n    /**\n     * @dev Updates address of the strat keeper.\n     * @param _keeper new keeper address.\n     */\n    function setKeeper(address _keeper) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        keeper = _keeper;\n    }\n\n    /**\n     * @dev Updates the harvest {callFee}. Capped by {MAX_CALL_FEE}.\n     * @param _fee new fee to give harvesters.\n     */\n    function setCallFee(uint256 _fee) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n        require(_fee <= MAX_CALL_FEE, \"!cap\");\n\n        callFee = _fee;\n        rewardsFee = MAX_FEE - TREASURY_FEE - STRATEGIST_FEE - callFee;\n    }\n\n    /**\n     * @dev Rescues random funds stuck that the strat can't handle.\n     * @param _token address oof the tkoen to rescue.\n     */\n    function inCaseTokensGetStuck(address _token) external {\n        require(msg.sender == owner() || msg.sender == keeper, \"!authorized\");\n\n        require(_token != wbnb, \"!wbnb\");\n        require(_token != bifi, \"!bifi\");\n        require(_token != alpaca, \"!alpaca\");\n        require(_token != sAlpaca, \"!sAlpaca\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/BIFI/interfaces/alpaca/IFairLaunch.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IFairLaunch {\n    function deposit(address _for, uint256 _pid, uint256 _amount) external;\n    function withdraw(address _for, uint256 _pid, uint256 _amount) external;\n    function pendingAlpaca(uint256 _pid, address _user) external view returns (uint256);\n    function userInfo(uint256 _pid, address _user) external view returns (uint256, uint256);\n    function emergencyWithdraw(uint256 _pid) external;\n    function harvest(uint256 _pid) external;\n}"
    },
    "contracts/BIFI/strategies/Alpaca/StrategyAlpacaLP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../../interfaces/common/IUniswapV2Pair.sol\";\nimport \"../../interfaces/alpaca/IFairLaunch.sol\";\nimport \"../../utils/GasThrottler.sol\";\n\n/**\n * @dev Implementation of a strategy to get yields from farming an LP from Alpaca.\n *\n * This strategy simply deposits whatever funds it receives from the vault into the selected FairLaunch pool.\n * ALPACA rewards from providing liquidity are farmed every few hours, sold and split 50/50.\n * The corresponding pair of assets are bought and more liquidity is added to the FairLaunch pool.\n *\n */\ncontract StrategyAlpacaLP is Ownable, Pausable, GasThrottler {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    /**\n     * @dev Tokens Used:\n     * {wbnb} - Required for liquidity routing when doing swaps.\n     * {alpaca} - Token generated by staking our funds. In this case it's the ALPACA token.\n     * {bifi} - BeefyFinance token, used to send funds to the treasury.\n     * {lpPair} - Token that the strategy maximizes. The same token that users deposit in the vault.\n     * {lpToken0, lpToken1} - Tokens that the strategy maximizes. IUniswapV2Pair tokens\n     */\n    address constant public wbnb = address(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);\n    address constant public alpaca = address(0x8F0528cE5eF7B51152A59745bEfDD91D97091d2F);\n    address constant public bifi = address(0xCa3F508B8e4Dd382eE878A314789373D80A5190A);\n    address public lpPair;\n    address public lpToken0;\n    address public lpToken1;\n\n    /**\n     * @dev Third Party Contracts:\n     * {unirouter} - PancakeSwap unirouter\n     * {fairLaunch} - Alpaca FairLaunch contract\n     * {poolId} - FairLaunch pool id\n     */\n    address constant public unirouter  = address(0x05fF2B0DB69458A0750badebc4f9e13aDd608C7F);\n    address constant public fairLaunch = address(0xA625AB01B08ce023B2a342Dbb12a16f2C8489A8F);\n    uint8 public poolId;\n\n    /**\n     * @dev Beefy Contracts:\n     * {rewards} - Reward pool where the strategy fee earnings will go.\n     * {treasury} - Address of the BeefyFinance treasury\n     * {vault} - Address of the vault that controls the strategy's funds.\n     * {strategist} - Address of the strategy author/deployer where strategist fee will go.\n     */\n    address constant public rewards  = address(0x453D4Ba9a2D594314DF88564248497F7D74d6b2C);\n    address constant public treasury = address(0x4A32De8c248533C28904b24B4cFCFE18E9F2ad01);\n    address public vault;\n    address public strategist;\n\n    /**\n     * @dev Distribution of fees earned. This allocations relative to the % implemented on doSplit().\n     * Current implementation separates 4.5% for fees.\n     *\n     * {REWARDS_FEE} - 3% goes to BIFI holders through the {rewards} pool.\n     * {CALL_FEE} - 0.5% goes to whoever executes the harvest function as gas subsidy.\n     * {TREASURY_FEE} - 0.5% goes to the treasury.\n     * {STRATEGIST_FEE} - 0.5% goes to the strategist.\n     * {MAX_FEE} - Aux const used to safely calc the correct amounts.\n     *\n     * {WITHDRAWAL_FEE} - Fee taxed when a user withdraws funds. 10 === 0.1% fee.\n     * {WITHDRAWAL_MAX} - Aux const used to safely calc the correct amounts.\n     */\n    uint constant public REWARDS_FEE    = 665;\n    uint constant public CALL_FEE       = 111;\n    uint constant public TREASURY_FEE   = 112;\n    uint constant public STRATEGIST_FEE = 112;\n    uint constant public MAX_FEE        = 1000;\n\n    uint constant public WITHDRAWAL_FEE = 10;\n    uint constant public WITHDRAWAL_MAX = 10000;\n\n    /**\n     * @dev Routes we take to swap tokens using PancakeSwap.\n     * {alpacaToWbnbRoute} - Route we take to get from {alpaca} into {wbnb}.\n     * {wbnbToBifiRoute} - Route we take to get from {wbnb} into {bifi}.\n     * {alpacaToLp0Route} - Route we take to get from {alpaca} into {lpToken0}.\n     * {alpacaToLp1Route} - Route we take to get from {alpaca} into {lpToken1}.\n     */\n    address[] public alpacaToWbnbRoute = [alpaca, wbnb];\n    address[] public wbnbToBifiRoute = [wbnb, bifi];\n    address[] public alpacaToLp0Route;\n    address[] public alpacaToLp1Route;\n\n    /**\n     * @dev Event that is fired each time someone harvests the strat.\n     */\n    event StratHarvest();\n\n    /**\n     * @dev Initializes the strategy with the token to maximize.\n     */\n    constructor(address _lpPair, uint8 _poolId, address _vault, address _strategist) {\n        lpPair = _lpPair;\n        lpToken0 = IUniswapV2Pair(lpPair).token0();\n        lpToken1 = IUniswapV2Pair(lpPair).token1();\n        poolId = _poolId;\n        vault = _vault;\n        strategist = _strategist;\n\n        if (lpToken0 == wbnb) {\n            alpacaToLp0Route = [alpaca, wbnb];\n        } else if (lpToken0 != alpaca) {\n            alpacaToLp0Route = [alpaca, wbnb, lpToken0];\n        }\n\n        if (lpToken1 == wbnb) {\n            alpacaToLp1Route = [alpaca, wbnb];\n        } else if (lpToken1 != alpaca) {\n            alpacaToLp1Route = [alpaca, wbnb, lpToken1];\n        }\n\n        IERC20(lpPair).safeApprove(fairLaunch, type(uint).max);\n        IERC20(alpaca).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Function that puts the funds to work.\n     * It gets called whenever someone deposits in the strategy's vault contract.\n     * It deposits {lpPair} in the FairLaunch to farm {alpaca}\n     */\n    function deposit() public whenNotPaused {\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal > 0) {\n            IFairLaunch(fairLaunch).deposit(address(this), poolId, pairBal);\n        }\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault.\n     * It withdraws {lpPair} from the FairLaunch.\n     * The available {lpPair} minus fees is returned to the vault.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n\n        if (pairBal < _amount) {\n            IFairLaunch(fairLaunch).withdraw(address(this), poolId, _amount.sub(pairBal));\n            pairBal = IERC20(lpPair).balanceOf(address(this));\n        }\n\n        if (pairBal > _amount) {\n            pairBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(lpPair).safeTransfer(vault, pairBal);\n        } else {\n            uint256 withdrawalFee = pairBal.mul(WITHDRAWAL_FEE).div(WITHDRAWAL_MAX);\n            IERC20(lpPair).safeTransfer(vault, pairBal.sub(withdrawalFee));\n        }\n    }\n\n    /**\n     * @dev Core function of the strat, in charge of collecting and re-investing rewards.\n     * 1. It claims rewards from the FairLaunch.\n     * 2. It charges the system fees to simplify the split.\n     * 3. It swaps the {alpaca} token for {lpToken0} & {lpToken1}\n     * 4. Adds more liquidity to the pool.\n     * 5. It deposits the new LP tokens.\n     */\n    function harvest() external whenNotPaused gasThrottle {\n        IFairLaunch(fairLaunch).harvest(poolId);\n        chargeFees();\n        addLiquidity();\n        deposit();\n\n        emit StratHarvest();\n    }\n\n    /**\n     * @dev Takes out 4.5% as system fees from the rewards.\n     * 0.5% -> Call Fee\n     * 0.5% -> Treasury fee\n     * 0.5% -> Strategist fee\n     * 3.0% -> BIFI Holders\n     */\n    function chargeFees() internal {\n        uint256 toWbnb = IERC20(alpaca).balanceOf(address(this)).mul(45).div(1000);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(toWbnb, 0, alpacaToWbnbRoute, address(this), block.timestamp.add(600));\n\n        uint256 wbnbBal = IERC20(wbnb).balanceOf(address(this));\n\n        uint256 callFee = wbnbBal.mul(CALL_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(msg.sender, callFee);\n\n        uint256 treasuryHalf = wbnbBal.mul(TREASURY_FEE).div(MAX_FEE).div(2);\n        IERC20(wbnb).safeTransfer(treasury, treasuryHalf);\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(treasuryHalf, 0, wbnbToBifiRoute, treasury, block.timestamp.add(600));\n\n        uint256 rewardsFee = wbnbBal.mul(REWARDS_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(rewards, rewardsFee);\n\n        uint256 strategistFee = wbnbBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wbnb).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Swaps {alpaca} for {lpToken0} and {lpToken1} using PancakeSwap.\n     */\n    function addLiquidity() internal {\n        uint256 alpacaHalf = IERC20(alpaca).balanceOf(address(this)).div(2);\n\n        if (lpToken0 != alpaca) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(alpacaHalf, 0, alpacaToLp0Route, address(this), block.timestamp.add(600));\n        }\n\n        if (lpToken1 != alpaca) {\n            IUniswapRouterETH(unirouter).swapExactTokensForTokens(alpacaHalf, 0, alpacaToLp1Route, address(this), block.timestamp.add(600));\n        }\n\n        uint256 lp0Bal = IERC20(lpToken0).balanceOf(address(this));\n        uint256 lp1Bal = IERC20(lpToken1).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).addLiquidity(lpToken0, lpToken1, lp0Bal, lp1Bal, 1, 1, address(this), block.timestamp.add(600));\n    }\n\n    /**\n     * @dev Function to calculate the total underlaying {lpPair} held by the strat.\n     * It takes into account both the funds in hand, as the funds allocated in the FairLaunch.\n     */\n    function balanceOf() public view returns (uint256) {\n        return balanceOfLpPair().add(balanceOfPool());\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the contract holds.\n     */\n    function balanceOfLpPair() public view returns (uint256) {\n        return IERC20(lpPair).balanceOf(address(this));\n    }\n\n    /**\n     * @dev It calculates how much {lpPair} the strategy has allocated in the FairLaunch\n     */\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 _amount, ) = IFairLaunch(fairLaunch).userInfo(poolId, address(this));\n        return _amount;\n    }\n\n    /**\n     * @dev Function that has to be called as part of strat migration. It sends all the available funds back to the\n     * vault, ready to be migrated to the new strat.\n     */\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        IFairLaunch(fairLaunch).emergencyWithdraw(poolId);\n\n        uint256 pairBal = IERC20(lpPair).balanceOf(address(this));\n        IERC20(lpPair).safeTransfer(vault, pairBal);\n    }\n\n    /**\n     * @dev Pauses deposits. Withdraws all funds from the FairLaunch, leaving rewards behind\n     */\n    function panic() public onlyOwner {\n        pause();\n        IFairLaunch(fairLaunch).emergencyWithdraw(poolId);\n    }\n\n    /**\n     * @dev Pauses the strat.\n     */\n    function pause() public onlyOwner {\n        _pause();\n\n        IERC20(lpPair).safeApprove(fairLaunch, 0);\n        IERC20(alpaca).safeApprove(unirouter, 0);\n        IERC20(wbnb).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n    }\n\n    /**\n     * @dev Unpauses the strat.\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n\n        IERC20(lpPair).safeApprove(fairLaunch, type(uint).max);\n        IERC20(alpaca).safeApprove(unirouter, type(uint).max);\n        IERC20(wbnb).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken0).safeApprove(unirouter, 0);\n        IERC20(lpToken0).safeApprove(unirouter, type(uint).max);\n\n        IERC20(lpToken1).safeApprove(unirouter, 0);\n        IERC20(lpToken1).safeApprove(unirouter, type(uint).max);\n    }\n\n    /**\n     * @dev Updates address where strategist fee earnings will go.\n     * @param _strategist new strategist address.\n     */\n    function setStrategist(address _strategist) external {\n        require(msg.sender == strategist, \"!strategist\");\n        strategist = _strategist;\n    }\n}\n"
    },
    "contracts/BIFI/strategies/Aave/StrategyAaveSupplyOnly.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/aave/IDataProvider.sol\";\nimport \"../../interfaces/aave/IIncentivesController.sol\";\nimport \"../../interfaces/aave/ILendingPool.sol\";\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../Common/FeeManager.sol\";\nimport \"../Common/StratManager.sol\";\n\ncontract StrategyAaveSupplyOnly is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    address public want;\n    address public aToken;\n\n    // Third party contracts\n    address constant public dataProvider = address(0x7551b5D2763519d4e37e8B81929D336De671d46d);\n    address constant public lendingPool = address(0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf);\n    address constant public incentivesController = address(0x357D51124f59836DeD84c8a1730D72B749d8BC23);\n\n    // Routes\n    address[] public wmaticToWantRoute;\n\n    /**\n     * @dev Events that the contract emits\n     */\n    event StratHarvest(address indexed harvester);\n\n    constructor(\n        address _want,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        (aToken,,) = IDataProvider(dataProvider).getReserveTokensAddresses(want);\n\n        if (want == eth) {\n            wmaticToWantRoute = [wmatic, eth];\n        } else if (want != wmatic) {\n            wmaticToWantRoute = [wmatic, eth, want];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal > 0) {\n            ILendingPool(lendingPool).deposit(want, wantBal, address(this), 0);\n        }\n    }\n\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n\n        if (wantBal < _amount) {\n            ILendingPool(lendingPool).withdraw(want, _amount.sub(wantBal), address(this));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        address[] memory assets = new address[](1);\n        assets[0] = aToken;\n        IIncentivesController(incentivesController).claimRewards(assets, type(uint).max, address(this));\n\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 wmaticFeeBal = IERC20(wmatic).balanceOf(address(this)).mul(45).div(1000);\n\n        uint256 callFeeAmount = wmaticFeeBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticFeeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticFeeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    // swap rewards to {want}\n    function swapRewards() internal {\n        uint256 wmaticBal = IERC20(wmatic).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(wmaticBal, 0, wmaticToWantRoute, address(this), block.timestamp);\n    }\n\n    // return supply and borrow balance\n    function userReserves() public view returns (uint256, uint256) {\n        (uint256 supplyBal,,uint256 borrowBal,,,,,,) = IDataProvider(dataProvider).getUserReserveData(want, address(this));\n        return (supplyBal, borrowBal);\n    }\n\n    // returns the user account data across all the reserves\n    function userAccountData() public view returns (\n        uint256 totalCollateralETH,\n        uint256 totalDebtETH,\n        uint256 availableBorrowsETH,\n        uint256 currentLiquidationThreshold,\n        uint256 ltv,\n        uint256 healthFactor\n    ) {\n        return ILendingPool(lendingPool).getUserAccountData(address(this));\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 supplyBal, uint256 borrowBal) = userReserves();\n        return supplyBal.sub(borrowBal);\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        ILendingPool(lendingPool).withdraw(want, type(uint).max, address(this));\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        ILendingPool(lendingPool).withdraw(want, type(uint).max, address(this));\n        pause();\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(lendingPool, type(uint256).max);\n        IERC20(wmatic).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(lendingPool, 0);\n        IERC20(wmatic).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/interfaces/aave/IDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IDataProvider {\n    function getReserveTokensAddresses(address asset) external view returns (\n        address aTokenAddress,\n        address stableDebtTokenAddress,\n        address variableDebtTokenAddress\n    );\n\n    function getUserReserveData(address asset, address user) external view returns (\n        uint256 currentATokenBalance,\n        uint256 currentStableDebt,\n        uint256 currentVariableDebt,\n        uint256 principalStableDebt,\n        uint256 scaledVariableDebt,\n        uint256 stableBorrowRate,\n        uint256 liquidityRate,\n        uint40 stableRateLastUpdated,\n        bool usageAsCollateralEnabled\n    );\n}"
    },
    "contracts/BIFI/interfaces/aave/IIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface IIncentivesController {\n    function claimRewards(address[] calldata assets, uint256 amount, address to) external returns (uint256);\n}"
    },
    "contracts/BIFI/interfaces/aave/ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\ninterface ILendingPool {\n\n    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;\n\n    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf) external;\n\n    function repay(address asset, uint256 amount, uint256 rateMode, address onBehalfOf) external returns (uint256);\n\n    function withdraw(address asset, uint256 amount, address to) external returns (uint256);\n\n    function getUserAccountData(address user) external view returns (\n        uint256 totalCollateralETH,\n        uint256 totalDebtETH,\n        uint256 availableBorrowsETH,\n        uint256 currentLiquidationThreshold,\n        uint256 ltv,\n        uint256 healthFactor\n    );\n}"
    },
    "contracts/BIFI/strategies/Aave/StrategyAaveMatic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/aave/IDataProvider.sol\";\nimport \"../../interfaces/aave/IIncentivesController.sol\";\nimport \"../../interfaces/aave/ILendingPool.sol\";\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../Common/FeeManager.sol\";\nimport \"../Common/StratManager.sol\";\n\ncontract StrategyAaveMatic is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public want = wmatic;\n    address public aToken;\n    address public varDebtToken;\n\n    // Third party contracts\n    address constant public dataProvider = address(0x7551b5D2763519d4e37e8B81929D336De671d46d);\n    address constant public lendingPool = address(0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf);\n    address constant public incentivesController = address(0x357D51124f59836DeD84c8a1730D72B749d8BC23);\n\n    /**\n     * @dev Variables that can be changed to config profitability and risk:\n     * {borrowRate}          - What % of our collateral do we borrow per leverage level.\n     * {borrowRateMax}       - A limit on how much we can push borrow risk.\n     * {borrowDepth}         - How many levels of leverage do we take.\n     * {minLeverage}         - The minimum amount of collateral required to leverage.\n     * {BORROW_DEPTH_MAX}    - A limit on how many steps we can leverage.\n     * {INTEREST_RATE_MODE}  - The type of borrow debt. Stable: 1, Variable: 2.\n     */\n    uint256 public borrowRate;\n    uint256 public borrowRateMax;\n    uint256 public borrowDepth;\n    uint256 public minLeverage;\n    uint256 constant public BORROW_DEPTH_MAX = 10;\n    uint256 constant public INTEREST_RATE_MODE = 2;\n\n    /**\n     * @dev Helps to differentiate borrowed funds that shouldn't be used in functions like 'deposit()'\n     * as they're required to deleverage correctly.\n     */\n    uint256 public reserves = 0;\n\n    /**\n     * @dev Events that the contract emits\n     */\n    event StratHarvest(address indexed harvester);\n    event StratRebalance(uint256 _borrowRate, uint256 _borrowDepth);\n\n    constructor(\n        uint256 _borrowRate,\n        uint256 _borrowRateMax,\n        uint256 _borrowDepth,\n        uint256 _minLeverage,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        (aToken,,varDebtToken) = IDataProvider(dataProvider).getReserveTokensAddresses(want);\n\n        borrowRate = _borrowRate;\n        borrowRateMax = _borrowRateMax;\n        borrowDepth = _borrowDepth;\n        minLeverage = _minLeverage;\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = availableWant();\n\n        if (wantBal > 0) {\n            _leverage(wantBal);\n        }\n    }\n\n    /**\n     * @dev Repeatedly supplies and borrows {want} following the configured {borrowRate} and {borrowDepth}\n     * @param _amount amount of {want} to leverage\n     */\n    function _leverage(uint256 _amount) internal {\n        if (_amount < minLeverage) { return; }\n\n        for (uint i = 0; i < borrowDepth; i++) {\n            ILendingPool(lendingPool).deposit(want, _amount, address(this), 0);\n            _amount = _amount.mul(borrowRate).div(100);\n            ILendingPool(lendingPool).borrow(want, _amount, INTEREST_RATE_MODE, 0, address(this));\n        }\n\n        reserves = reserves.add(_amount);\n    }\n\n\n    /**\n     * @dev Incrementally alternates between paying part of the debt and withdrawing part of the supplied\n     * collateral. Continues to do this until it repays the entire debt and withdraws all the supplied {want}\n     * from the system\n     */\n    function _deleverage() internal {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        (uint256 supplyBal, uint256 borrowBal) = userReserves();\n\n        while (wantBal < borrowBal) {\n            ILendingPool(lendingPool).repay(want, wantBal, INTEREST_RATE_MODE, address(this));\n\n            (supplyBal, borrowBal) = userReserves();\n            uint256 targetSupply = borrowBal.mul(100).div(borrowRate);\n\n            ILendingPool(lendingPool).withdraw(want, supplyBal.sub(targetSupply), address(this));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        ILendingPool(lendingPool).repay(want, type(uint256).max, INTEREST_RATE_MODE, address(this));\n        ILendingPool(lendingPool).withdraw(want, type(uint).max, address(this));\n\n        reserves = 0;\n    }\n\n    /**\n     * @dev Extra safety measure that allows us to manually unwind one level. In case we somehow get into\n     * as state where the cost of unwinding freezes the system. We can manually unwind a few levels\n     * with this function and then 'rebalance()' with new {borrowRate} and {borrowConfig} values.\n     * @param _borrowRate configurable borrow rate in case it's required to unwind successfully\n     */\n    function deleverageOnce(uint _borrowRate) external onlyManager {\n        require(_borrowRate <= borrowRateMax, \"!safe\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        ILendingPool(lendingPool).repay(want, wantBal, INTEREST_RATE_MODE, address(this));\n\n        (uint256 supplyBal, uint256 borrowBal) = userReserves();\n        uint256 targetSupply = borrowBal.mul(100).div(_borrowRate);\n\n        ILendingPool(lendingPool).withdraw(want, supplyBal.sub(targetSupply), address(this));\n\n        wantBal = IERC20(want).balanceOf(address(this));\n        reserves = wantBal;\n    }\n\n    /**\n     * @dev Updates the risk profile and rebalances the vault funds accordingly.\n     * @param _borrowRate percent to borrow on each leverage level.\n     * @param _borrowDepth how many levels to leverage the funds.\n     */\n    function rebalance(uint256 _borrowRate, uint256 _borrowDepth) external onlyManager {\n        require(_borrowRate <= borrowRateMax, \"!rate\");\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \"!depth\");\n\n        _deleverage();\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        _leverage(wantBal);\n\n        emit StratRebalance(_borrowRate, _borrowDepth);\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        uint _before = balanceOfWant();\n\n        address[] memory assets = new address[](2);\n        assets[0] = aToken;\n        assets[1] = varDebtToken;\n        IIncentivesController(incentivesController).claimRewards(assets, type(uint).max, address(this));\n\n        uint _after = balanceOfWant();\n        uint harvestedBal = _after.sub(_before);\n\n        chargeFees(harvestedBal);\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees(uint harvestedBal) internal {\n        uint256 wmaticFeeBal = harvestedBal.mul(45).div(1000);\n\n        uint256 callFeeAmount = wmaticFeeBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticFeeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticFeeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. It deleverages from venus first,\n     * and then deposits again after the withdraw to make sure it mantains the desired ratio.\n     * @param _amount How much {want} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = availableWant();\n\n        if (wantBal < _amount) {\n            _deleverage();\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n\n        if (!paused()) {\n            _leverage(availableWant());\n        }\n    }\n\n    /**\n     * @dev Required for various functions that need to deduct {reserves} from total {want}.\n     * @return how much {want} the contract holds without reserves\n     */\n    function availableWant() public view returns (uint256) {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        return wantBal.sub(reserves);\n    }\n\n    // return supply and borrow balance\n    function userReserves() public view returns (uint256, uint256) {\n        (uint256 supplyBal,,uint256 borrowBal,,,,,,) = IDataProvider(dataProvider).getUserReserveData(want, address(this));\n        return (supplyBal, borrowBal);\n    }\n\n    // returns the user account data across all the reserves\n    function userAccountData() public view returns (\n        uint256 totalCollateralETH,\n        uint256 totalDebtETH,\n        uint256 availableBorrowsETH,\n        uint256 currentLiquidationThreshold,\n        uint256 ltv,\n        uint256 healthFactor\n    ) {\n        return ILendingPool(lendingPool).getUserAccountData(address(this));\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 supplyBal, uint256 borrowBal) = userReserves();\n        return supplyBal.sub(borrowBal);\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        _deleverage();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        _deleverage();\n        pause();\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(lendingPool, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(lendingPool, 0);\n    }\n}"
    },
    "contracts/BIFI/strategies/Aave/StrategyAave.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\nimport \"../../interfaces/aave/IDataProvider.sol\";\nimport \"../../interfaces/aave/IIncentivesController.sol\";\nimport \"../../interfaces/aave/ILendingPool.sol\";\nimport \"../../interfaces/common/IUniswapRouterETH.sol\";\nimport \"../Common/FeeManager.sol\";\nimport \"../Common/StratManager.sol\";\n\ncontract StrategyAave is StratManager, FeeManager {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // Tokens used\n    address constant public wmatic = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n    address constant public eth = address(0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619);\n    address public want;\n    address public aToken;\n    address public varDebtToken;\n\n    // Third party contracts\n    address constant public dataProvider = address(0x7551b5D2763519d4e37e8B81929D336De671d46d);\n    address constant public lendingPool = address(0x8dFf5E27EA6b7AC08EbFdf9eB090F32ee9a30fcf);\n    address constant public incentivesController = address(0x357D51124f59836DeD84c8a1730D72B749d8BC23);\n\n    // Routes\n    address[] public wmaticToWantRoute;\n\n    /**\n     * @dev Variables that can be changed to config profitability and risk:\n     * {borrowRate}          - What % of our collateral do we borrow per leverage level.\n     * {borrowRateMax}       - A limit on how much we can push borrow risk.\n     * {borrowDepth}         - How many levels of leverage do we take.\n     * {minLeverage}         - The minimum amount of collateral required to leverage.\n     * {BORROW_DEPTH_MAX}    - A limit on how many steps we can leverage.\n     * {INTEREST_RATE_MODE}  - The type of borrow debt. Stable: 1, Variable: 2.\n     */\n    uint256 public borrowRate;\n    uint256 public borrowRateMax;\n    uint256 public borrowDepth;\n    uint256 public minLeverage;\n    uint256 constant public BORROW_DEPTH_MAX = 10;\n    uint256 constant public INTEREST_RATE_MODE = 2;\n\n    /**\n     * @dev Helps to differentiate borrowed funds that shouldn't be used in functions like 'deposit()'\n     * as they're required to deleverage correctly.\n     */\n    uint256 public reserves = 0;\n\n    /**\n     * @dev Events that the contract emits\n     */\n    event StratHarvest(address indexed harvester);\n    event StratRebalance(uint256 _borrowRate, uint256 _borrowDepth);\n\n    constructor(\n        address _want,\n        uint256 _borrowRate,\n        uint256 _borrowRateMax,\n        uint256 _borrowDepth,\n        uint256 _minLeverage,\n        address _vault,\n        address _unirouter,\n        address _keeper,\n        address _strategist,\n        address _beefyFeeRecipient\n    ) StratManager(_keeper, _strategist, _unirouter, _vault, _beefyFeeRecipient) {\n        want = _want;\n        (aToken,,varDebtToken) = IDataProvider(dataProvider).getReserveTokensAddresses(want);\n\n        borrowRate = _borrowRate;\n        borrowRateMax = _borrowRateMax;\n        borrowDepth = _borrowDepth;\n        minLeverage = _minLeverage;\n\n        if (want == eth) {\n            wmaticToWantRoute = [wmatic, eth];\n        } else if (want != wmatic) {\n            wmaticToWantRoute = [wmatic, eth, want];\n        }\n\n        _giveAllowances();\n    }\n\n    // puts the funds to work\n    function deposit() public whenNotPaused {\n        uint256 wantBal = availableWant();\n\n        if (wantBal > 0) {\n            _leverage(wantBal);\n        }\n    }\n\n    /**\n     * @dev Repeatedly supplies and borrows {want} following the configured {borrowRate} and {borrowDepth}\n     * @param _amount amount of {want} to leverage\n     */\n    function _leverage(uint256 _amount) internal {\n        if (_amount < minLeverage) { return; }\n\n        for (uint i = 0; i < borrowDepth; i++) {\n            ILendingPool(lendingPool).deposit(want, _amount, address(this), 0);\n            _amount = _amount.mul(borrowRate).div(100);\n            ILendingPool(lendingPool).borrow(want, _amount, INTEREST_RATE_MODE, 0, address(this));\n        }\n\n        reserves = reserves.add(_amount);\n    }\n\n\n    /**\n     * @dev Incrementally alternates between paying part of the debt and withdrawing part of the supplied\n     * collateral. Continues to do this until it repays the entire debt and withdraws all the supplied {want}\n     * from the system\n     */\n    function _deleverage() internal {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        (uint256 supplyBal, uint256 borrowBal) = userReserves();\n\n        while (wantBal < borrowBal) {\n            ILendingPool(lendingPool).repay(want, wantBal, INTEREST_RATE_MODE, address(this));\n\n            (supplyBal, borrowBal) = userReserves();\n            uint256 targetSupply = borrowBal.mul(100).div(borrowRate);\n\n            ILendingPool(lendingPool).withdraw(want, supplyBal.sub(targetSupply), address(this));\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        ILendingPool(lendingPool).repay(want, type(uint256).max, INTEREST_RATE_MODE, address(this));\n        ILendingPool(lendingPool).withdraw(want, type(uint).max, address(this));\n\n        reserves = 0;\n    }\n\n    /**\n     * @dev Extra safety measure that allows us to manually unwind one level. In case we somehow get into\n     * as state where the cost of unwinding freezes the system. We can manually unwind a few levels\n     * with this function and then 'rebalance()' with new {borrowRate} and {borrowConfig} values.\n     * @param _borrowRate configurable borrow rate in case it's required to unwind successfully\n     */\n    function deleverageOnce(uint _borrowRate) external onlyManager {\n        require(_borrowRate <= borrowRateMax, \"!safe\");\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        ILendingPool(lendingPool).repay(want, wantBal, INTEREST_RATE_MODE, address(this));\n\n        (uint256 supplyBal, uint256 borrowBal) = userReserves();\n        uint256 targetSupply = borrowBal.mul(100).div(_borrowRate);\n\n        ILendingPool(lendingPool).withdraw(want, supplyBal.sub(targetSupply), address(this));\n\n        wantBal = IERC20(want).balanceOf(address(this));\n        reserves = wantBal;\n    }\n\n    /**\n     * @dev Updates the risk profile and rebalances the vault funds accordingly.\n     * @param _borrowRate percent to borrow on each leverage level.\n     * @param _borrowDepth how many levels to leverage the funds.\n     */\n    function rebalance(uint256 _borrowRate, uint256 _borrowDepth) external onlyManager {\n        require(_borrowRate <= borrowRateMax, \"!rate\");\n        require(_borrowDepth <= BORROW_DEPTH_MAX, \"!depth\");\n\n        _deleverage();\n        borrowRate = _borrowRate;\n        borrowDepth = _borrowDepth;\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        _leverage(wantBal);\n\n        emit StratRebalance(_borrowRate, _borrowDepth);\n    }\n\n    // compounds earnings and charges performance fee\n    function harvest() external whenNotPaused onlyEOA {\n        address[] memory assets = new address[](2);\n        assets[0] = aToken;\n        assets[1] = varDebtToken;\n        IIncentivesController(incentivesController).claimRewards(assets, type(uint).max, address(this));\n\n        chargeFees();\n        swapRewards();\n        deposit();\n\n        emit StratHarvest(msg.sender);\n    }\n\n    // performance fees\n    function chargeFees() internal {\n        uint256 wmaticFeeBal = IERC20(wmatic).balanceOf(address(this)).mul(45).div(1000);\n\n        uint256 callFeeAmount = wmaticFeeBal.mul(callFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(msg.sender, callFeeAmount);\n\n        uint256 beefyFeeAmount = wmaticFeeBal.mul(beefyFee).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(beefyFeeRecipient, beefyFeeAmount);\n\n        uint256 strategistFee = wmaticFeeBal.mul(STRATEGIST_FEE).div(MAX_FEE);\n        IERC20(wmatic).safeTransfer(strategist, strategistFee);\n    }\n\n    // swap rewards to {want}\n    function swapRewards() internal {\n        uint256 wmaticBal = IERC20(wmatic).balanceOf(address(this));\n        IUniswapRouterETH(unirouter).swapExactTokensForTokens(wmaticBal, 0, wmaticToWantRoute, address(this), block.timestamp);\n    }\n\n    /**\n     * @dev Withdraws funds and sends them back to the vault. It deleverages from venus first,\n     * and then deposits again after the withdraw to make sure it mantains the desired ratio.\n     * @param _amount How much {want} to withdraw.\n     */\n    function withdraw(uint256 _amount) external {\n        require(msg.sender == vault, \"!vault\");\n\n        uint256 wantBal = availableWant();\n\n        if (wantBal < _amount) {\n            _deleverage();\n            wantBal = IERC20(want).balanceOf(address(this));\n        }\n\n        if (wantBal > _amount) {\n            wantBal = _amount;\n        }\n\n        if (tx.origin == owner() || paused()) {\n            IERC20(want).safeTransfer(vault, wantBal);\n        } else {\n            uint256 withdrawalFeeAmount = wantBal.mul(withdrawalFee).div(WITHDRAWAL_MAX);\n            IERC20(want).safeTransfer(vault, wantBal.sub(withdrawalFeeAmount));\n        }\n\n        if (!paused()) {\n            _leverage(availableWant());\n        }\n    }\n\n    /**\n     * @dev Required for various functions that need to deduct {reserves} from total {want}.\n     * @return how much {want} the contract holds without reserves\n     */\n    function availableWant() public view returns (uint256) {\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        return wantBal.sub(reserves);\n    }\n\n    // return supply and borrow balance\n    function userReserves() public view returns (uint256, uint256) {\n        (uint256 supplyBal,,uint256 borrowBal,,,,,,) = IDataProvider(dataProvider).getUserReserveData(want, address(this));\n        return (supplyBal, borrowBal);\n    }\n\n    // returns the user account data across all the reserves\n    function userAccountData() public view returns (\n        uint256 totalCollateralETH,\n        uint256 totalDebtETH,\n        uint256 availableBorrowsETH,\n        uint256 currentLiquidationThreshold,\n        uint256 ltv,\n        uint256 healthFactor\n    ) {\n        return ILendingPool(lendingPool).getUserAccountData(address(this));\n    }\n\n    // calculate the total underlaying 'want' held by the strat.\n    function balanceOf() public view returns (uint256) {\n        return balanceOfWant().add(balanceOfPool());\n    }\n\n    // it calculates how much 'want' this contract holds.\n    function balanceOfWant() public view returns (uint256) {\n        return IERC20(want).balanceOf(address(this));\n    }\n\n    // it calculates how much 'want' the strategy has working in the farm.\n    function balanceOfPool() public view returns (uint256) {\n        (uint256 supplyBal, uint256 borrowBal) = userReserves();\n        return supplyBal.sub(borrowBal);\n    }\n\n    // called as part of strat migration. Sends all the available funds back to the vault.\n    function retireStrat() external {\n        require(msg.sender == vault, \"!vault\");\n\n        _deleverage();\n\n        uint256 wantBal = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(vault, wantBal);\n    }\n\n    // pauses deposits and withdraws all funds from third party systems.\n    function panic() public onlyManager {\n        _deleverage();\n        pause();\n    }\n\n    function pause() public onlyManager {\n        _pause();\n\n        _removeAllowances();\n    }\n\n    function unpause() external onlyManager {\n        _unpause();\n\n        _giveAllowances();\n\n        deposit();\n    }\n\n    function _giveAllowances() internal {\n        IERC20(want).safeApprove(lendingPool, type(uint256).max);\n        IERC20(wmatic).safeApprove(unirouter, type(uint256).max);\n    }\n\n    function _removeAllowances() internal {\n        IERC20(want).safeApprove(lendingPool, 0);\n        IERC20(wmatic).safeApprove(unirouter, 0);\n    }\n}"
    },
    "contracts/BIFI/infra/BeefyTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract BeefyTreasury is Ownable {\n    using SafeERC20 for IERC20;\n\n    function withdrawTokens(address _token, address _to, uint256 _amount) external onlyOwner {\n        IERC20(_token).safeTransfer(_to, _amount);\n    }\n\n    function withdrawNative(address payable _to, uint256 _amount) external onlyOwner {\n        _to.transfer(_amount);\n    }\n\n    receive () external payable {}\n}"
    },
    "contracts/BIFI/infra/BeefyFeeBatchSimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract BeefyFeeBatchSimple is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    address public immutable treasury;\n    address public immutable rewardPool;\n    address public immutable wNative ;\n\n    // Fee constants\n    uint constant public TREASURY_FEE = 140;\n    uint constant public REWARD_POOL_FEE = 860;\n    uint constant public MAX_FEE = 1000;\n\n    constructor(\n        address _treasury,\n        address _rewardPool,\n        address _wNative\n    ) {\n        treasury = _treasury;\n        rewardPool = _rewardPool;\n        wNative  = _wNative ;\n    }\n\n    // Main function. Divides Beefy's profits.\n    function harvest() public {\n        uint256 wNativeBal = IERC20(wNative).balanceOf(address(this));\n\n        uint256 treasuryAmount = wNativeBal.mul(TREASURY_FEE).div(MAX_FEE);\n        IERC20(wNative).safeTransfer(treasury, treasuryAmount);\n\n        uint256 rewardPoolAmount = wNativeBal.mul(REWARD_POOL_FEE).div(MAX_FEE);\n        IERC20(wNative).safeTransfer(rewardPool, rewardPoolAmount);\n    }\n\n    // Rescue locked funds sent by mistake\n    function inCaseTokensGetStuck(address _token) external onlyOwner {\n        require(_token != wNative, \"!safe\");\n\n        uint256 amount = IERC20(_token).balanceOf(address(this));\n        IERC20(_token).safeTransfer(msg.sender, amount);\n    }\n}"
    },
    "contracts/BIFI/mocks/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    constructor(\n        uint256 _initialSupply,\n        string memory _name,\n        string memory _symbol\n    ) ERC20(_name, _symbol) {\n        _mint(msg.sender, _initialSupply);\n    }\n}"
    },
    "contracts/BIFI/interfaces/common/IWrappedNative.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IWrappedNative is IERC20 {\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping (bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId\n            || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if(!hasRole(role, account)) {\n            revert(string(abi.encodePacked(\n                \"AccessControl: account \",\n                Strings.toHexString(uint160(account), 20),\n                \" is missing role \",\n                Strings.toHexString(uint256(role), 32)\n            )));\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n        _roles[role].adminRole = adminRole;\n    }\n\n    function _grantRole(bytes32 role, address account) private {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    function _revokeRole(bytes32 role, address account) private {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data, bytes32 predecessor, uint256 delay);\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`.\n     */\n    constructor(uint256 minDelay, address[] memory proposers, address[] memory executors) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        // solhint-disable-next-line not-rely-on-time\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, datas, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt, uint256 delay) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], datas[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        // solhint-disable-next-line not-rely-on-time\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(PROPOSER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _beforeCall(predecessor);\n        _call(id, 0, target, value, data);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == datas.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, datas, predecessor, salt);\n        _beforeCall(predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            _call(id, i, targets[i], values[i], datas[i]);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 predecessor) private view {\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     *\n     * Emits a {CallExecuted} event.\n     */\n    function _call(bytes32 id, uint256 index, address target, uint256 value, bytes calldata data) private {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success,) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n\n        emit CallExecuted(id, index, target, value, data);\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n}\n"
    },
    "contracts/BIFI/utils/Imports.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/governance/TimelockController.sol\";\n"
    },
    "contracts/BIFI/utils/GasPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract GasPrice is Ownable {\n\n    uint public maxGasPrice = 10000000000; // 10 gwei\n\n    event NewMaxGasPrice(uint oldPrice, uint newPrice);\n\n    function setMaxGasPrice(uint _maxGasPrice) external onlyOwner {\n        emit NewMaxGasPrice(maxGasPrice, _maxGasPrice);\n        maxGasPrice = _maxGasPrice;\n    }\n}"
    },
    "contracts/BIFI/mocks/ExposedStrategyVenusBNB.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\npragma abicoder v1;\n\nimport \"../strategies/Venus/StrategyVenusBNB.sol\";\n\ncontract ExposedStrategyVenusBNB is StrategyVenusBNB {\n    constructor(\n        address _vault,\n        uint256 _borrowRate,\n        uint256 _borrowDepth,\n        address[] memory _markets\n    ) StrategyVenusBNB(\n        _vault,\n        _borrowRate,\n        _borrowDepth,\n        _markets\n    ) {}\n\n    function leverage(uint256 _amount) public  {\n        _leverage(_amount);\n    }\n\n    function deleverage() public  {\n        _deleverage();\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}